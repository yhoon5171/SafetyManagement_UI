{"ast":null,"code":"/*\r\n This file is part of web3.js.\r\n\r\n web3.js is free software: you can redistribute it and/or modify\r\n it under the terms of the GNU Lesser General Public License as published by\r\n the Free Software Foundation, either version 3 of the License, or\r\n (at your option) any later version.\r\n\r\n web3.js is distributed in the hope that it will be useful,\r\n but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n GNU Lesser General Public License for more details.\r\n\r\n You should have received a copy of the GNU Lesser General Public License\r\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n */\n\n/**\r\n * @file index.js\r\n * @author Marek Kotewicz <marek@parity.io>\r\n * @author Fabian Vogelsteller <fabian@frozeman.de>\r\n * @date 2018\r\n */\nvar _ = require('underscore');\n\nvar utils = require('web3-utils');\n\nvar EthersAbi = require('ethers/utils/abi-coder').AbiCoder;\n\nvar ethersAbiCoder = new EthersAbi(function (type, value) {\n  if (type.match(/^u?int/) && !_.isArray(value) && (!_.isObject(value) || value.constructor.name !== 'BN')) {\n    return value.toString();\n  }\n\n  return value;\n}); // result method\n\nfunction Result() {}\n/**\r\n * ABICoder prototype should be used to encode/decode solidity params of any type\r\n */\n\n\nvar ABICoder = function () {};\n/**\r\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\r\n *\r\n * @method encodeFunctionSignature\r\n * @param {String|Object} functionName\r\n * @return {String} encoded function name\r\n */\n\n\nABICoder.prototype.encodeFunctionSignature = function (functionName) {\n  if (_.isObject(functionName)) {\n    functionName = utils._jsonInterfaceMethodToString(functionName);\n  }\n\n  return utils.sha3(functionName).slice(0, 10);\n};\n/**\r\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\r\n *\r\n * @method encodeEventSignature\r\n * @param {String|Object} functionName\r\n * @return {String} encoded function name\r\n */\n\n\nABICoder.prototype.encodeEventSignature = function (functionName) {\n  if (_.isObject(functionName)) {\n    functionName = utils._jsonInterfaceMethodToString(functionName);\n  }\n\n  return utils.sha3(functionName);\n};\n/**\r\n * Should be used to encode plain param\r\n *\r\n * @method encodeParameter\r\n * @param {String} type\r\n * @param {Object} param\r\n * @return {String} encoded plain param\r\n */\n\n\nABICoder.prototype.encodeParameter = function (type, param) {\n  return this.encodeParameters([type], [param]);\n};\n/**\r\n * Should be used to encode list of params\r\n *\r\n * @method encodeParameters\r\n * @param {Array} types\r\n * @param {Array} params\r\n * @return {String} encoded list of params\r\n */\n\n\nABICoder.prototype.encodeParameters = function (types, params) {\n  return ethersAbiCoder.encode(this.mapTypes(types), params);\n};\n/**\r\n * Map types if simplified format is used\r\n *\r\n * @method mapTypes\r\n * @param {Array} types\r\n * @return {Array}\r\n */\n\n\nABICoder.prototype.mapTypes = function (types) {\n  var self = this;\n  var mappedTypes = [];\n  types.forEach(function (type) {\n    if (self.isSimplifiedStructFormat(type)) {\n      var structName = Object.keys(type)[0];\n      mappedTypes.push(Object.assign(self.mapStructNameAndType(structName), {\n        components: self.mapStructToCoderFormat(type[structName])\n      }));\n      return;\n    }\n\n    mappedTypes.push(type);\n  });\n  return mappedTypes;\n};\n/**\r\n * Check if type is simplified struct format\r\n *\r\n * @method isSimplifiedStructFormat\r\n * @param {string | Object} type\r\n * @returns {boolean}\r\n */\n\n\nABICoder.prototype.isSimplifiedStructFormat = function (type) {\n  return typeof type === 'object' && typeof type.components === 'undefined' && typeof type.name === 'undefined';\n};\n/**\r\n * Maps the correct tuple type and name when the simplified format in encode/decodeParameter is used\r\n *\r\n * @method mapStructNameAndType\r\n * @param {string} structName\r\n * @return {{type: string, name: *}}\r\n */\n\n\nABICoder.prototype.mapStructNameAndType = function (structName) {\n  var type = 'tuple';\n\n  if (structName.indexOf('[]') > -1) {\n    type = 'tuple[]';\n    structName = structName.slice(0, -2);\n  }\n\n  return {\n    type: type,\n    name: structName\n  };\n};\n/**\r\n * Maps the simplified format in to the expected format of the ABICoder\r\n *\r\n * @method mapStructToCoderFormat\r\n * @param {Object} struct\r\n * @return {Array}\r\n */\n\n\nABICoder.prototype.mapStructToCoderFormat = function (struct) {\n  var self = this;\n  var components = [];\n  Object.keys(struct).forEach(function (key) {\n    if (typeof struct[key] === 'object') {\n      components.push(Object.assign(self.mapStructNameAndType(key), {\n        components: self.mapStructToCoderFormat(struct[key])\n      }));\n      return;\n    }\n\n    components.push({\n      name: key,\n      type: struct[key]\n    });\n  });\n  return components;\n};\n/**\r\n * Encodes a function call from its json interface and parameters.\r\n *\r\n * @method encodeFunctionCall\r\n * @param {Array} jsonInterface\r\n * @param {Array} params\r\n * @return {String} The encoded ABI for this function call\r\n */\n\n\nABICoder.prototype.encodeFunctionCall = function (jsonInterface, params) {\n  return this.encodeFunctionSignature(jsonInterface) + this.encodeParameters(jsonInterface.inputs, params).replace('0x', '');\n};\n/**\r\n * Should be used to decode bytes to plain param\r\n *\r\n * @method decodeParameter\r\n * @param {String} type\r\n * @param {String} bytes\r\n * @return {Object} plain param\r\n */\n\n\nABICoder.prototype.decodeParameter = function (type, bytes) {\n  return this.decodeParameters([type], bytes)[0];\n};\n/**\r\n * Should be used to decode list of params\r\n *\r\n * @method decodeParameter\r\n * @param {Array} outputs\r\n * @param {String} bytes\r\n * @return {Array} array of plain params\r\n */\n\n\nABICoder.prototype.decodeParameters = function (outputs, bytes) {\n  if (outputs.length > 0 && (!bytes || bytes === '0x' || bytes === '0X')) {\n    throw new Error('Returned values aren\\'t valid, did it run Out of Gas?');\n  }\n\n  var res = ethersAbiCoder.decode(this.mapTypes(outputs), '0x' + bytes.replace(/0x/i, ''));\n  var returnValue = new Result();\n  returnValue.__length__ = 0;\n  outputs.forEach(function (output, i) {\n    var decodedValue = res[returnValue.__length__];\n    decodedValue = decodedValue === '0x' ? null : decodedValue;\n    returnValue[i] = decodedValue;\n\n    if (_.isObject(output) && output.name) {\n      returnValue[output.name] = decodedValue;\n    }\n\n    returnValue.__length__++;\n  });\n  return returnValue;\n};\n/**\r\n * Decodes events non- and indexed parameters.\r\n *\r\n * @method decodeLog\r\n * @param {Object} inputs\r\n * @param {String} data\r\n * @param {Array} topics\r\n * @return {Array} array of plain params\r\n */\n\n\nABICoder.prototype.decodeLog = function (inputs, data, topics) {\n  var _this = this;\n\n  topics = _.isArray(topics) ? topics : [topics];\n  data = data || '';\n  var notIndexedInputs = [];\n  var indexedParams = [];\n  var topicCount = 0; // TODO check for anonymous logs?\n\n  inputs.forEach(function (input, i) {\n    if (input.indexed) {\n      indexedParams[i] = ['bool', 'int', 'uint', 'address', 'fixed', 'ufixed'].find(function (staticType) {\n        return input.type.indexOf(staticType) !== -1;\n      }) ? _this.decodeParameter(input.type, topics[topicCount]) : topics[topicCount];\n      topicCount++;\n    } else {\n      notIndexedInputs[i] = input;\n    }\n  });\n  var nonIndexedData = data;\n  var notIndexedParams = nonIndexedData ? this.decodeParameters(notIndexedInputs, nonIndexedData) : [];\n  var returnValue = new Result();\n  returnValue.__length__ = 0;\n  inputs.forEach(function (res, i) {\n    returnValue[i] = res.type === 'string' ? '' : null;\n\n    if (typeof notIndexedParams[i] !== 'undefined') {\n      returnValue[i] = notIndexedParams[i];\n    }\n\n    if (typeof indexedParams[i] !== 'undefined') {\n      returnValue[i] = indexedParams[i];\n    }\n\n    if (res.name) {\n      returnValue[res.name] = returnValue[i];\n    }\n\n    returnValue.__length__++;\n  });\n  return returnValue;\n};\n\nvar coder = new ABICoder();\nmodule.exports = coder;","map":{"version":3,"names":["_","require","utils","EthersAbi","AbiCoder","ethersAbiCoder","type","value","match","isArray","isObject","constructor","name","toString","Result","ABICoder","prototype","encodeFunctionSignature","functionName","_jsonInterfaceMethodToString","sha3","slice","encodeEventSignature","encodeParameter","param","encodeParameters","types","params","encode","mapTypes","self","mappedTypes","forEach","isSimplifiedStructFormat","structName","Object","keys","push","assign","mapStructNameAndType","components","mapStructToCoderFormat","indexOf","struct","key","encodeFunctionCall","jsonInterface","inputs","replace","decodeParameter","bytes","decodeParameters","outputs","length","Error","res","decode","returnValue","__length__","output","i","decodedValue","decodeLog","data","topics","_this","notIndexedInputs","indexedParams","topicCount","input","indexed","find","staticType","nonIndexedData","notIndexedParams","coder","module","exports"],"sources":["D:/공프기/Capstone test/SafetyManagement_UI/client/node_modules/web3-eth-abi/src/index.js"],"sourcesContent":["/*\r\n This file is part of web3.js.\r\n\r\n web3.js is free software: you can redistribute it and/or modify\r\n it under the terms of the GNU Lesser General Public License as published by\r\n the Free Software Foundation, either version 3 of the License, or\r\n (at your option) any later version.\r\n\r\n web3.js is distributed in the hope that it will be useful,\r\n but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n GNU Lesser General Public License for more details.\r\n\r\n You should have received a copy of the GNU Lesser General Public License\r\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\n/**\r\n * @file index.js\r\n * @author Marek Kotewicz <marek@parity.io>\r\n * @author Fabian Vogelsteller <fabian@frozeman.de>\r\n * @date 2018\r\n */\r\n\r\nvar _ = require('underscore');\r\nvar utils = require('web3-utils');\r\n\r\nvar EthersAbi = require('ethers/utils/abi-coder').AbiCoder;\r\nvar ethersAbiCoder = new EthersAbi(function (type, value) {\r\n    if (type.match(/^u?int/) && !_.isArray(value) && (!_.isObject(value) || value.constructor.name !== 'BN')) {\r\n        return value.toString();\r\n    }\r\n    return value;\r\n});\r\n\r\n// result method\r\nfunction Result() {\r\n}\r\n\r\n/**\r\n * ABICoder prototype should be used to encode/decode solidity params of any type\r\n */\r\nvar ABICoder = function () {\r\n};\r\n\r\n/**\r\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\r\n *\r\n * @method encodeFunctionSignature\r\n * @param {String|Object} functionName\r\n * @return {String} encoded function name\r\n */\r\nABICoder.prototype.encodeFunctionSignature = function (functionName) {\r\n    if (_.isObject(functionName)) {\r\n        functionName = utils._jsonInterfaceMethodToString(functionName);\r\n    }\r\n\r\n    return utils.sha3(functionName).slice(0, 10);\r\n};\r\n\r\n/**\r\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\r\n *\r\n * @method encodeEventSignature\r\n * @param {String|Object} functionName\r\n * @return {String} encoded function name\r\n */\r\nABICoder.prototype.encodeEventSignature = function (functionName) {\r\n    if (_.isObject(functionName)) {\r\n        functionName = utils._jsonInterfaceMethodToString(functionName);\r\n    }\r\n\r\n    return utils.sha3(functionName);\r\n};\r\n\r\n/**\r\n * Should be used to encode plain param\r\n *\r\n * @method encodeParameter\r\n * @param {String} type\r\n * @param {Object} param\r\n * @return {String} encoded plain param\r\n */\r\nABICoder.prototype.encodeParameter = function (type, param) {\r\n    return this.encodeParameters([type], [param]);\r\n};\r\n\r\n/**\r\n * Should be used to encode list of params\r\n *\r\n * @method encodeParameters\r\n * @param {Array} types\r\n * @param {Array} params\r\n * @return {String} encoded list of params\r\n */\r\nABICoder.prototype.encodeParameters = function (types, params) {\r\n    return ethersAbiCoder.encode(this.mapTypes(types), params);\r\n};\r\n\r\n/**\r\n * Map types if simplified format is used\r\n *\r\n * @method mapTypes\r\n * @param {Array} types\r\n * @return {Array}\r\n */\r\nABICoder.prototype.mapTypes = function (types) {\r\n    var self = this;\r\n    var mappedTypes = [];\r\n    types.forEach(function (type) {\r\n        if (self.isSimplifiedStructFormat(type)) {\r\n            var structName = Object.keys(type)[0];\r\n            mappedTypes.push(\r\n                Object.assign(\r\n                    self.mapStructNameAndType(structName),\r\n                    {\r\n                        components: self.mapStructToCoderFormat(type[structName])\r\n                    }\r\n                )\r\n            );\r\n\r\n            return;\r\n        }\r\n\r\n        mappedTypes.push(type);\r\n    });\r\n\r\n    return mappedTypes;\r\n};\r\n\r\n/**\r\n * Check if type is simplified struct format\r\n *\r\n * @method isSimplifiedStructFormat\r\n * @param {string | Object} type\r\n * @returns {boolean}\r\n */\r\nABICoder.prototype.isSimplifiedStructFormat = function (type) {\r\n    return typeof type === 'object' && typeof type.components === 'undefined' && typeof type.name === 'undefined';\r\n};\r\n\r\n/**\r\n * Maps the correct tuple type and name when the simplified format in encode/decodeParameter is used\r\n *\r\n * @method mapStructNameAndType\r\n * @param {string} structName\r\n * @return {{type: string, name: *}}\r\n */\r\nABICoder.prototype.mapStructNameAndType = function (structName) {\r\n    var type = 'tuple';\r\n\r\n    if (structName.indexOf('[]') > -1) {\r\n        type = 'tuple[]';\r\n        structName = structName.slice(0, -2);\r\n    }\r\n\r\n    return {type: type, name: structName};\r\n};\r\n\r\n/**\r\n * Maps the simplified format in to the expected format of the ABICoder\r\n *\r\n * @method mapStructToCoderFormat\r\n * @param {Object} struct\r\n * @return {Array}\r\n */\r\nABICoder.prototype.mapStructToCoderFormat = function (struct) {\r\n    var self = this;\r\n    var components = [];\r\n    Object.keys(struct).forEach(function (key) {\r\n        if (typeof struct[key] === 'object') {\r\n            components.push(\r\n                Object.assign(\r\n                    self.mapStructNameAndType(key),\r\n                    {\r\n                        components: self.mapStructToCoderFormat(struct[key])\r\n                    }\r\n                )\r\n            );\r\n\r\n            return;\r\n        }\r\n\r\n        components.push({\r\n            name: key,\r\n            type: struct[key]\r\n        });\r\n    });\r\n\r\n    return components;\r\n};\r\n\r\n/**\r\n * Encodes a function call from its json interface and parameters.\r\n *\r\n * @method encodeFunctionCall\r\n * @param {Array} jsonInterface\r\n * @param {Array} params\r\n * @return {String} The encoded ABI for this function call\r\n */\r\nABICoder.prototype.encodeFunctionCall = function (jsonInterface, params) {\r\n    return this.encodeFunctionSignature(jsonInterface) + this.encodeParameters(jsonInterface.inputs, params).replace('0x', '');\r\n};\r\n\r\n/**\r\n * Should be used to decode bytes to plain param\r\n *\r\n * @method decodeParameter\r\n * @param {String} type\r\n * @param {String} bytes\r\n * @return {Object} plain param\r\n */\r\nABICoder.prototype.decodeParameter = function (type, bytes) {\r\n    return this.decodeParameters([type], bytes)[0];\r\n};\r\n\r\n/**\r\n * Should be used to decode list of params\r\n *\r\n * @method decodeParameter\r\n * @param {Array} outputs\r\n * @param {String} bytes\r\n * @return {Array} array of plain params\r\n */\r\nABICoder.prototype.decodeParameters = function (outputs, bytes) {\r\n    if (outputs.length > 0 && (!bytes || bytes === '0x' || bytes === '0X')) {\r\n        throw new Error('Returned values aren\\'t valid, did it run Out of Gas?');\r\n    }\r\n\r\n    var res = ethersAbiCoder.decode(this.mapTypes(outputs), '0x' + bytes.replace(/0x/i, ''));\r\n    var returnValue = new Result();\r\n    returnValue.__length__ = 0;\r\n\r\n    outputs.forEach(function (output, i) {\r\n        var decodedValue = res[returnValue.__length__];\r\n        decodedValue = (decodedValue === '0x') ? null : decodedValue;\r\n\r\n        returnValue[i] = decodedValue;\r\n\r\n        if (_.isObject(output) && output.name) {\r\n            returnValue[output.name] = decodedValue;\r\n        }\r\n\r\n        returnValue.__length__++;\r\n    });\r\n\r\n    return returnValue;\r\n};\r\n\r\n/**\r\n * Decodes events non- and indexed parameters.\r\n *\r\n * @method decodeLog\r\n * @param {Object} inputs\r\n * @param {String} data\r\n * @param {Array} topics\r\n * @return {Array} array of plain params\r\n */\r\nABICoder.prototype.decodeLog = function (inputs, data, topics) {\r\n    var _this = this;\r\n    topics = _.isArray(topics) ? topics : [topics];\r\n\r\n    data = data || '';\r\n\r\n    var notIndexedInputs = [];\r\n    var indexedParams = [];\r\n    var topicCount = 0;\r\n\r\n    // TODO check for anonymous logs?\r\n\r\n    inputs.forEach(function (input, i) {\r\n        if (input.indexed) {\r\n            indexedParams[i] = (['bool', 'int', 'uint', 'address', 'fixed', 'ufixed'].find(function (staticType) {\r\n                return input.type.indexOf(staticType) !== -1;\r\n            })) ? _this.decodeParameter(input.type, topics[topicCount]) : topics[topicCount];\r\n            topicCount++;\r\n        } else {\r\n            notIndexedInputs[i] = input;\r\n        }\r\n    });\r\n\r\n\r\n    var nonIndexedData = data;\r\n    var notIndexedParams = (nonIndexedData) ? this.decodeParameters(notIndexedInputs, nonIndexedData) : [];\r\n\r\n    var returnValue = new Result();\r\n    returnValue.__length__ = 0;\r\n\r\n\r\n    inputs.forEach(function (res, i) {\r\n        returnValue[i] = (res.type === 'string') ? '' : null;\r\n\r\n        if (typeof notIndexedParams[i] !== 'undefined') {\r\n            returnValue[i] = notIndexedParams[i];\r\n        }\r\n        if (typeof indexedParams[i] !== 'undefined') {\r\n            returnValue[i] = indexedParams[i];\r\n        }\r\n\r\n        if (res.name) {\r\n            returnValue[res.name] = returnValue[i];\r\n        }\r\n\r\n        returnValue.__length__++;\r\n    });\r\n\r\n    return returnValue;\r\n};\r\n\r\nvar coder = new ABICoder();\r\n\r\nmodule.exports = coder;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n\nimport { Coder } from \"./abstract-coder\";\nimport { pack, unpack } from \"./array\";\nexport class TupleCoder extends Coder {\n  constructor(coders, localName) {\n    let dynamic = false;\n    const types = [];\n    coders.forEach(coder => {\n      if (coder.dynamic) {\n        dynamic = true;\n      }\n\n      types.push(coder.type);\n    });\n    const type = \"tuple(\" + types.join(\",\") + \")\";\n    super(\"tuple\", type, localName, dynamic);\n    this.coders = coders;\n  }\n\n  defaultValue() {\n    const values = [];\n    this.coders.forEach(coder => {\n      values.push(coder.defaultValue());\n    }); // We only output named properties for uniquely named coders\n\n    const uniqueNames = this.coders.reduce((accum, coder) => {\n      const name = coder.localName;\n\n      if (name) {\n        if (!accum[name]) {\n          accum[name] = 0;\n        }\n\n        accum[name]++;\n      }\n\n      return accum;\n    }, {}); // Add named values\n\n    this.coders.forEach((coder, index) => {\n      let name = coder.localName;\n\n      if (!name || uniqueNames[name] !== 1) {\n        return;\n      }\n\n      if (name === \"length\") {\n        name = \"_length\";\n      }\n\n      if (values[name] != null) {\n        return;\n      }\n\n      values[name] = values[index];\n    });\n    return Object.freeze(values);\n  }\n\n  encode(writer, value) {\n    return pack(writer, this.coders, value);\n  }\n\n  decode(reader) {\n    return reader.coerce(this.name, unpack(reader, this.coders));\n  }\n\n}","map":{"version":3,"sources":["../../src.ts/coders/tuple.ts"],"names":[],"mappings":"AAAA;;AAEA,SAAS,KAAT,QAAsC,kBAAtC;AACA,SAAS,IAAT,EAAe,MAAf,QAA6B,SAA7B;AAEA,OAAM,MAAO,UAAP,SAA0B,KAA1B,CAA+B;EAGjC,WAAA,CAAY,MAAZ,EAAkC,SAAlC,EAAmD;IAC/C,IAAI,OAAO,GAAG,KAAd;IACA,MAAM,KAAK,GAAkB,EAA7B;IACA,MAAM,CAAC,OAAP,CAAgB,KAAD,IAAU;MACrB,IAAI,KAAK,CAAC,OAAV,EAAmB;QAAE,OAAO,GAAG,IAAV;MAAiB;;MACtC,KAAK,CAAC,IAAN,CAAW,KAAK,CAAC,IAAjB;IACH,CAHD;IAIA,MAAM,IAAI,GAAI,WAAW,KAAK,CAAC,IAAN,CAAW,GAAX,CAAX,GAA6B,GAA3C;IAEA,MAAM,OAAN,EAAe,IAAf,EAAqB,SAArB,EAAgC,OAAhC;IACA,KAAK,MAAL,GAAc,MAAd;EACH;;EAED,YAAY,GAAA;IACR,MAAM,MAAM,GAAQ,EAApB;IACA,KAAK,MAAL,CAAY,OAAZ,CAAqB,KAAD,IAAU;MAC1B,MAAM,CAAC,IAAP,CAAY,KAAK,CAAC,YAAN,EAAZ;IACH,CAFD,EAFQ,CAMR;;IACA,MAAM,WAAW,GAAG,KAAK,MAAL,CAAY,MAAZ,CAAmB,CAAC,KAAD,EAAQ,KAAR,KAAiB;MACpD,MAAM,IAAI,GAAG,KAAK,CAAC,SAAnB;;MACA,IAAI,IAAJ,EAAU;QACN,IAAI,CAAC,KAAK,CAAC,IAAD,CAAV,EAAkB;UAAE,KAAK,CAAC,IAAD,CAAL,GAAc,CAAd;QAAkB;;QACtC,KAAK,CAAC,IAAD,CAAL;MACH;;MACD,OAAO,KAAP;IACH,CAPmB,EAOa,EAPb,CAApB,CAPQ,CAgBR;;IACA,KAAK,MAAL,CAAY,OAAZ,CAAoB,CAAC,KAAD,EAAe,KAAf,KAAgC;MAChD,IAAI,IAAI,GAAG,KAAK,CAAC,SAAjB;;MACA,IAAI,CAAC,IAAD,IAAS,WAAW,CAAC,IAAD,CAAX,KAAsB,CAAnC,EAAsC;QAAE;MAAS;;MAEjD,IAAI,IAAI,KAAK,QAAb,EAAuB;QAAE,IAAI,GAAG,SAAP;MAAmB;;MAE5C,IAAI,MAAM,CAAC,IAAD,CAAN,IAAgB,IAApB,EAA0B;QAAE;MAAS;;MAErC,MAAM,CAAC,IAAD,CAAN,GAAe,MAAM,CAAC,KAAD,CAArB;IACH,CATD;IAWA,OAAO,MAAM,CAAC,MAAP,CAAc,MAAd,CAAP;EACH;;EAED,MAAM,CAAC,MAAD,EAAiB,KAAjB,EAA8D;IAChE,OAAO,IAAI,CAAC,MAAD,EAAS,KAAK,MAAd,EAAsB,KAAtB,CAAX;EACH;;EAED,MAAM,CAAC,MAAD,EAAe;IACjB,OAAO,MAAM,CAAC,MAAP,CAAc,KAAK,IAAnB,EAAyB,MAAM,CAAC,MAAD,EAAS,KAAK,MAAd,CAA/B,CAAP;EACH;;AArDgC","sourceRoot":"","sourcesContent":["\"use strict\";\r\nimport { Coder } from \"./abstract-coder\";\r\nimport { pack, unpack } from \"./array\";\r\nexport class TupleCoder extends Coder {\r\n    constructor(coders, localName) {\r\n        let dynamic = false;\r\n        const types = [];\r\n        coders.forEach((coder) => {\r\n            if (coder.dynamic) {\r\n                dynamic = true;\r\n            }\r\n            types.push(coder.type);\r\n        });\r\n        const type = (\"tuple(\" + types.join(\",\") + \")\");\r\n        super(\"tuple\", type, localName, dynamic);\r\n        this.coders = coders;\r\n    }\r\n    defaultValue() {\r\n        const values = [];\r\n        this.coders.forEach((coder) => {\r\n            values.push(coder.defaultValue());\r\n        });\r\n        // We only output named properties for uniquely named coders\r\n        const uniqueNames = this.coders.reduce((accum, coder) => {\r\n            const name = coder.localName;\r\n            if (name) {\r\n                if (!accum[name]) {\r\n                    accum[name] = 0;\r\n                }\r\n                accum[name]++;\r\n            }\r\n            return accum;\r\n        }, {});\r\n        // Add named values\r\n        this.coders.forEach((coder, index) => {\r\n            let name = coder.localName;\r\n            if (!name || uniqueNames[name] !== 1) {\r\n                return;\r\n            }\r\n            if (name === \"length\") {\r\n                name = \"_length\";\r\n            }\r\n            if (values[name] != null) {\r\n                return;\r\n            }\r\n            values[name] = values[index];\r\n        });\r\n        return Object.freeze(values);\r\n    }\r\n    encode(writer, value) {\r\n        return pack(writer, this.coders, value);\r\n    }\r\n    decode(reader) {\r\n        return reader.coerce(this.name, unpack(reader, this.coders));\r\n    }\r\n}\r\n//# sourceMappingURL=tuple.js.map"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"/**\r\n * Copyright (c) 2014-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @providesModule Dispatcher\r\n * \r\n * @preventMunge\r\n */\n'use strict';\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar _prefix = 'ID_';\n/**\r\n * Dispatcher is used to broadcast payloads to registered callbacks. This is\r\n * different from generic pub-sub systems in two ways:\r\n *\r\n *   1) Callbacks are not subscribed to particular events. Every payload is\r\n *      dispatched to every registered callback.\r\n *   2) Callbacks can be deferred in whole or part until other callbacks have\r\n *      been executed.\r\n *\r\n * For example, consider this hypothetical flight destination form, which\r\n * selects a default city when a country is selected:\r\n *\r\n *   var flightDispatcher = new Dispatcher();\r\n *\r\n *   // Keeps track of which country is selected\r\n *   var CountryStore = {country: null};\r\n *\r\n *   // Keeps track of which city is selected\r\n *   var CityStore = {city: null};\r\n *\r\n *   // Keeps track of the base flight price of the selected city\r\n *   var FlightPriceStore = {price: null}\r\n *\r\n * When a user changes the selected city, we dispatch the payload:\r\n *\r\n *   flightDispatcher.dispatch({\r\n *     actionType: 'city-update',\r\n *     selectedCity: 'paris'\r\n *   });\r\n *\r\n * This payload is digested by `CityStore`:\r\n *\r\n *   flightDispatcher.register(function(payload) {\r\n *     if (payload.actionType === 'city-update') {\r\n *       CityStore.city = payload.selectedCity;\r\n *     }\r\n *   });\r\n *\r\n * When the user selects a country, we dispatch the payload:\r\n *\r\n *   flightDispatcher.dispatch({\r\n *     actionType: 'country-update',\r\n *     selectedCountry: 'australia'\r\n *   });\r\n *\r\n * This payload is digested by both stores:\r\n *\r\n *   CountryStore.dispatchToken = flightDispatcher.register(function(payload) {\r\n *     if (payload.actionType === 'country-update') {\r\n *       CountryStore.country = payload.selectedCountry;\r\n *     }\r\n *   });\r\n *\r\n * When the callback to update `CountryStore` is registered, we save a reference\r\n * to the returned token. Using this token with `waitFor()`, we can guarantee\r\n * that `CountryStore` is updated before the callback that updates `CityStore`\r\n * needs to query its data.\r\n *\r\n *   CityStore.dispatchToken = flightDispatcher.register(function(payload) {\r\n *     if (payload.actionType === 'country-update') {\r\n *       // `CountryStore.country` may not be updated.\r\n *       flightDispatcher.waitFor([CountryStore.dispatchToken]);\r\n *       // `CountryStore.country` is now guaranteed to be updated.\r\n *\r\n *       // Select the default city for the new country\r\n *       CityStore.city = getDefaultCityForCountry(CountryStore.country);\r\n *     }\r\n *   });\r\n *\r\n * The usage of `waitFor()` can be chained, for example:\r\n *\r\n *   FlightPriceStore.dispatchToken =\r\n *     flightDispatcher.register(function(payload) {\r\n *       switch (payload.actionType) {\r\n *         case 'country-update':\r\n *         case 'city-update':\r\n *           flightDispatcher.waitFor([CityStore.dispatchToken]);\r\n *           FlightPriceStore.price =\r\n *             getFlightPriceStore(CountryStore.country, CityStore.city);\r\n *           break;\r\n *     }\r\n *   });\r\n *\r\n * The `country-update` payload will be guaranteed to invoke the stores'\r\n * registered callbacks in order: `CountryStore`, `CityStore`, then\r\n * `FlightPriceStore`.\r\n */\n\nvar Dispatcher = /*#__PURE__*/function () {\n  function Dispatcher() {\n    _defineProperty(this, \"_callbacks\", void 0);\n\n    _defineProperty(this, \"_isDispatching\", void 0);\n\n    _defineProperty(this, \"_isHandled\", void 0);\n\n    _defineProperty(this, \"_isPending\", void 0);\n\n    _defineProperty(this, \"_lastID\", void 0);\n\n    _defineProperty(this, \"_pendingPayload\", void 0);\n\n    this._callbacks = {};\n    this._isDispatching = false;\n    this._isHandled = {};\n    this._isPending = {};\n    this._lastID = 1;\n  }\n  /**\r\n   * Registers a callback to be invoked with every dispatched payload. Returns\r\n   * a token that can be used with `waitFor()`.\r\n   */\n\n\n  var _proto = Dispatcher.prototype;\n\n  _proto.register = function register(callback) {\n    var id = _prefix + this._lastID++;\n    this._callbacks[id] = callback;\n    return id;\n  }\n  /**\r\n   * Removes a callback based on its token.\r\n   */\n  ;\n\n  _proto.unregister = function unregister(id) {\n    !this._callbacks[id] ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Dispatcher.unregister(...): `%s` does not map to a registered callback.', id) : invariant(false) : void 0;\n    delete this._callbacks[id];\n  }\n  /**\r\n   * Waits for the callbacks specified to be invoked before continuing execution\r\n   * of the current callback. This method should only be used by a callback in\r\n   * response to a dispatched payload.\r\n   */\n  ;\n\n  _proto.waitFor = function waitFor(ids) {\n    !this._isDispatching ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Dispatcher.waitFor(...): Must be invoked while dispatching.') : invariant(false) : void 0;\n\n    for (var ii = 0; ii < ids.length; ii++) {\n      var id = ids[ii];\n\n      if (this._isPending[id]) {\n        !this._isHandled[id] ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Dispatcher.waitFor(...): Circular dependency detected while ' + 'waiting for `%s`.', id) : invariant(false) : void 0;\n        continue;\n      }\n\n      !this._callbacks[id] ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Dispatcher.waitFor(...): `%s` does not map to a registered callback.', id) : invariant(false) : void 0;\n\n      this._invokeCallback(id);\n    }\n  }\n  /**\r\n   * Dispatches a payload to all registered callbacks.\r\n   */\n  ;\n\n  _proto.dispatch = function dispatch(payload) {\n    !!this._isDispatching ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch.') : invariant(false) : void 0;\n\n    this._startDispatching(payload);\n\n    try {\n      for (var id in this._callbacks) {\n        if (this._isPending[id]) {\n          continue;\n        }\n\n        this._invokeCallback(id);\n      }\n    } finally {\n      this._stopDispatching();\n    }\n  }\n  /**\r\n   * Is this Dispatcher currently dispatching.\r\n   */\n  ;\n\n  _proto.isDispatching = function isDispatching() {\n    return this._isDispatching;\n  }\n  /**\r\n   * Call the callback stored with the given id. Also do some internal\r\n   * bookkeeping.\r\n   *\r\n   * @internal\r\n   */\n  ;\n\n  _proto._invokeCallback = function _invokeCallback(id) {\n    this._isPending[id] = true;\n\n    this._callbacks[id](this._pendingPayload);\n\n    this._isHandled[id] = true;\n  }\n  /**\r\n   * Set up bookkeeping needed when dispatching.\r\n   *\r\n   * @internal\r\n   */\n  ;\n\n  _proto._startDispatching = function _startDispatching(payload) {\n    for (var id in this._callbacks) {\n      this._isPending[id] = false;\n      this._isHandled[id] = false;\n    }\n\n    this._pendingPayload = payload;\n    this._isDispatching = true;\n  }\n  /**\r\n   * Clear bookkeeping used for dispatching.\r\n   *\r\n   * @internal\r\n   */\n  ;\n\n  _proto._stopDispatching = function _stopDispatching() {\n    delete this._pendingPayload;\n    this._isDispatching = false;\n  };\n\n  return Dispatcher;\n}();\n\nmodule.exports = Dispatcher;","map":{"version":3,"names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","invariant","require","_prefix","Dispatcher","_callbacks","_isDispatching","_isHandled","_isPending","_lastID","_proto","prototype","register","callback","id","unregister","process","env","NODE_ENV","waitFor","ids","ii","length","_invokeCallback","dispatch","payload","_startDispatching","_stopDispatching","isDispatching","_pendingPayload","module","exports"],"sources":["C:/Users/Runner/Desktop/test1/SafetyManagement_UI/client/node_modules/flux/lib/Dispatcher.js"],"sourcesContent":["/**\r\n * Copyright (c) 2014-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @providesModule Dispatcher\r\n * \r\n * @preventMunge\r\n */\r\n'use strict';\r\n\r\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\r\n\r\nvar invariant = require(\"fbjs/lib/invariant\");\r\n\r\nvar _prefix = 'ID_';\r\n/**\r\n * Dispatcher is used to broadcast payloads to registered callbacks. This is\r\n * different from generic pub-sub systems in two ways:\r\n *\r\n *   1) Callbacks are not subscribed to particular events. Every payload is\r\n *      dispatched to every registered callback.\r\n *   2) Callbacks can be deferred in whole or part until other callbacks have\r\n *      been executed.\r\n *\r\n * For example, consider this hypothetical flight destination form, which\r\n * selects a default city when a country is selected:\r\n *\r\n *   var flightDispatcher = new Dispatcher();\r\n *\r\n *   // Keeps track of which country is selected\r\n *   var CountryStore = {country: null};\r\n *\r\n *   // Keeps track of which city is selected\r\n *   var CityStore = {city: null};\r\n *\r\n *   // Keeps track of the base flight price of the selected city\r\n *   var FlightPriceStore = {price: null}\r\n *\r\n * When a user changes the selected city, we dispatch the payload:\r\n *\r\n *   flightDispatcher.dispatch({\r\n *     actionType: 'city-update',\r\n *     selectedCity: 'paris'\r\n *   });\r\n *\r\n * This payload is digested by `CityStore`:\r\n *\r\n *   flightDispatcher.register(function(payload) {\r\n *     if (payload.actionType === 'city-update') {\r\n *       CityStore.city = payload.selectedCity;\r\n *     }\r\n *   });\r\n *\r\n * When the user selects a country, we dispatch the payload:\r\n *\r\n *   flightDispatcher.dispatch({\r\n *     actionType: 'country-update',\r\n *     selectedCountry: 'australia'\r\n *   });\r\n *\r\n * This payload is digested by both stores:\r\n *\r\n *   CountryStore.dispatchToken = flightDispatcher.register(function(payload) {\r\n *     if (payload.actionType === 'country-update') {\r\n *       CountryStore.country = payload.selectedCountry;\r\n *     }\r\n *   });\r\n *\r\n * When the callback to update `CountryStore` is registered, we save a reference\r\n * to the returned token. Using this token with `waitFor()`, we can guarantee\r\n * that `CountryStore` is updated before the callback that updates `CityStore`\r\n * needs to query its data.\r\n *\r\n *   CityStore.dispatchToken = flightDispatcher.register(function(payload) {\r\n *     if (payload.actionType === 'country-update') {\r\n *       // `CountryStore.country` may not be updated.\r\n *       flightDispatcher.waitFor([CountryStore.dispatchToken]);\r\n *       // `CountryStore.country` is now guaranteed to be updated.\r\n *\r\n *       // Select the default city for the new country\r\n *       CityStore.city = getDefaultCityForCountry(CountryStore.country);\r\n *     }\r\n *   });\r\n *\r\n * The usage of `waitFor()` can be chained, for example:\r\n *\r\n *   FlightPriceStore.dispatchToken =\r\n *     flightDispatcher.register(function(payload) {\r\n *       switch (payload.actionType) {\r\n *         case 'country-update':\r\n *         case 'city-update':\r\n *           flightDispatcher.waitFor([CityStore.dispatchToken]);\r\n *           FlightPriceStore.price =\r\n *             getFlightPriceStore(CountryStore.country, CityStore.city);\r\n *           break;\r\n *     }\r\n *   });\r\n *\r\n * The `country-update` payload will be guaranteed to invoke the stores'\r\n * registered callbacks in order: `CountryStore`, `CityStore`, then\r\n * `FlightPriceStore`.\r\n */\r\n\r\nvar Dispatcher = /*#__PURE__*/function () {\r\n  function Dispatcher() {\r\n    _defineProperty(this, \"_callbacks\", void 0);\r\n\r\n    _defineProperty(this, \"_isDispatching\", void 0);\r\n\r\n    _defineProperty(this, \"_isHandled\", void 0);\r\n\r\n    _defineProperty(this, \"_isPending\", void 0);\r\n\r\n    _defineProperty(this, \"_lastID\", void 0);\r\n\r\n    _defineProperty(this, \"_pendingPayload\", void 0);\r\n\r\n    this._callbacks = {};\r\n    this._isDispatching = false;\r\n    this._isHandled = {};\r\n    this._isPending = {};\r\n    this._lastID = 1;\r\n  }\r\n  /**\r\n   * Registers a callback to be invoked with every dispatched payload. Returns\r\n   * a token that can be used with `waitFor()`.\r\n   */\r\n\r\n\r\n  var _proto = Dispatcher.prototype;\r\n\r\n  _proto.register = function register(callback) {\r\n    var id = _prefix + this._lastID++;\r\n    this._callbacks[id] = callback;\r\n    return id;\r\n  }\r\n  /**\r\n   * Removes a callback based on its token.\r\n   */\r\n  ;\r\n\r\n  _proto.unregister = function unregister(id) {\r\n    !this._callbacks[id] ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Dispatcher.unregister(...): `%s` does not map to a registered callback.', id) : invariant(false) : void 0;\r\n    delete this._callbacks[id];\r\n  }\r\n  /**\r\n   * Waits for the callbacks specified to be invoked before continuing execution\r\n   * of the current callback. This method should only be used by a callback in\r\n   * response to a dispatched payload.\r\n   */\r\n  ;\r\n\r\n  _proto.waitFor = function waitFor(ids) {\r\n    !this._isDispatching ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Dispatcher.waitFor(...): Must be invoked while dispatching.') : invariant(false) : void 0;\r\n\r\n    for (var ii = 0; ii < ids.length; ii++) {\r\n      var id = ids[ii];\r\n\r\n      if (this._isPending[id]) {\r\n        !this._isHandled[id] ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Dispatcher.waitFor(...): Circular dependency detected while ' + 'waiting for `%s`.', id) : invariant(false) : void 0;\r\n        continue;\r\n      }\r\n\r\n      !this._callbacks[id] ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Dispatcher.waitFor(...): `%s` does not map to a registered callback.', id) : invariant(false) : void 0;\r\n\r\n      this._invokeCallback(id);\r\n    }\r\n  }\r\n  /**\r\n   * Dispatches a payload to all registered callbacks.\r\n   */\r\n  ;\r\n\r\n  _proto.dispatch = function dispatch(payload) {\r\n    !!this._isDispatching ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch.') : invariant(false) : void 0;\r\n\r\n    this._startDispatching(payload);\r\n\r\n    try {\r\n      for (var id in this._callbacks) {\r\n        if (this._isPending[id]) {\r\n          continue;\r\n        }\r\n\r\n        this._invokeCallback(id);\r\n      }\r\n    } finally {\r\n      this._stopDispatching();\r\n    }\r\n  }\r\n  /**\r\n   * Is this Dispatcher currently dispatching.\r\n   */\r\n  ;\r\n\r\n  _proto.isDispatching = function isDispatching() {\r\n    return this._isDispatching;\r\n  }\r\n  /**\r\n   * Call the callback stored with the given id. Also do some internal\r\n   * bookkeeping.\r\n   *\r\n   * @internal\r\n   */\r\n  ;\r\n\r\n  _proto._invokeCallback = function _invokeCallback(id) {\r\n    this._isPending[id] = true;\r\n\r\n    this._callbacks[id](this._pendingPayload);\r\n\r\n    this._isHandled[id] = true;\r\n  }\r\n  /**\r\n   * Set up bookkeeping needed when dispatching.\r\n   *\r\n   * @internal\r\n   */\r\n  ;\r\n\r\n  _proto._startDispatching = function _startDispatching(payload) {\r\n    for (var id in this._callbacks) {\r\n      this._isPending[id] = false;\r\n      this._isHandled[id] = false;\r\n    }\r\n\r\n    this._pendingPayload = payload;\r\n    this._isDispatching = true;\r\n  }\r\n  /**\r\n   * Clear bookkeeping used for dispatching.\r\n   *\r\n   * @internal\r\n   */\r\n  ;\r\n\r\n  _proto._stopDispatching = function _stopDispatching() {\r\n    delete this._pendingPayload;\r\n    this._isDispatching = false;\r\n  };\r\n\r\n  return Dispatcher;\r\n}();\r\n\r\nmodule.exports = Dispatcher;"],"mappings":"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"},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"/*\r\n This file is part of web3.js.\r\n\r\n web3.js is free software: you can redistribute it and/or modify\r\n it under the terms of the GNU Lesser General Public License as published by\r\n the Free Software Foundation, either version 3 of the License, or\r\n (at your option) any later version.\r\n\r\n web3.js is distributed in the hope that it will be useful,\r\n but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n GNU Lesser General Public License for more details.\r\n\r\n You should have received a copy of the GNU Lesser General Public License\r\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n */\n\n/**\r\n * @file index.js\r\n * @author Marek Kotewicz <marek@parity.io>\r\n * @author Fabian Vogelsteller <fabian@frozeman.de>\r\n * @date 2018\r\n */\nvar Buffer = require('buffer').Buffer;\n\nvar utils = require('web3-utils');\n\nvar EthersAbiCoder = require('@ethersproject/abi').AbiCoder;\n\nvar ParamType = require('@ethersproject/abi').ParamType;\n\nvar ethersAbiCoder = new EthersAbiCoder(function (type, value) {\n  if (type.match(/^u?int/) && !Array.isArray(value) && (!(!!value && typeof value === 'object') || value.constructor.name !== 'BN')) {\n    return value.toString();\n  }\n\n  return value;\n}); // result method\n\nfunction Result() {}\n/**\r\n * ABICoder prototype should be used to encode/decode solidity params of any type\r\n */\n\n\nvar ABICoder = function () {};\n/**\r\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\r\n *\r\n * @method encodeFunctionSignature\r\n * @param {String|Object} functionName\r\n * @return {String} encoded function name\r\n */\n\n\nABICoder.prototype.encodeFunctionSignature = function (functionName) {\n  if (typeof functionName === 'function' || typeof functionName === 'object' && functionName) {\n    functionName = utils._jsonInterfaceMethodToString(functionName);\n  }\n\n  return utils.sha3(functionName).slice(0, 10);\n};\n/**\r\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\r\n *\r\n * @method encodeEventSignature\r\n * @param {String|Object} functionName\r\n * @return {String} encoded function name\r\n */\n\n\nABICoder.prototype.encodeEventSignature = function (functionName) {\n  if (typeof functionName === 'function' || typeof functionName === 'object' && functionName) {\n    functionName = utils._jsonInterfaceMethodToString(functionName);\n  }\n\n  return utils.sha3(functionName);\n};\n/**\r\n * Should be used to encode plain param\r\n *\r\n * @method encodeParameter\r\n *\r\n * @param {String|Object} type\r\n * @param {any} param\r\n *\r\n * @return {String} encoded plain param\r\n */\n\n\nABICoder.prototype.encodeParameter = function (type, param) {\n  return this.encodeParameters([type], [param]);\n};\n/**\r\n * Should be used to encode list of params\r\n *\r\n * @method encodeParameters\r\n *\r\n * @param {Array<String|Object>} types\r\n * @param {Array<any>} params\r\n *\r\n * @return {String} encoded list of params\r\n */\n\n\nABICoder.prototype.encodeParameters = function (types, params) {\n  var self = this;\n  types = self.mapTypes(types);\n  params = params.map(function (param, index) {\n    let type = types[index];\n\n    if (typeof type === 'object' && type.type) {\n      // We may get a named type of shape {name, type}\n      type = type.type;\n    }\n\n    param = self.formatParam(type, param); // Format params for tuples\n\n    if (typeof type === 'string' && type.includes('tuple')) {\n      const coder = ethersAbiCoder._getCoder(ParamType.from(type));\n\n      const modifyParams = (coder, param) => {\n        if (coder.name === 'array') {\n          if (!coder.type.match(/\\[(\\d+)\\]/)) {\n            return param.map(p => modifyParams(ethersAbiCoder._getCoder(ParamType.from(coder.type.replace('[]', ''))), p));\n          }\n\n          const arrayLength = parseInt(coder.type.match(/\\[(\\d+)\\]/)[1]);\n\n          if (param.length !== arrayLength) {\n            throw new Error('Array length does not matches with the given input');\n          }\n\n          return param.map(p => modifyParams(ethersAbiCoder._getCoder(ParamType.from(coder.type.replace(/\\[\\d+\\]/, ''))), p));\n        }\n\n        coder.coders.forEach((c, i) => {\n          if (c.name === 'tuple') {\n            modifyParams(c, param[i]);\n          } else {\n            param[i] = self.formatParam(c.name, param[i]);\n          }\n        });\n      };\n\n      modifyParams(coder, param);\n    }\n\n    return param;\n  });\n  return ethersAbiCoder.encode(types, params);\n};\n/**\r\n * Map types if simplified format is used\r\n *\r\n * @method mapTypes\r\n * @param {Array} types\r\n * @return {Array}\r\n */\n\n\nABICoder.prototype.mapTypes = function (types) {\n  var self = this;\n  var mappedTypes = [];\n  types.forEach(function (type) {\n    // Remap `function` type params to bytes24 since Ethers does not\n    // recognize former type. Solidity docs say `Function` is a bytes24\n    // encoding the contract address followed by the function selector hash.\n    if (typeof type === 'object' && type.type === 'function') {\n      type = Object.assign({}, type, {\n        type: \"bytes24\"\n      });\n    }\n\n    if (self.isSimplifiedStructFormat(type)) {\n      var structName = Object.keys(type)[0];\n      mappedTypes.push(Object.assign(self.mapStructNameAndType(structName), {\n        components: self.mapStructToCoderFormat(type[structName])\n      }));\n      return;\n    }\n\n    mappedTypes.push(type);\n  });\n  return mappedTypes;\n};\n/**\r\n * Check if type is simplified struct format\r\n *\r\n * @method isSimplifiedStructFormat\r\n * @param {string | Object} type\r\n * @returns {boolean}\r\n */\n\n\nABICoder.prototype.isSimplifiedStructFormat = function (type) {\n  return typeof type === 'object' && typeof type.components === 'undefined' && typeof type.name === 'undefined';\n};\n/**\r\n * Maps the correct tuple type and name when the simplified format in encode/decodeParameter is used\r\n *\r\n * @method mapStructNameAndType\r\n * @param {string} structName\r\n * @return {{type: string, name: *}}\r\n */\n\n\nABICoder.prototype.mapStructNameAndType = function (structName) {\n  var type = 'tuple';\n\n  if (structName.indexOf('[]') > -1) {\n    type = 'tuple[]';\n    structName = structName.slice(0, -2);\n  }\n\n  return {\n    type: type,\n    name: structName\n  };\n};\n/**\r\n * Maps the simplified format in to the expected format of the ABICoder\r\n *\r\n * @method mapStructToCoderFormat\r\n * @param {Object} struct\r\n * @return {Array}\r\n */\n\n\nABICoder.prototype.mapStructToCoderFormat = function (struct) {\n  var self = this;\n  var components = [];\n  Object.keys(struct).forEach(function (key) {\n    if (typeof struct[key] === 'object') {\n      components.push(Object.assign(self.mapStructNameAndType(key), {\n        components: self.mapStructToCoderFormat(struct[key])\n      }));\n      return;\n    }\n\n    components.push({\n      name: key,\n      type: struct[key]\n    });\n  });\n  return components;\n};\n/**\r\n * Handle some formatting of params for backwards compatability with Ethers V4\r\n *\r\n * @method formatParam\r\n * @param {String} - type\r\n * @param {any} - param\r\n * @return {any} - The formatted param\r\n */\n\n\nABICoder.prototype.formatParam = function (type, param) {\n  const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\n  const paramTypeBytesArray = new RegExp(/^bytes([0-9]*)\\[\\]$/);\n  const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\n  const paramTypeNumberArray = new RegExp(/^(u?int)([0-9]*)\\[\\]$/); // Format BN to string\n\n  if (utils.isBN(param) || utils.isBigNumber(param)) {\n    return param.toString(10);\n  }\n\n  if (type.match(paramTypeBytesArray) || type.match(paramTypeNumberArray)) {\n    return param.map(p => this.formatParam(type.replace('[]', ''), p));\n  } // Format correct width for u?int[0-9]*\n\n\n  let match = type.match(paramTypeNumber);\n\n  if (match) {\n    let size = parseInt(match[2] || \"256\");\n\n    if (size / 8 < param.length) {\n      // pad to correct bit width\n      param = utils.leftPad(param, size);\n    }\n  } // Format correct length for bytes[0-9]+\n\n\n  match = type.match(paramTypeBytes);\n\n  if (match) {\n    if (Buffer.isBuffer(param)) {\n      param = utils.toHex(param);\n    } // format to correct length\n\n\n    let size = parseInt(match[1]);\n\n    if (size) {\n      let maxSize = size * 2;\n\n      if (param.substring(0, 2) === '0x') {\n        maxSize += 2;\n      }\n\n      if (param.length < maxSize) {\n        // pad to correct length\n        param = utils.rightPad(param, size * 2);\n      }\n    } // format odd-length bytes to even-length\n\n\n    if (param.length % 2 === 1) {\n      param = '0x0' + param.substring(2);\n    }\n  }\n\n  return param;\n};\n/**\r\n * Encodes a function call from its json interface and parameters.\r\n *\r\n * @method encodeFunctionCall\r\n * @param {Array} jsonInterface\r\n * @param {Array} params\r\n * @return {String} The encoded ABI for this function call\r\n */\n\n\nABICoder.prototype.encodeFunctionCall = function (jsonInterface, params) {\n  return this.encodeFunctionSignature(jsonInterface) + this.encodeParameters(jsonInterface.inputs, params).replace('0x', '');\n};\n/**\r\n * Should be used to decode bytes to plain param\r\n *\r\n * @method decodeParameter\r\n * @param {String} type\r\n * @param {String} bytes\r\n * @return {Object} plain param\r\n */\n\n\nABICoder.prototype.decodeParameter = function (type, bytes) {\n  return this.decodeParameters([type], bytes)[0];\n};\n/**\r\n * Should be used to decode list of params\r\n *\r\n * @method decodeParameter\r\n * @param {Array} outputs\r\n * @param {String} bytes\r\n * @return {Array} array of plain params\r\n */\n\n\nABICoder.prototype.decodeParameters = function (outputs, bytes) {\n  return this.decodeParametersWith(outputs, bytes, false);\n};\n/**\r\n * Should be used to decode list of params\r\n *\r\n * @method decodeParameter\r\n * @param {Array} outputs\r\n * @param {String} bytes\r\n * @param {Boolean} loose\r\n * @return {Array} array of plain params\r\n */\n\n\nABICoder.prototype.decodeParametersWith = function (outputs, bytes, loose) {\n  if (outputs.length > 0 && (!bytes || bytes === '0x' || bytes === '0X')) {\n    throw new Error('Returned values aren\\'t valid, did it run Out of Gas? ' + 'You might also see this error if you are not using the ' + 'correct ABI for the contract you are retrieving data from, ' + 'requesting data from a block number that does not exist, ' + 'or querying a node which is not fully synced.');\n  }\n\n  var res = ethersAbiCoder.decode(this.mapTypes(outputs), '0x' + bytes.replace(/0x/i, ''), loose);\n  var returnValue = new Result();\n  returnValue.__length__ = 0;\n  outputs.forEach(function (output, i) {\n    var decodedValue = res[returnValue.__length__];\n    const isStringObject = typeof output === 'object' && output.type && output.type === 'string';\n    const isStringType = typeof output === 'string' && output === 'string'; // only convert `0x` to null if it's not string value\n\n    decodedValue = decodedValue === '0x' && !isStringObject && !isStringType ? null : decodedValue;\n    returnValue[i] = decodedValue;\n\n    if ((typeof output === 'function' || !!output && typeof output === 'object') && output.name) {\n      returnValue[output.name] = decodedValue;\n    }\n\n    returnValue.__length__++;\n  });\n  return returnValue;\n};\n/**\r\n * Decodes events non- and indexed parameters.\r\n *\r\n * @method decodeLog\r\n * @param {Object} inputs\r\n * @param {String} data\r\n * @param {Array} topics\r\n * @return {Array} array of plain params\r\n */\n\n\nABICoder.prototype.decodeLog = function (inputs, data, topics) {\n  var _this = this;\n\n  topics = Array.isArray(topics) ? topics : [topics];\n  data = data || '';\n  var notIndexedInputs = [];\n  var indexedParams = [];\n  var topicCount = 0; // TODO check for anonymous logs?\n\n  inputs.forEach(function (input, i) {\n    if (input.indexed) {\n      indexedParams[i] = ['bool', 'int', 'uint', 'address', 'fixed', 'ufixed'].find(function (staticType) {\n        return input.type.indexOf(staticType) !== -1;\n      }) ? _this.decodeParameter(input.type, topics[topicCount]) : topics[topicCount];\n      topicCount++;\n    } else {\n      notIndexedInputs[i] = input;\n    }\n  });\n  var nonIndexedData = data;\n  var notIndexedParams = nonIndexedData ? this.decodeParametersWith(notIndexedInputs, nonIndexedData, true) : [];\n  var returnValue = new Result();\n  returnValue.__length__ = 0;\n  inputs.forEach(function (res, i) {\n    returnValue[i] = res.type === 'string' ? '' : null;\n\n    if (typeof notIndexedParams[i] !== 'undefined') {\n      returnValue[i] = notIndexedParams[i];\n    }\n\n    if (typeof indexedParams[i] !== 'undefined') {\n      returnValue[i] = indexedParams[i];\n    }\n\n    if (res.name) {\n      returnValue[res.name] = returnValue[i];\n    }\n\n    returnValue.__length__++;\n  });\n  return returnValue;\n};\n\nvar coder = new ABICoder();\nmodule.exports = coder;","map":{"version":3,"names":["Buffer","require","utils","EthersAbiCoder","AbiCoder","ParamType","ethersAbiCoder","type","value","match","Array","isArray","constructor","name","toString","Result","ABICoder","prototype","encodeFunctionSignature","functionName","_jsonInterfaceMethodToString","sha3","slice","encodeEventSignature","encodeParameter","param","encodeParameters","types","params","self","mapTypes","map","index","formatParam","includes","coder","_getCoder","from","modifyParams","p","replace","arrayLength","parseInt","length","Error","coders","forEach","c","i","encode","mappedTypes","Object","assign","isSimplifiedStructFormat","structName","keys","push","mapStructNameAndType","components","mapStructToCoderFormat","indexOf","struct","key","paramTypeBytes","RegExp","paramTypeBytesArray","paramTypeNumber","paramTypeNumberArray","isBN","isBigNumber","size","leftPad","isBuffer","toHex","maxSize","substring","rightPad","encodeFunctionCall","jsonInterface","inputs","decodeParameter","bytes","decodeParameters","outputs","decodeParametersWith","loose","res","decode","returnValue","__length__","output","decodedValue","isStringObject","isStringType","decodeLog","data","topics","_this","notIndexedInputs","indexedParams","topicCount","input","indexed","find","staticType","nonIndexedData","notIndexedParams","module","exports"],"sources":["C:/Users/Runner/Desktop/test1/SafetyManagement_UI/client/node_modules/web3-eth/node_modules/web3-eth-abi/lib/index.js"],"sourcesContent":["/*\r\n This file is part of web3.js.\r\n\r\n web3.js is free software: you can redistribute it and/or modify\r\n it under the terms of the GNU Lesser General Public License as published by\r\n the Free Software Foundation, either version 3 of the License, or\r\n (at your option) any later version.\r\n\r\n web3.js is distributed in the hope that it will be useful,\r\n but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n GNU Lesser General Public License for more details.\r\n\r\n You should have received a copy of the GNU Lesser General Public License\r\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\n/**\r\n * @file index.js\r\n * @author Marek Kotewicz <marek@parity.io>\r\n * @author Fabian Vogelsteller <fabian@frozeman.de>\r\n * @date 2018\r\n */\r\nvar Buffer = require('buffer').Buffer;\r\nvar utils = require('web3-utils');\r\nvar EthersAbiCoder = require('@ethersproject/abi').AbiCoder;\r\nvar ParamType = require('@ethersproject/abi').ParamType;\r\nvar ethersAbiCoder = new EthersAbiCoder(function (type, value) {\r\n    if (type.match(/^u?int/) && !Array.isArray(value) && (!(!!value && typeof value === 'object') || value.constructor.name !== 'BN')) {\r\n        return value.toString();\r\n    }\r\n    return value;\r\n});\r\n// result method\r\nfunction Result() {\r\n}\r\n/**\r\n * ABICoder prototype should be used to encode/decode solidity params of any type\r\n */\r\nvar ABICoder = function () {\r\n};\r\n/**\r\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\r\n *\r\n * @method encodeFunctionSignature\r\n * @param {String|Object} functionName\r\n * @return {String} encoded function name\r\n */\r\nABICoder.prototype.encodeFunctionSignature = function (functionName) {\r\n    if (typeof functionName === 'function' || typeof functionName === 'object' && functionName) {\r\n        functionName = utils._jsonInterfaceMethodToString(functionName);\r\n    }\r\n    return utils.sha3(functionName).slice(0, 10);\r\n};\r\n/**\r\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\r\n *\r\n * @method encodeEventSignature\r\n * @param {String|Object} functionName\r\n * @return {String} encoded function name\r\n */\r\nABICoder.prototype.encodeEventSignature = function (functionName) {\r\n    if (typeof functionName === 'function' || typeof functionName === 'object' && functionName) {\r\n        functionName = utils._jsonInterfaceMethodToString(functionName);\r\n    }\r\n    return utils.sha3(functionName);\r\n};\r\n/**\r\n * Should be used to encode plain param\r\n *\r\n * @method encodeParameter\r\n *\r\n * @param {String|Object} type\r\n * @param {any} param\r\n *\r\n * @return {String} encoded plain param\r\n */\r\nABICoder.prototype.encodeParameter = function (type, param) {\r\n    return this.encodeParameters([type], [param]);\r\n};\r\n/**\r\n * Should be used to encode list of params\r\n *\r\n * @method encodeParameters\r\n *\r\n * @param {Array<String|Object>} types\r\n * @param {Array<any>} params\r\n *\r\n * @return {String} encoded list of params\r\n */\r\nABICoder.prototype.encodeParameters = function (types, params) {\r\n    var self = this;\r\n    types = self.mapTypes(types);\r\n    params = params.map(function (param, index) {\r\n        let type = types[index];\r\n        if (typeof type === 'object' && type.type) {\r\n            // We may get a named type of shape {name, type}\r\n            type = type.type;\r\n        }\r\n        param = self.formatParam(type, param);\r\n        // Format params for tuples\r\n        if (typeof type === 'string' && type.includes('tuple')) {\r\n            const coder = ethersAbiCoder._getCoder(ParamType.from(type));\r\n            const modifyParams = (coder, param) => {\r\n                if (coder.name === 'array') {\r\n                    if (!coder.type.match(/\\[(\\d+)\\]/)) {\r\n                        return param.map(p => modifyParams(ethersAbiCoder._getCoder(ParamType.from(coder.type.replace('[]', ''))), p));\r\n                    }\r\n                    const arrayLength = parseInt(coder.type.match(/\\[(\\d+)\\]/)[1]);\r\n                    if (param.length !== arrayLength) {\r\n                        throw new Error('Array length does not matches with the given input');\r\n                    }\r\n                    return param.map(p => modifyParams(ethersAbiCoder._getCoder(ParamType.from(coder.type.replace(/\\[\\d+\\]/, ''))), p));\r\n                }\r\n                coder.coders.forEach((c, i) => {\r\n                    if (c.name === 'tuple') {\r\n                        modifyParams(c, param[i]);\r\n                    }\r\n                    else {\r\n                        param[i] = self.formatParam(c.name, param[i]);\r\n                    }\r\n                });\r\n            };\r\n            modifyParams(coder, param);\r\n        }\r\n        return param;\r\n    });\r\n    return ethersAbiCoder.encode(types, params);\r\n};\r\n/**\r\n * Map types if simplified format is used\r\n *\r\n * @method mapTypes\r\n * @param {Array} types\r\n * @return {Array}\r\n */\r\nABICoder.prototype.mapTypes = function (types) {\r\n    var self = this;\r\n    var mappedTypes = [];\r\n    types.forEach(function (type) {\r\n        // Remap `function` type params to bytes24 since Ethers does not\r\n        // recognize former type. Solidity docs say `Function` is a bytes24\r\n        // encoding the contract address followed by the function selector hash.\r\n        if (typeof type === 'object' && type.type === 'function') {\r\n            type = Object.assign({}, type, { type: \"bytes24\" });\r\n        }\r\n        if (self.isSimplifiedStructFormat(type)) {\r\n            var structName = Object.keys(type)[0];\r\n            mappedTypes.push(Object.assign(self.mapStructNameAndType(structName), {\r\n                components: self.mapStructToCoderFormat(type[structName])\r\n            }));\r\n            return;\r\n        }\r\n        mappedTypes.push(type);\r\n    });\r\n    return mappedTypes;\r\n};\r\n/**\r\n * Check if type is simplified struct format\r\n *\r\n * @method isSimplifiedStructFormat\r\n * @param {string | Object} type\r\n * @returns {boolean}\r\n */\r\nABICoder.prototype.isSimplifiedStructFormat = function (type) {\r\n    return typeof type === 'object' && typeof type.components === 'undefined' && typeof type.name === 'undefined';\r\n};\r\n/**\r\n * Maps the correct tuple type and name when the simplified format in encode/decodeParameter is used\r\n *\r\n * @method mapStructNameAndType\r\n * @param {string} structName\r\n * @return {{type: string, name: *}}\r\n */\r\nABICoder.prototype.mapStructNameAndType = function (structName) {\r\n    var type = 'tuple';\r\n    if (structName.indexOf('[]') > -1) {\r\n        type = 'tuple[]';\r\n        structName = structName.slice(0, -2);\r\n    }\r\n    return { type: type, name: structName };\r\n};\r\n/**\r\n * Maps the simplified format in to the expected format of the ABICoder\r\n *\r\n * @method mapStructToCoderFormat\r\n * @param {Object} struct\r\n * @return {Array}\r\n */\r\nABICoder.prototype.mapStructToCoderFormat = function (struct) {\r\n    var self = this;\r\n    var components = [];\r\n    Object.keys(struct).forEach(function (key) {\r\n        if (typeof struct[key] === 'object') {\r\n            components.push(Object.assign(self.mapStructNameAndType(key), {\r\n                components: self.mapStructToCoderFormat(struct[key])\r\n            }));\r\n            return;\r\n        }\r\n        components.push({\r\n            name: key,\r\n            type: struct[key]\r\n        });\r\n    });\r\n    return components;\r\n};\r\n/**\r\n * Handle some formatting of params for backwards compatability with Ethers V4\r\n *\r\n * @method formatParam\r\n * @param {String} - type\r\n * @param {any} - param\r\n * @return {any} - The formatted param\r\n */\r\nABICoder.prototype.formatParam = function (type, param) {\r\n    const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\r\n    const paramTypeBytesArray = new RegExp(/^bytes([0-9]*)\\[\\]$/);\r\n    const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\r\n    const paramTypeNumberArray = new RegExp(/^(u?int)([0-9]*)\\[\\]$/);\r\n    // Format BN to string\r\n    if (utils.isBN(param) || utils.isBigNumber(param)) {\r\n        return param.toString(10);\r\n    }\r\n    if (type.match(paramTypeBytesArray) || type.match(paramTypeNumberArray)) {\r\n        return param.map(p => this.formatParam(type.replace('[]', ''), p));\r\n    }\r\n    // Format correct width for u?int[0-9]*\r\n    let match = type.match(paramTypeNumber);\r\n    if (match) {\r\n        let size = parseInt(match[2] || \"256\");\r\n        if (size / 8 < param.length) {\r\n            // pad to correct bit width\r\n            param = utils.leftPad(param, size);\r\n        }\r\n    }\r\n    // Format correct length for bytes[0-9]+\r\n    match = type.match(paramTypeBytes);\r\n    if (match) {\r\n        if (Buffer.isBuffer(param)) {\r\n            param = utils.toHex(param);\r\n        }\r\n        // format to correct length\r\n        let size = parseInt(match[1]);\r\n        if (size) {\r\n            let maxSize = size * 2;\r\n            if (param.substring(0, 2) === '0x') {\r\n                maxSize += 2;\r\n            }\r\n            if (param.length < maxSize) {\r\n                // pad to correct length\r\n                param = utils.rightPad(param, size * 2);\r\n            }\r\n        }\r\n        // format odd-length bytes to even-length\r\n        if (param.length % 2 === 1) {\r\n            param = '0x0' + param.substring(2);\r\n        }\r\n    }\r\n    return param;\r\n};\r\n/**\r\n * Encodes a function call from its json interface and parameters.\r\n *\r\n * @method encodeFunctionCall\r\n * @param {Array} jsonInterface\r\n * @param {Array} params\r\n * @return {String} The encoded ABI for this function call\r\n */\r\nABICoder.prototype.encodeFunctionCall = function (jsonInterface, params) {\r\n    return this.encodeFunctionSignature(jsonInterface) + this.encodeParameters(jsonInterface.inputs, params).replace('0x', '');\r\n};\r\n/**\r\n * Should be used to decode bytes to plain param\r\n *\r\n * @method decodeParameter\r\n * @param {String} type\r\n * @param {String} bytes\r\n * @return {Object} plain param\r\n */\r\nABICoder.prototype.decodeParameter = function (type, bytes) {\r\n    return this.decodeParameters([type], bytes)[0];\r\n};\r\n/**\r\n * Should be used to decode list of params\r\n *\r\n * @method decodeParameter\r\n * @param {Array} outputs\r\n * @param {String} bytes\r\n * @return {Array} array of plain params\r\n */\r\nABICoder.prototype.decodeParameters = function (outputs, bytes) {\r\n    return this.decodeParametersWith(outputs, bytes, false);\r\n};\r\n/**\r\n * Should be used to decode list of params\r\n *\r\n * @method decodeParameter\r\n * @param {Array} outputs\r\n * @param {String} bytes\r\n * @param {Boolean} loose\r\n * @return {Array} array of plain params\r\n */\r\nABICoder.prototype.decodeParametersWith = function (outputs, bytes, loose) {\r\n    if (outputs.length > 0 && (!bytes || bytes === '0x' || bytes === '0X')) {\r\n        throw new Error('Returned values aren\\'t valid, did it run Out of Gas? ' +\r\n            'You might also see this error if you are not using the ' +\r\n            'correct ABI for the contract you are retrieving data from, ' +\r\n            'requesting data from a block number that does not exist, ' +\r\n            'or querying a node which is not fully synced.');\r\n    }\r\n    var res = ethersAbiCoder.decode(this.mapTypes(outputs), '0x' + bytes.replace(/0x/i, ''), loose);\r\n    var returnValue = new Result();\r\n    returnValue.__length__ = 0;\r\n    outputs.forEach(function (output, i) {\r\n        var decodedValue = res[returnValue.__length__];\r\n        const isStringObject = typeof output === 'object' && output.type && output.type === 'string';\r\n        const isStringType = typeof output === 'string' && output === 'string';\r\n        // only convert `0x` to null if it's not string value\r\n        decodedValue = (decodedValue === '0x' && !isStringObject && !isStringType) ? null : decodedValue;\r\n        returnValue[i] = decodedValue;\r\n        if ((typeof output === 'function' || !!output && typeof output === 'object') && output.name) {\r\n            returnValue[output.name] = decodedValue;\r\n        }\r\n        returnValue.__length__++;\r\n    });\r\n    return returnValue;\r\n};\r\n/**\r\n * Decodes events non- and indexed parameters.\r\n *\r\n * @method decodeLog\r\n * @param {Object} inputs\r\n * @param {String} data\r\n * @param {Array} topics\r\n * @return {Array} array of plain params\r\n */\r\nABICoder.prototype.decodeLog = function (inputs, data, topics) {\r\n    var _this = this;\r\n    topics = Array.isArray(topics) ? topics : [topics];\r\n    data = data || '';\r\n    var notIndexedInputs = [];\r\n    var indexedParams = [];\r\n    var topicCount = 0;\r\n    // TODO check for anonymous logs?\r\n    inputs.forEach(function (input, i) {\r\n        if (input.indexed) {\r\n            indexedParams[i] = (['bool', 'int', 'uint', 'address', 'fixed', 'ufixed'].find(function (staticType) {\r\n                return input.type.indexOf(staticType) !== -1;\r\n            })) ? _this.decodeParameter(input.type, topics[topicCount]) : topics[topicCount];\r\n            topicCount++;\r\n        }\r\n        else {\r\n            notIndexedInputs[i] = input;\r\n        }\r\n    });\r\n    var nonIndexedData = data;\r\n    var notIndexedParams = (nonIndexedData) ? this.decodeParametersWith(notIndexedInputs, nonIndexedData, true) : [];\r\n    var returnValue = new Result();\r\n    returnValue.__length__ = 0;\r\n    inputs.forEach(function (res, i) {\r\n        returnValue[i] = (res.type === 'string') ? '' : null;\r\n        if (typeof notIndexedParams[i] !== 'undefined') {\r\n            returnValue[i] = notIndexedParams[i];\r\n        }\r\n        if (typeof indexedParams[i] !== 'undefined') {\r\n            returnValue[i] = indexedParams[i];\r\n        }\r\n        if (res.name) {\r\n            returnValue[res.name] = returnValue[i];\r\n        }\r\n        returnValue.__length__++;\r\n    });\r\n    return returnValue;\r\n};\r\nvar coder = new ABICoder();\r\nmodule.exports = coder;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}
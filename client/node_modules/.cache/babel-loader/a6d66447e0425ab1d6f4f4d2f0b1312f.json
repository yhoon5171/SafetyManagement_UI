{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { arrayify, hexConcat, hexlify, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { id } from \"./id\";\nconst padding = new Uint8Array(32);\npadding.fill(0);\nconst NegativeOne = BigNumber.from(-1);\nconst Zero = BigNumber.from(0);\nconst One = BigNumber.from(1);\nconst MaxUint256 = BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n\nfunction hexPadRight(value) {\n  const bytes = arrayify(value);\n  const padOffset = bytes.length % 32;\n\n  if (padOffset) {\n    return hexConcat([bytes, padding.slice(padOffset)]);\n  }\n\n  return hexlify(bytes);\n}\n\nconst hexTrue = hexZeroPad(One.toHexString(), 32);\nconst hexFalse = hexZeroPad(Zero.toHexString(), 32);\nconst domainFieldTypes = {\n  name: \"string\",\n  version: \"string\",\n  chainId: \"uint256\",\n  verifyingContract: \"address\",\n  salt: \"bytes32\"\n};\nconst domainFieldNames = [\"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"];\n\nfunction checkString(key) {\n  return function (value) {\n    if (typeof value !== \"string\") {\n      logger.throwArgumentError(`invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);\n    }\n\n    return value;\n  };\n}\n\nconst domainChecks = {\n  name: checkString(\"name\"),\n  version: checkString(\"version\"),\n  chainId: function (value) {\n    try {\n      return BigNumber.from(value).toString();\n    } catch (error) {}\n\n    return logger.throwArgumentError(`invalid domain value for \"chainId\"`, \"domain.chainId\", value);\n  },\n  verifyingContract: function (value) {\n    try {\n      return getAddress(value).toLowerCase();\n    } catch (error) {}\n\n    return logger.throwArgumentError(`invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\n  },\n  salt: function (value) {\n    try {\n      const bytes = arrayify(value);\n\n      if (bytes.length !== 32) {\n        throw new Error(\"bad length\");\n      }\n\n      return hexlify(bytes);\n    } catch (error) {}\n\n    return logger.throwArgumentError(`invalid domain value \"salt\"`, \"domain.salt\", value);\n  }\n};\n\nfunction getBaseEncoder(type) {\n  // intXX and uintXX\n  {\n    const match = type.match(/^(u?)int(\\d*)$/);\n\n    if (match) {\n      const signed = match[1] === \"\";\n      const width = parseInt(match[2] || \"256\");\n\n      if (width % 8 !== 0 || width > 256 || match[2] && match[2] !== String(width)) {\n        logger.throwArgumentError(\"invalid numeric width\", \"type\", type);\n      }\n\n      const boundsUpper = MaxUint256.mask(signed ? width - 1 : width);\n      const boundsLower = signed ? boundsUpper.add(One).mul(NegativeOne) : Zero;\n      return function (value) {\n        const v = BigNumber.from(value);\n\n        if (v.lt(boundsLower) || v.gt(boundsUpper)) {\n          logger.throwArgumentError(`value out-of-bounds for ${type}`, \"value\", value);\n        }\n\n        return hexZeroPad(v.toTwos(256).toHexString(), 32);\n      };\n    }\n  } // bytesXX\n\n  {\n    const match = type.match(/^bytes(\\d+)$/);\n\n    if (match) {\n      const width = parseInt(match[1]);\n\n      if (width === 0 || width > 32 || match[1] !== String(width)) {\n        logger.throwArgumentError(\"invalid bytes width\", \"type\", type);\n      }\n\n      return function (value) {\n        const bytes = arrayify(value);\n\n        if (bytes.length !== width) {\n          logger.throwArgumentError(`invalid length for ${type}`, \"value\", value);\n        }\n\n        return hexPadRight(value);\n      };\n    }\n  }\n\n  switch (type) {\n    case \"address\":\n      return function (value) {\n        return hexZeroPad(getAddress(value), 32);\n      };\n\n    case \"bool\":\n      return function (value) {\n        return !value ? hexFalse : hexTrue;\n      };\n\n    case \"bytes\":\n      return function (value) {\n        return keccak256(value);\n      };\n\n    case \"string\":\n      return function (value) {\n        return id(value);\n      };\n  }\n\n  return null;\n}\n\nfunction encodeType(name, fields) {\n  return `${name}(${fields.map(_ref => {\n    let {\n      name,\n      type\n    } = _ref;\n    return type + \" \" + name;\n  }).join(\",\")})`;\n}\n\nexport class TypedDataEncoder {\n  constructor(types) {\n    defineReadOnly(this, \"types\", Object.freeze(deepCopy(types)));\n    defineReadOnly(this, \"_encoderCache\", {});\n    defineReadOnly(this, \"_types\", {}); // Link struct types to their direct child structs\n\n    const links = {}; // Link structs to structs which contain them as a child\n\n    const parents = {}; // Link all subtypes within a given struct\n\n    const subtypes = {};\n    Object.keys(types).forEach(type => {\n      links[type] = {};\n      parents[type] = [];\n      subtypes[type] = {};\n    });\n\n    for (const name in types) {\n      const uniqueNames = {};\n      types[name].forEach(field => {\n        // Check each field has a unique name\n        if (uniqueNames[field.name]) {\n          logger.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, \"types\", types);\n        }\n\n        uniqueNames[field.name] = true; // Get the base type (drop any array specifiers)\n\n        const baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1];\n\n        if (baseType === name) {\n          logger.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, \"types\", types);\n        } // Is this a base encoding type?\n\n\n        const encoder = getBaseEncoder(baseType);\n\n        if (encoder) {\n          return;\n        }\n\n        if (!parents[baseType]) {\n          logger.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, \"types\", types);\n        } // Add linkage\n\n\n        parents[baseType].push(name);\n        links[name][baseType] = true;\n      });\n    } // Deduce the primary type\n\n\n    const primaryTypes = Object.keys(parents).filter(n => parents[n].length === 0);\n\n    if (primaryTypes.length === 0) {\n      logger.throwArgumentError(\"missing primary type\", \"types\", types);\n    } else if (primaryTypes.length > 1) {\n      logger.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map(t => JSON.stringify(t)).join(\", \")}`, \"types\", types);\n    }\n\n    defineReadOnly(this, \"primaryType\", primaryTypes[0]); // Check for circular type references\n\n    function checkCircular(type, found) {\n      if (found[type]) {\n        logger.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`, \"types\", types);\n      }\n\n      found[type] = true;\n      Object.keys(links[type]).forEach(child => {\n        if (!parents[child]) {\n          return;\n        } // Recursively check children\n\n\n        checkCircular(child, found); // Mark all ancestors as having this decendant\n\n        Object.keys(found).forEach(subtype => {\n          subtypes[subtype][child] = true;\n        });\n      });\n      delete found[type];\n    }\n\n    checkCircular(this.primaryType, {}); // Compute each fully describe type\n\n    for (const name in subtypes) {\n      const st = Object.keys(subtypes[name]);\n      st.sort();\n      this._types[name] = encodeType(name, types[name]) + st.map(t => encodeType(t, types[t])).join(\"\");\n    }\n  }\n\n  getEncoder(type) {\n    let encoder = this._encoderCache[type];\n\n    if (!encoder) {\n      encoder = this._encoderCache[type] = this._getEncoder(type);\n    }\n\n    return encoder;\n  }\n\n  _getEncoder(type) {\n    // Basic encoder type (address, bool, uint256, etc)\n    {\n      const encoder = getBaseEncoder(type);\n\n      if (encoder) {\n        return encoder;\n      }\n    } // Array\n\n    const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n\n    if (match) {\n      const subtype = match[1];\n      const subEncoder = this.getEncoder(subtype);\n      const length = parseInt(match[3]);\n      return value => {\n        if (length >= 0 && value.length !== length) {\n          logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n        }\n\n        let result = value.map(subEncoder);\n\n        if (this._types[subtype]) {\n          result = result.map(keccak256);\n        }\n\n        return keccak256(hexConcat(result));\n      };\n    } // Struct\n\n\n    const fields = this.types[type];\n\n    if (fields) {\n      const encodedType = id(this._types[type]);\n      return value => {\n        const values = fields.map(_ref2 => {\n          let {\n            name,\n            type\n          } = _ref2;\n          const result = this.getEncoder(type)(value[name]);\n\n          if (this._types[type]) {\n            return keccak256(result);\n          }\n\n          return result;\n        });\n        values.unshift(encodedType);\n        return hexConcat(values);\n      };\n    }\n\n    return logger.throwArgumentError(`unknown type: ${type}`, \"type\", type);\n  }\n\n  encodeType(name) {\n    const result = this._types[name];\n\n    if (!result) {\n      logger.throwArgumentError(`unknown type: ${JSON.stringify(name)}`, \"name\", name);\n    }\n\n    return result;\n  }\n\n  encodeData(type, value) {\n    return this.getEncoder(type)(value);\n  }\n\n  hashStruct(name, value) {\n    return keccak256(this.encodeData(name, value));\n  }\n\n  encode(value) {\n    return this.encodeData(this.primaryType, value);\n  }\n\n  hash(value) {\n    return this.hashStruct(this.primaryType, value);\n  }\n\n  _visit(type, value, callback) {\n    // Basic encoder type (address, bool, uint256, etc)\n    {\n      const encoder = getBaseEncoder(type);\n\n      if (encoder) {\n        return callback(type, value);\n      }\n    } // Array\n\n    const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n\n    if (match) {\n      const subtype = match[1];\n      const length = parseInt(match[3]);\n\n      if (length >= 0 && value.length !== length) {\n        logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n      }\n\n      return value.map(v => this._visit(subtype, v, callback));\n    } // Struct\n\n\n    const fields = this.types[type];\n\n    if (fields) {\n      return fields.reduce((accum, _ref3) => {\n        let {\n          name,\n          type\n        } = _ref3;\n        accum[name] = this._visit(type, value[name], callback);\n        return accum;\n      }, {});\n    }\n\n    return logger.throwArgumentError(`unknown type: ${type}`, \"type\", type);\n  }\n\n  visit(value, callback) {\n    return this._visit(this.primaryType, value, callback);\n  }\n\n  static from(types) {\n    return new TypedDataEncoder(types);\n  }\n\n  static getPrimaryType(types) {\n    return TypedDataEncoder.from(types).primaryType;\n  }\n\n  static hashStruct(name, types, value) {\n    return TypedDataEncoder.from(types).hashStruct(name, value);\n  }\n\n  static hashDomain(domain) {\n    const domainFields = [];\n\n    for (const name in domain) {\n      const type = domainFieldTypes[name];\n\n      if (!type) {\n        logger.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name)}`, \"domain\", domain);\n      }\n\n      domainFields.push({\n        name,\n        type\n      });\n    }\n\n    domainFields.sort((a, b) => {\n      return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n    });\n    return TypedDataEncoder.hashStruct(\"EIP712Domain\", {\n      EIP712Domain: domainFields\n    }, domain);\n  }\n\n  static encode(domain, types, value) {\n    return hexConcat([\"0x1901\", TypedDataEncoder.hashDomain(domain), TypedDataEncoder.from(types).hash(value)]);\n  }\n\n  static hash(domain, types, value) {\n    return keccak256(TypedDataEncoder.encode(domain, types, value));\n  } // Replaces all address types with ENS names with their looked up address\n\n\n  static resolveNames(domain, types, value, resolveName) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Make a copy to isolate it from the object passed in\n      domain = shallowCopy(domain); // Look up all ENS names\n\n      const ensCache = {}; // Do we need to look up the domain's verifyingContract?\n\n      if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {\n        ensCache[domain.verifyingContract] = \"0x\";\n      } // We are going to use the encoder to visit all the base values\n\n\n      const encoder = TypedDataEncoder.from(types); // Get a list of all the addresses\n\n      encoder.visit(value, (type, value) => {\n        if (type === \"address\" && !isHexString(value, 20)) {\n          ensCache[value] = \"0x\";\n        }\n\n        return value;\n      }); // Lookup each name\n\n      for (const name in ensCache) {\n        ensCache[name] = yield resolveName(name);\n      } // Replace the domain verifyingContract if needed\n\n\n      if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n        domain.verifyingContract = ensCache[domain.verifyingContract];\n      } // Replace all ENS names with their address\n\n\n      value = encoder.visit(value, (type, value) => {\n        if (type === \"address\" && ensCache[value]) {\n          return ensCache[value];\n        }\n\n        return value;\n      });\n      return {\n        domain,\n        value\n      };\n    });\n  }\n\n  static getPayload(domain, types, value) {\n    // Validate the domain fields\n    TypedDataEncoder.hashDomain(domain); // Derive the EIP712Domain Struct reference type\n\n    const domainValues = {};\n    const domainTypes = [];\n    domainFieldNames.forEach(name => {\n      const value = domain[name];\n\n      if (value == null) {\n        return;\n      }\n\n      domainValues[name] = domainChecks[name](value);\n      domainTypes.push({\n        name,\n        type: domainFieldTypes[name]\n      });\n    });\n    const encoder = TypedDataEncoder.from(types);\n    const typesWithDomain = shallowCopy(types);\n\n    if (typesWithDomain.EIP712Domain) {\n      logger.throwArgumentError(\"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n    } else {\n      typesWithDomain.EIP712Domain = domainTypes;\n    } // Validate the data structures and types\n\n\n    encoder.encode(value);\n    return {\n      types: typesWithDomain,\n      domain: domainValues,\n      primaryType: encoder.primaryType,\n      message: encoder.visit(value, (type, value) => {\n        // bytes\n        if (type.match(/^bytes(\\d*)/)) {\n          return hexlify(arrayify(value));\n        } // uint or int\n\n\n        if (type.match(/^u?int/)) {\n          return BigNumber.from(value).toString();\n        }\n\n        switch (type) {\n          case \"address\":\n            return value.toLowerCase();\n\n          case \"bool\":\n            return !!value;\n\n          case \"string\":\n            if (typeof value !== \"string\") {\n              logger.throwArgumentError(`invalid string`, \"value\", value);\n            }\n\n            return value;\n        }\n\n        return logger.throwArgumentError(\"unsupported type\", \"type\", type);\n      })\n    };\n  }\n\n}","map":{"version":3,"sources":["../src.ts/typed-data.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nimport { getAddress } from \"@ethersproject/address\";\r\nimport { BigNumber } from \"@ethersproject/bignumber\";\r\nimport { arrayify, hexConcat, hexlify, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\r\nimport { keccak256 } from \"@ethersproject/keccak256\";\r\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\r\nimport { Logger } from \"@ethersproject/logger\";\r\nimport { version } from \"./_version\";\r\nconst logger = new Logger(version);\r\nimport { id } from \"./id\";\r\nconst padding = new Uint8Array(32);\r\npadding.fill(0);\r\nconst NegativeOne = BigNumber.from(-1);\r\nconst Zero = BigNumber.from(0);\r\nconst One = BigNumber.from(1);\r\nconst MaxUint256 = BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\r\nfunction hexPadRight(value) {\r\n    const bytes = arrayify(value);\r\n    const padOffset = bytes.length % 32;\r\n    if (padOffset) {\r\n        return hexConcat([bytes, padding.slice(padOffset)]);\r\n    }\r\n    return hexlify(bytes);\r\n}\r\nconst hexTrue = hexZeroPad(One.toHexString(), 32);\r\nconst hexFalse = hexZeroPad(Zero.toHexString(), 32);\r\nconst domainFieldTypes = {\r\n    name: \"string\",\r\n    version: \"string\",\r\n    chainId: \"uint256\",\r\n    verifyingContract: \"address\",\r\n    salt: \"bytes32\"\r\n};\r\nconst domainFieldNames = [\r\n    \"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"\r\n];\r\nfunction checkString(key) {\r\n    return function (value) {\r\n        if (typeof (value) !== \"string\") {\r\n            logger.throwArgumentError(`invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);\r\n        }\r\n        return value;\r\n    };\r\n}\r\nconst domainChecks = {\r\n    name: checkString(\"name\"),\r\n    version: checkString(\"version\"),\r\n    chainId: function (value) {\r\n        try {\r\n            return BigNumber.from(value).toString();\r\n        }\r\n        catch (error) { }\r\n        return logger.throwArgumentError(`invalid domain value for \"chainId\"`, \"domain.chainId\", value);\r\n    },\r\n    verifyingContract: function (value) {\r\n        try {\r\n            return getAddress(value).toLowerCase();\r\n        }\r\n        catch (error) { }\r\n        return logger.throwArgumentError(`invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\r\n    },\r\n    salt: function (value) {\r\n        try {\r\n            const bytes = arrayify(value);\r\n            if (bytes.length !== 32) {\r\n                throw new Error(\"bad length\");\r\n            }\r\n            return hexlify(bytes);\r\n        }\r\n        catch (error) { }\r\n        return logger.throwArgumentError(`invalid domain value \"salt\"`, \"domain.salt\", value);\r\n    }\r\n};\r\nfunction getBaseEncoder(type) {\r\n    // intXX and uintXX\r\n    {\r\n        const match = type.match(/^(u?)int(\\d*)$/);\r\n        if (match) {\r\n            const signed = (match[1] === \"\");\r\n            const width = parseInt(match[2] || \"256\");\r\n            if (width % 8 !== 0 || width > 256 || (match[2] && match[2] !== String(width))) {\r\n                logger.throwArgumentError(\"invalid numeric width\", \"type\", type);\r\n            }\r\n            const boundsUpper = MaxUint256.mask(signed ? (width - 1) : width);\r\n            const boundsLower = signed ? boundsUpper.add(One).mul(NegativeOne) : Zero;\r\n            return function (value) {\r\n                const v = BigNumber.from(value);\r\n                if (v.lt(boundsLower) || v.gt(boundsUpper)) {\r\n                    logger.throwArgumentError(`value out-of-bounds for ${type}`, \"value\", value);\r\n                }\r\n                return hexZeroPad(v.toTwos(256).toHexString(), 32);\r\n            };\r\n        }\r\n    }\r\n    // bytesXX\r\n    {\r\n        const match = type.match(/^bytes(\\d+)$/);\r\n        if (match) {\r\n            const width = parseInt(match[1]);\r\n            if (width === 0 || width > 32 || match[1] !== String(width)) {\r\n                logger.throwArgumentError(\"invalid bytes width\", \"type\", type);\r\n            }\r\n            return function (value) {\r\n                const bytes = arrayify(value);\r\n                if (bytes.length !== width) {\r\n                    logger.throwArgumentError(`invalid length for ${type}`, \"value\", value);\r\n                }\r\n                return hexPadRight(value);\r\n            };\r\n        }\r\n    }\r\n    switch (type) {\r\n        case \"address\": return function (value) {\r\n            return hexZeroPad(getAddress(value), 32);\r\n        };\r\n        case \"bool\": return function (value) {\r\n            return ((!value) ? hexFalse : hexTrue);\r\n        };\r\n        case \"bytes\": return function (value) {\r\n            return keccak256(value);\r\n        };\r\n        case \"string\": return function (value) {\r\n            return id(value);\r\n        };\r\n    }\r\n    return null;\r\n}\r\nfunction encodeType(name, fields) {\r\n    return `${name}(${fields.map(({ name, type }) => (type + \" \" + name)).join(\",\")})`;\r\n}\r\nexport class TypedDataEncoder {\r\n    constructor(types) {\r\n        defineReadOnly(this, \"types\", Object.freeze(deepCopy(types)));\r\n        defineReadOnly(this, \"_encoderCache\", {});\r\n        defineReadOnly(this, \"_types\", {});\r\n        // Link struct types to their direct child structs\r\n        const links = {};\r\n        // Link structs to structs which contain them as a child\r\n        const parents = {};\r\n        // Link all subtypes within a given struct\r\n        const subtypes = {};\r\n        Object.keys(types).forEach((type) => {\r\n            links[type] = {};\r\n            parents[type] = [];\r\n            subtypes[type] = {};\r\n        });\r\n        for (const name in types) {\r\n            const uniqueNames = {};\r\n            types[name].forEach((field) => {\r\n                // Check each field has a unique name\r\n                if (uniqueNames[field.name]) {\r\n                    logger.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, \"types\", types);\r\n                }\r\n                uniqueNames[field.name] = true;\r\n                // Get the base type (drop any array specifiers)\r\n                const baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1];\r\n                if (baseType === name) {\r\n                    logger.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, \"types\", types);\r\n                }\r\n                // Is this a base encoding type?\r\n                const encoder = getBaseEncoder(baseType);\r\n                if (encoder) {\r\n                    return;\r\n                }\r\n                if (!parents[baseType]) {\r\n                    logger.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, \"types\", types);\r\n                }\r\n                // Add linkage\r\n                parents[baseType].push(name);\r\n                links[name][baseType] = true;\r\n            });\r\n        }\r\n        // Deduce the primary type\r\n        const primaryTypes = Object.keys(parents).filter((n) => (parents[n].length === 0));\r\n        if (primaryTypes.length === 0) {\r\n            logger.throwArgumentError(\"missing primary type\", \"types\", types);\r\n        }\r\n        else if (primaryTypes.length > 1) {\r\n            logger.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map((t) => (JSON.stringify(t))).join(\", \")}`, \"types\", types);\r\n        }\r\n        defineReadOnly(this, \"primaryType\", primaryTypes[0]);\r\n        // Check for circular type references\r\n        function checkCircular(type, found) {\r\n            if (found[type]) {\r\n                logger.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`, \"types\", types);\r\n            }\r\n            found[type] = true;\r\n            Object.keys(links[type]).forEach((child) => {\r\n                if (!parents[child]) {\r\n                    return;\r\n                }\r\n                // Recursively check children\r\n                checkCircular(child, found);\r\n                // Mark all ancestors as having this decendant\r\n                Object.keys(found).forEach((subtype) => {\r\n                    subtypes[subtype][child] = true;\r\n                });\r\n            });\r\n            delete found[type];\r\n        }\r\n        checkCircular(this.primaryType, {});\r\n        // Compute each fully describe type\r\n        for (const name in subtypes) {\r\n            const st = Object.keys(subtypes[name]);\r\n            st.sort();\r\n            this._types[name] = encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join(\"\");\r\n        }\r\n    }\r\n    getEncoder(type) {\r\n        let encoder = this._encoderCache[type];\r\n        if (!encoder) {\r\n            encoder = this._encoderCache[type] = this._getEncoder(type);\r\n        }\r\n        return encoder;\r\n    }\r\n    _getEncoder(type) {\r\n        // Basic encoder type (address, bool, uint256, etc)\r\n        {\r\n            const encoder = getBaseEncoder(type);\r\n            if (encoder) {\r\n                return encoder;\r\n            }\r\n        }\r\n        // Array\r\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\r\n        if (match) {\r\n            const subtype = match[1];\r\n            const subEncoder = this.getEncoder(subtype);\r\n            const length = parseInt(match[3]);\r\n            return (value) => {\r\n                if (length >= 0 && value.length !== length) {\r\n                    logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\r\n                }\r\n                let result = value.map(subEncoder);\r\n                if (this._types[subtype]) {\r\n                    result = result.map(keccak256);\r\n                }\r\n                return keccak256(hexConcat(result));\r\n            };\r\n        }\r\n        // Struct\r\n        const fields = this.types[type];\r\n        if (fields) {\r\n            const encodedType = id(this._types[type]);\r\n            return (value) => {\r\n                const values = fields.map(({ name, type }) => {\r\n                    const result = this.getEncoder(type)(value[name]);\r\n                    if (this._types[type]) {\r\n                        return keccak256(result);\r\n                    }\r\n                    return result;\r\n                });\r\n                values.unshift(encodedType);\r\n                return hexConcat(values);\r\n            };\r\n        }\r\n        return logger.throwArgumentError(`unknown type: ${type}`, \"type\", type);\r\n    }\r\n    encodeType(name) {\r\n        const result = this._types[name];\r\n        if (!result) {\r\n            logger.throwArgumentError(`unknown type: ${JSON.stringify(name)}`, \"name\", name);\r\n        }\r\n        return result;\r\n    }\r\n    encodeData(type, value) {\r\n        return this.getEncoder(type)(value);\r\n    }\r\n    hashStruct(name, value) {\r\n        return keccak256(this.encodeData(name, value));\r\n    }\r\n    encode(value) {\r\n        return this.encodeData(this.primaryType, value);\r\n    }\r\n    hash(value) {\r\n        return this.hashStruct(this.primaryType, value);\r\n    }\r\n    _visit(type, value, callback) {\r\n        // Basic encoder type (address, bool, uint256, etc)\r\n        {\r\n            const encoder = getBaseEncoder(type);\r\n            if (encoder) {\r\n                return callback(type, value);\r\n            }\r\n        }\r\n        // Array\r\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\r\n        if (match) {\r\n            const subtype = match[1];\r\n            const length = parseInt(match[3]);\r\n            if (length >= 0 && value.length !== length) {\r\n                logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\r\n            }\r\n            return value.map((v) => this._visit(subtype, v, callback));\r\n        }\r\n        // Struct\r\n        const fields = this.types[type];\r\n        if (fields) {\r\n            return fields.reduce((accum, { name, type }) => {\r\n                accum[name] = this._visit(type, value[name], callback);\r\n                return accum;\r\n            }, {});\r\n        }\r\n        return logger.throwArgumentError(`unknown type: ${type}`, \"type\", type);\r\n    }\r\n    visit(value, callback) {\r\n        return this._visit(this.primaryType, value, callback);\r\n    }\r\n    static from(types) {\r\n        return new TypedDataEncoder(types);\r\n    }\r\n    static getPrimaryType(types) {\r\n        return TypedDataEncoder.from(types).primaryType;\r\n    }\r\n    static hashStruct(name, types, value) {\r\n        return TypedDataEncoder.from(types).hashStruct(name, value);\r\n    }\r\n    static hashDomain(domain) {\r\n        const domainFields = [];\r\n        for (const name in domain) {\r\n            const type = domainFieldTypes[name];\r\n            if (!type) {\r\n                logger.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name)}`, \"domain\", domain);\r\n            }\r\n            domainFields.push({ name, type });\r\n        }\r\n        domainFields.sort((a, b) => {\r\n            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\r\n        });\r\n        return TypedDataEncoder.hashStruct(\"EIP712Domain\", { EIP712Domain: domainFields }, domain);\r\n    }\r\n    static encode(domain, types, value) {\r\n        return hexConcat([\r\n            \"0x1901\",\r\n            TypedDataEncoder.hashDomain(domain),\r\n            TypedDataEncoder.from(types).hash(value)\r\n        ]);\r\n    }\r\n    static hash(domain, types, value) {\r\n        return keccak256(TypedDataEncoder.encode(domain, types, value));\r\n    }\r\n    // Replaces all address types with ENS names with their looked up address\r\n    static resolveNames(domain, types, value, resolveName) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            // Make a copy to isolate it from the object passed in\r\n            domain = shallowCopy(domain);\r\n            // Look up all ENS names\r\n            const ensCache = {};\r\n            // Do we need to look up the domain's verifyingContract?\r\n            if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {\r\n                ensCache[domain.verifyingContract] = \"0x\";\r\n            }\r\n            // We are going to use the encoder to visit all the base values\r\n            const encoder = TypedDataEncoder.from(types);\r\n            // Get a list of all the addresses\r\n            encoder.visit(value, (type, value) => {\r\n                if (type === \"address\" && !isHexString(value, 20)) {\r\n                    ensCache[value] = \"0x\";\r\n                }\r\n                return value;\r\n            });\r\n            // Lookup each name\r\n            for (const name in ensCache) {\r\n                ensCache[name] = yield resolveName(name);\r\n            }\r\n            // Replace the domain verifyingContract if needed\r\n            if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\r\n                domain.verifyingContract = ensCache[domain.verifyingContract];\r\n            }\r\n            // Replace all ENS names with their address\r\n            value = encoder.visit(value, (type, value) => {\r\n                if (type === \"address\" && ensCache[value]) {\r\n                    return ensCache[value];\r\n                }\r\n                return value;\r\n            });\r\n            return { domain, value };\r\n        });\r\n    }\r\n    static getPayload(domain, types, value) {\r\n        // Validate the domain fields\r\n        TypedDataEncoder.hashDomain(domain);\r\n        // Derive the EIP712Domain Struct reference type\r\n        const domainValues = {};\r\n        const domainTypes = [];\r\n        domainFieldNames.forEach((name) => {\r\n            const value = domain[name];\r\n            if (value == null) {\r\n                return;\r\n            }\r\n            domainValues[name] = domainChecks[name](value);\r\n            domainTypes.push({ name, type: domainFieldTypes[name] });\r\n        });\r\n        const encoder = TypedDataEncoder.from(types);\r\n        const typesWithDomain = shallowCopy(types);\r\n        if (typesWithDomain.EIP712Domain) {\r\n            logger.throwArgumentError(\"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\r\n        }\r\n        else {\r\n            typesWithDomain.EIP712Domain = domainTypes;\r\n        }\r\n        // Validate the data structures and types\r\n        encoder.encode(value);\r\n        return {\r\n            types: typesWithDomain,\r\n            domain: domainValues,\r\n            primaryType: encoder.primaryType,\r\n            message: encoder.visit(value, (type, value) => {\r\n                // bytes\r\n                if (type.match(/^bytes(\\d*)/)) {\r\n                    return hexlify(arrayify(value));\r\n                }\r\n                // uint or int\r\n                if (type.match(/^u?int/)) {\r\n                    return BigNumber.from(value).toString();\r\n                }\r\n                switch (type) {\r\n                    case \"address\":\r\n                        return value.toLowerCase();\r\n                    case \"bool\":\r\n                        return !!value;\r\n                    case \"string\":\r\n                        if (typeof (value) !== \"string\") {\r\n                            logger.throwArgumentError(`invalid string`, \"value\", value);\r\n                        }\r\n                        return value;\r\n                }\r\n                return logger.throwArgumentError(\"unsupported type\", \"type\", type);\r\n            })\r\n        };\r\n    }\r\n}\r\n//# sourceMappingURL=typed-data.js.map"]},"metadata":{},"sourceType":"module"}
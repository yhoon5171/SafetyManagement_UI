{"ast":null,"code":"var pkgVersion = require(\"./package.json\").version;\n\nvar Ajv = require(\"ajv\");\n\nvar util = require(\"util\");\n\nvar contractObjectSchema = require(\"./spec/contract-object.spec.json\");\n\nvar networkObjectSchema = require(\"./spec/network-object.spec.json\");\n\nvar abiSchema = require(\"./spec/abi.spec.json\");\n/**\r\n * Property definitions for Contract Objects\r\n *\r\n * Describes canonical output properties as sourced from some \"dirty\" input\r\n * object. Describes normalization process to account for deprecated and/or\r\n * nonstandard keys and values.\r\n *\r\n * Maps (key -> property) where:\r\n *  - `key` is the top-level output key matching up with those in the schema\r\n *  - `property` is an object with optional values:\r\n *      - `sources`: list of sources (see below); default `key`\r\n *      - `transform`: function(value) -> transformed value; default x -> x\r\n *\r\n * Each source represents a means to select a value from dirty object.\r\n * Allows:\r\n *  - dot-separated (`.`) string, corresponding to path to value in dirty\r\n *    object\r\n *  - function(dirtyObj) -> (cleanValue | undefined)\r\n *\r\n * The optional `transform` parameter standardizes value regardless of source,\r\n * for purposes of ensuring data type and/or string schemas.\r\n */\n// helper that ensures abi's do not contain function signatures\n\n\nconst sanitizedValue = dirtyValueArray => {\n  let sanitizedValueArray = [];\n  dirtyValueArray.forEach(item => {\n    let sanitizedItem = Object.assign({}, item);\n    delete sanitizedItem.signature;\n    sanitizedValueArray.push(sanitizedItem);\n  });\n  return sanitizedValueArray;\n}; // filter `signature` property from an event\n\n\nconst sanitizeEvent = dirtyEvent => Object.entries(dirtyEvent).reduce((acc, _ref) => {\n  let [property, value] = _ref;\n  return property === \"signature\" ? acc : Object.assign(acc, {\n    [property]: value\n  });\n}, {}); // sanitize aggregrate events given a `network-object.spec.json#events` object\n\n\nconst sanitizeAllEvents = dirtyEvents => Object.entries(dirtyEvents).reduce((acc, _ref2) => {\n  let [property, event] = _ref2;\n  return Object.assign(acc, {\n    [property]: sanitizeEvent(event)\n  });\n}, {});\n\nvar properties = {\n  contractName: {\n    sources: [\"contractName\", \"contract_name\"]\n  },\n  abi: {\n    sources: [\"abi\", \"interface\"],\n    transform: function (value) {\n      if (typeof value === \"string\") {\n        try {\n          value = JSON.parse(value);\n        } catch (_) {\n          value = undefined;\n        }\n      }\n\n      if (Array.isArray(value)) {\n        return sanitizedValue(value);\n      }\n\n      return value;\n    }\n  },\n  metadata: {\n    sources: [\"metadata\"]\n  },\n  bytecode: {\n    sources: [\"bytecode\", \"binary\", \"unlinked_binary\", \"evm.bytecode.object\"],\n    transform: function (value) {\n      if (value && value.indexOf(\"0x\") !== 0) {\n        value = \"0x\" + value;\n      }\n\n      return value;\n    }\n  },\n  deployedBytecode: {\n    sources: [\"deployedBytecode\", \"runtimeBytecode\", \"evm.deployedBytecode.object\"],\n    transform: function (value) {\n      if (value && value.indexOf(\"0x\") !== 0) {\n        value = \"0x\" + value;\n      }\n\n      return value;\n    }\n  },\n  immutableReferences: {},\n  generatedSources: {},\n  deployedGeneratedSources: {},\n  sourceMap: {\n    transform: function (value) {\n      if (typeof value === \"string\") {\n        try {\n          return JSON.parse(value);\n        } catch (_) {\n          return value;\n        }\n      } else {\n        return value;\n      }\n    },\n    sources: [\"sourceMap\", \"srcmap\", \"evm.bytecode.sourceMap\"]\n  },\n  deployedSourceMap: {\n    transform: function (value) {\n      if (typeof value === \"string\") {\n        try {\n          return JSON.parse(value);\n        } catch (_) {\n          return value;\n        }\n      } else {\n        return value;\n      }\n    },\n    sources: [\"deployedSourceMap\", \"srcmapRuntime\", \"evm.deployedBytecode.sourceMap\"]\n  },\n  source: {},\n  sourcePath: {},\n  ast: {},\n  legacyAST: {},\n  compiler: {},\n  networks: {\n    /**\r\n     * Normalize a networks object. Currently this makes sure `events` are\r\n     * always sanitized and `links` is extracted when copying from\r\n     * a TruffleContract context object.\r\n     *\r\n     * @param {object} value - the target object\r\n     * @param {object | TruffleContract} obj - the context, or source object.\r\n     * @return {object} The normalized Network object\r\n     */\n    transform: function () {\n      let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      let obj = arguments.length > 1 ? arguments[1] : undefined;\n      // Sanitize value's events for known networks\n      Object.keys(value).forEach(networkId => {\n        if (value[networkId].events) {\n          value[networkId].events = sanitizeAllEvents(value[networkId].events);\n        }\n      }); // Set and sanitize the current networks property from the\n      // TruffleContract. Note: obj is a TruffleContract if it has\n      // `network_id` attribute\n\n      const networkId = obj.network_id;\n\n      if (networkId && value.hasOwnProperty(networkId)) {\n        value[networkId].links = obj.links;\n        value[networkId].events = sanitizeAllEvents(obj.events);\n      }\n\n      return value;\n    }\n  },\n  schemaVersion: {\n    sources: [\"schemaVersion\", \"schema_version\"]\n  },\n  updatedAt: {\n    sources: [\"updatedAt\", \"updated_at\"],\n    transform: function (value) {\n      if (typeof value === \"number\") {\n        value = new Date(value).toISOString();\n      }\n\n      return value;\n    }\n  },\n  networkType: {},\n  devdoc: {},\n  userdoc: {},\n  db: {}\n};\n/**\r\n * Construct a getter for a given key, possibly applying some post-retrieve\r\n * transformation on the resulting value.\r\n *\r\n * @return {Function} Accepting dirty object and returning value || undefined\r\n */\n\nfunction getter(key, transform) {\n  if (transform === undefined) {\n    transform = function (x) {\n      return x;\n    };\n  }\n\n  return function (obj) {\n    try {\n      return transform(obj[key]);\n    } catch (_) {\n      return undefined;\n    }\n  };\n}\n/**\r\n * Chains together a series of function(obj) -> value, passing resulting\r\n * returned value to next function in chain.\r\n *\r\n * Accepts any number of functions passed as arguments\r\n * @return {Function} Accepting initial object, returning end-of-chain value\r\n *\r\n * Assumes all intermediary values to be objects, with well-formed sequence\r\n * of operations.\r\n */\n\n\nfunction chain() {\n  var getters = Array.prototype.slice.call(arguments);\n  return function (obj) {\n    return getters.reduce(function (cur, get) {\n      return get(cur);\n    }, obj);\n  };\n} // Schema module\n//\n\n\nvar TruffleContractSchema = {\n  // Return a promise to validate a contract object\n  // - Resolves as validated `contractObj`\n  // - Rejects with list of errors from schema validator\n  validate: function (contractObj) {\n    var ajv = new Ajv({\n      verbose: true\n    });\n    ajv.addSchema(abiSchema);\n    ajv.addSchema(networkObjectSchema);\n    ajv.addSchema(contractObjectSchema);\n\n    if (ajv.validate(\"contract-object.spec.json\", contractObj)) {\n      return contractObj;\n    } else {\n      const message = `Schema validation failed. Errors:\\n\\n${ajv.errors.map(_ref3 => {\n        let {\n          keyword,\n          dataPath,\n          schemaPath,\n          params,\n          message,\n          data,\n          parentSchema\n        } = _ref3;\n        return util.format(\"%s (%s):\\n%s\\n\", message, keyword, util.inspect({\n          dataPath,\n          schemaPath,\n          params,\n          data,\n          parentSchema\n        }, {\n          depth: 5\n        }));\n      }).join(\"\\n\")}`;\n      const error = new Error(message);\n      error.errors = ajv.errors;\n      throw error;\n    }\n  },\n  // accepts as argument anything that can be turned into a contract object\n  // returns a contract object\n  normalize: function (objDirty, options) {\n    options = options || {};\n    var normalized = {}; // iterate over each property\n\n    Object.keys(properties).forEach(function (key) {\n      var property = properties[key];\n      var value; // normalized value || undefined\n      // either used the defined sources or assume the key will only ever be\n      // listed as its canonical name (itself)\n\n      var sources = property.sources || [key]; // iterate over sources until value is defined or end of list met\n\n      for (var i = 0; value === undefined && i < sources.length; i++) {\n        var source = sources[i]; // string refers to path to value in objDirty, split and chain\n        // getters\n\n        if (typeof source === \"string\") {\n          var traversals = source.split(\".\").map(function (k) {\n            return getter(k);\n          });\n          source = chain.apply(null, traversals);\n        } // source should be a function that takes the objDirty and returns\n        // value or undefined\n\n\n        value = source(objDirty);\n      } // run source-agnostic transform on value\n      // (e.g. make sure bytecode begins 0x)\n\n\n      if (property.transform) {\n        value = property.transform(value, objDirty);\n      } // add resulting (possibly undefined) to normalized obj\n\n\n      normalized[key] = value;\n    }); // Copy x- options\n\n    Object.keys(objDirty).forEach(function (key) {\n      if (key.indexOf(\"x-\") === 0) {\n        normalized[key] = getter(key)(objDirty);\n      }\n    }); // update schema version\n\n    normalized.schemaVersion = pkgVersion;\n\n    if (options.validate) {\n      this.validate(normalized);\n    }\n\n    return normalized;\n  }\n};\nmodule.exports = TruffleContractSchema;","map":{"version":3,"names":["pkgVersion","require","version","Ajv","util","contractObjectSchema","networkObjectSchema","abiSchema","sanitizedValue","dirtyValueArray","sanitizedValueArray","forEach","item","sanitizedItem","Object","assign","signature","push","sanitizeEvent","dirtyEvent","entries","reduce","acc","property","value","sanitizeAllEvents","dirtyEvents","event","properties","contractName","sources","abi","transform","JSON","parse","_","undefined","Array","isArray","metadata","bytecode","indexOf","deployedBytecode","immutableReferences","generatedSources","deployedGeneratedSources","sourceMap","deployedSourceMap","source","sourcePath","ast","legacyAST","compiler","networks","obj","keys","networkId","events","network_id","hasOwnProperty","links","schemaVersion","updatedAt","Date","toISOString","networkType","devdoc","userdoc","db","getter","key","x","chain","getters","prototype","slice","call","arguments","cur","get","TruffleContractSchema","validate","contractObj","ajv","verbose","addSchema","message","errors","map","keyword","dataPath","schemaPath","params","data","parentSchema","format","inspect","depth","join","error","Error","normalize","objDirty","options","normalized","i","length","traversals","split","k","apply","module","exports"],"sources":["D:/BlockchainSafetyManagement/client/node_modules/@truffle/contract-schema/index.js"],"sourcesContent":["var pkgVersion = require(\"./package.json\").version;\r\nvar Ajv = require(\"ajv\");\r\nvar util = require(\"util\");\r\n\r\nvar contractObjectSchema = require(\"./spec/contract-object.spec.json\");\r\nvar networkObjectSchema = require(\"./spec/network-object.spec.json\");\r\nvar abiSchema = require(\"./spec/abi.spec.json\");\r\n\r\n/**\r\n * Property definitions for Contract Objects\r\n *\r\n * Describes canonical output properties as sourced from some \"dirty\" input\r\n * object. Describes normalization process to account for deprecated and/or\r\n * nonstandard keys and values.\r\n *\r\n * Maps (key -> property) where:\r\n *  - `key` is the top-level output key matching up with those in the schema\r\n *  - `property` is an object with optional values:\r\n *      - `sources`: list of sources (see below); default `key`\r\n *      - `transform`: function(value) -> transformed value; default x -> x\r\n *\r\n * Each source represents a means to select a value from dirty object.\r\n * Allows:\r\n *  - dot-separated (`.`) string, corresponding to path to value in dirty\r\n *    object\r\n *  - function(dirtyObj) -> (cleanValue | undefined)\r\n *\r\n * The optional `transform` parameter standardizes value regardless of source,\r\n * for purposes of ensuring data type and/or string schemas.\r\n */\r\n\r\n// helper that ensures abi's do not contain function signatures\r\nconst sanitizedValue = dirtyValueArray => {\r\n  let sanitizedValueArray = [];\r\n  dirtyValueArray.forEach(item => {\r\n    let sanitizedItem = Object.assign({}, item);\r\n    delete sanitizedItem.signature;\r\n    sanitizedValueArray.push(sanitizedItem);\r\n  });\r\n  return sanitizedValueArray;\r\n};\r\n\r\n// filter `signature` property from an event\r\nconst sanitizeEvent = dirtyEvent =>\r\n  Object.entries(dirtyEvent).reduce(\r\n    (acc, [property, value]) =>\r\n      property === \"signature\"\r\n        ? acc\r\n        : Object.assign(acc, { [property]: value }),\r\n    {}\r\n  );\r\n\r\n// sanitize aggregrate events given a `network-object.spec.json#events` object\r\nconst sanitizeAllEvents = dirtyEvents =>\r\n  Object.entries(dirtyEvents).reduce(\r\n    (acc, [property, event]) =>\r\n      Object.assign(acc, { [property]: sanitizeEvent(event) }),\r\n    {}\r\n  );\r\n\r\nvar properties = {\r\n  contractName: {\r\n    sources: [\"contractName\", \"contract_name\"]\r\n  },\r\n  abi: {\r\n    sources: [\"abi\", \"interface\"],\r\n    transform: function (value) {\r\n      if (typeof value === \"string\") {\r\n        try {\r\n          value = JSON.parse(value);\r\n        } catch (_) {\r\n          value = undefined;\r\n        }\r\n      }\r\n      if (Array.isArray(value)) {\r\n        return sanitizedValue(value);\r\n      }\r\n      return value;\r\n    }\r\n  },\r\n  metadata: {\r\n    sources: [\"metadata\"]\r\n  },\r\n  bytecode: {\r\n    sources: [\"bytecode\", \"binary\", \"unlinked_binary\", \"evm.bytecode.object\"],\r\n    transform: function (value) {\r\n      if (value && value.indexOf(\"0x\") !== 0) {\r\n        value = \"0x\" + value;\r\n      }\r\n      return value;\r\n    }\r\n  },\r\n  deployedBytecode: {\r\n    sources: [\r\n      \"deployedBytecode\",\r\n      \"runtimeBytecode\",\r\n      \"evm.deployedBytecode.object\"\r\n    ],\r\n    transform: function (value) {\r\n      if (value && value.indexOf(\"0x\") !== 0) {\r\n        value = \"0x\" + value;\r\n      }\r\n      return value;\r\n    }\r\n  },\r\n  immutableReferences: {},\r\n  generatedSources: {},\r\n  deployedGeneratedSources: {},\r\n  sourceMap: {\r\n    transform: function (value) {\r\n      if (typeof value === \"string\") {\r\n        try {\r\n          return JSON.parse(value);\r\n        } catch (_) {\r\n          return value;\r\n        }\r\n      } else {\r\n        return value;\r\n      }\r\n    },\r\n    sources: [\"sourceMap\", \"srcmap\", \"evm.bytecode.sourceMap\"]\r\n  },\r\n  deployedSourceMap: {\r\n    transform: function (value) {\r\n      if (typeof value === \"string\") {\r\n        try {\r\n          return JSON.parse(value);\r\n        } catch (_) {\r\n          return value;\r\n        }\r\n      } else {\r\n        return value;\r\n      }\r\n    },\r\n    sources: [\r\n      \"deployedSourceMap\",\r\n      \"srcmapRuntime\",\r\n      \"evm.deployedBytecode.sourceMap\"\r\n    ]\r\n  },\r\n  source: {},\r\n  sourcePath: {},\r\n  ast: {},\r\n  legacyAST: {},\r\n  compiler: {},\r\n  networks: {\r\n    /**\r\n     * Normalize a networks object. Currently this makes sure `events` are\r\n     * always sanitized and `links` is extracted when copying from\r\n     * a TruffleContract context object.\r\n     *\r\n     * @param {object} value - the target object\r\n     * @param {object | TruffleContract} obj - the context, or source object.\r\n     * @return {object} The normalized Network object\r\n     */\r\n    transform: function (value = {}, obj) {\r\n      // Sanitize value's events for known networks\r\n      Object.keys(value).forEach(networkId => {\r\n        if (value[networkId].events) {\r\n          value[networkId].events = sanitizeAllEvents(value[networkId].events);\r\n        }\r\n      });\r\n\r\n      // Set and sanitize the current networks property from the\r\n      // TruffleContract. Note: obj is a TruffleContract if it has\r\n      // `network_id` attribute\r\n      const networkId = obj.network_id;\r\n      if (networkId && value.hasOwnProperty(networkId)) {\r\n        value[networkId].links = obj.links;\r\n        value[networkId].events = sanitizeAllEvents(obj.events);\r\n      }\r\n\r\n      return value;\r\n    }\r\n  },\r\n  schemaVersion: {\r\n    sources: [\"schemaVersion\", \"schema_version\"]\r\n  },\r\n  updatedAt: {\r\n    sources: [\"updatedAt\", \"updated_at\"],\r\n    transform: function (value) {\r\n      if (typeof value === \"number\") {\r\n        value = new Date(value).toISOString();\r\n      }\r\n      return value;\r\n    }\r\n  },\r\n  networkType: {},\r\n  devdoc: {},\r\n  userdoc: {},\r\n  db: {}\r\n};\r\n\r\n/**\r\n * Construct a getter for a given key, possibly applying some post-retrieve\r\n * transformation on the resulting value.\r\n *\r\n * @return {Function} Accepting dirty object and returning value || undefined\r\n */\r\nfunction getter(key, transform) {\r\n  if (transform === undefined) {\r\n    transform = function (x) {\r\n      return x;\r\n    };\r\n  }\r\n\r\n  return function (obj) {\r\n    try {\r\n      return transform(obj[key]);\r\n    } catch (_) {\r\n      return undefined;\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Chains together a series of function(obj) -> value, passing resulting\r\n * returned value to next function in chain.\r\n *\r\n * Accepts any number of functions passed as arguments\r\n * @return {Function} Accepting initial object, returning end-of-chain value\r\n *\r\n * Assumes all intermediary values to be objects, with well-formed sequence\r\n * of operations.\r\n */\r\nfunction chain() {\r\n  var getters = Array.prototype.slice.call(arguments);\r\n  return function (obj) {\r\n    return getters.reduce(function (cur, get) {\r\n      return get(cur);\r\n    }, obj);\r\n  };\r\n}\r\n\r\n// Schema module\r\n//\r\n\r\nvar TruffleContractSchema = {\r\n  // Return a promise to validate a contract object\r\n  // - Resolves as validated `contractObj`\r\n  // - Rejects with list of errors from schema validator\r\n  validate: function (contractObj) {\r\n    var ajv = new Ajv({ verbose: true });\r\n    ajv.addSchema(abiSchema);\r\n    ajv.addSchema(networkObjectSchema);\r\n    ajv.addSchema(contractObjectSchema);\r\n    if (ajv.validate(\"contract-object.spec.json\", contractObj)) {\r\n      return contractObj;\r\n    } else {\r\n      const message = `Schema validation failed. Errors:\\n\\n${ajv.errors\r\n        .map(\r\n          ({\r\n            keyword,\r\n            dataPath,\r\n            schemaPath,\r\n            params,\r\n            message,\r\n            data,\r\n            parentSchema\r\n          }) =>\r\n            util.format(\r\n              \"%s (%s):\\n%s\\n\",\r\n              message,\r\n              keyword,\r\n              util.inspect(\r\n                {\r\n                  dataPath,\r\n                  schemaPath,\r\n                  params,\r\n                  data,\r\n                  parentSchema\r\n                },\r\n                { depth: 5 }\r\n              )\r\n            )\r\n        )\r\n        .join(\"\\n\")}`;\r\n      const error = new Error(message);\r\n      error.errors = ajv.errors;\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  // accepts as argument anything that can be turned into a contract object\r\n  // returns a contract object\r\n  normalize: function (objDirty, options) {\r\n    options = options || {};\r\n    var normalized = {};\r\n\r\n    // iterate over each property\r\n    Object.keys(properties).forEach(function (key) {\r\n      var property = properties[key];\r\n      var value; // normalized value || undefined\r\n\r\n      // either used the defined sources or assume the key will only ever be\r\n      // listed as its canonical name (itself)\r\n      var sources = property.sources || [key];\r\n\r\n      // iterate over sources until value is defined or end of list met\r\n      for (var i = 0; value === undefined && i < sources.length; i++) {\r\n        var source = sources[i];\r\n        // string refers to path to value in objDirty, split and chain\r\n        // getters\r\n        if (typeof source === \"string\") {\r\n          var traversals = source.split(\".\").map(function (k) {\r\n            return getter(k);\r\n          });\r\n          source = chain.apply(null, traversals);\r\n        }\r\n\r\n        // source should be a function that takes the objDirty and returns\r\n        // value or undefined\r\n        value = source(objDirty);\r\n      }\r\n\r\n      // run source-agnostic transform on value\r\n      // (e.g. make sure bytecode begins 0x)\r\n      if (property.transform) {\r\n        value = property.transform(value, objDirty);\r\n      }\r\n\r\n      // add resulting (possibly undefined) to normalized obj\r\n      normalized[key] = value;\r\n    });\r\n\r\n    // Copy x- options\r\n    Object.keys(objDirty).forEach(function (key) {\r\n      if (key.indexOf(\"x-\") === 0) {\r\n        normalized[key] = getter(key)(objDirty);\r\n      }\r\n    });\r\n\r\n    // update schema version\r\n    normalized.schemaVersion = pkgVersion;\r\n\r\n    if (options.validate) {\r\n      this.validate(normalized);\r\n    }\r\n\r\n    return normalized;\r\n  }\r\n};\r\n\r\nmodule.exports = TruffleContractSchema;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}
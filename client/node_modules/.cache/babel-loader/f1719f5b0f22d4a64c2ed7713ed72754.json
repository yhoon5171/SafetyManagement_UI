{"ast":null,"code":"const debug = require(\"debug\")(\"contract:handlers\"); // eslint-disable-line no-unused-vars\n\n\nvar StatusError = require(\"./statuserror\");\n\nvar Utils = require(\"./utils\");\n\nvar Reason = require(\"./reason\");\n/*\r\n  Handlers for events emitted by `send` / `call` etc.\r\n */\n\n\nvar handlers = {\n  // ----------------------------------- Constants -------------------------------------------------\n  maxConfirmations: 24,\n  // Maximum number of confirmation web3 emits\n  defaultTimeoutBlocks: 50,\n  // Maximum number of blocks web3 will wait before abandoning tx\n  timeoutMessage: \"50 blocks\",\n  // Substring of web3 timeout error.\n  // -----------------------------------  Helpers --------------------------------------------------\n\n  /**\r\n   * Parses error message and determines if we should squash block timeout errors at user's request.\r\n   * @param  {Object} context execution state\r\n   * @param  {Object} error   error\r\n   * @return {Boolean}\r\n   */\n  ignoreTimeoutError: function (context, error) {\n    var timedOut = error.message && error.message.includes(handlers.timeoutMessage);\n    var shouldWait = context.contract && context.contract.timeoutBlocks && context.contract.timeoutBlocks > handlers.defaultTimeoutBlocks;\n    return timedOut && shouldWait;\n  },\n\n  /**\r\n   * Attaches Truffle specific handlers to all of the events emitted by a web3 method.\r\n   * @param {Object}       context  execution state\r\n   * @param {PromiEvent}   emitter  promiEvent returned by a web3 method call\r\n   */\n  setup: function (emitter, context) {\n    emitter.on(\"error\", handlers.error.bind(emitter, context));\n    emitter.on(\"transactionHash\", handlers.hash.bind(emitter, context));\n    emitter.on(\"confirmation\", handlers.confirmation.bind(emitter, context));\n    emitter.on(\"receipt\", handlers.receipt.bind(emitter, context));\n  },\n  // -----------------------------------  Handlers -------------------------------------------------\n\n  /**\r\n   * Error event handler. Emits error unless error is block timeout and user has\r\n   * specified we should wait longer\r\n   * @param  {Object} context   execution state\r\n   * @param  {Object} error     error\r\n   */\n  error: function (context, error) {\n    if (!handlers.ignoreTimeoutError(context, error)) {\n      context.promiEvent.eventEmitter.emit(\"error\", error);\n      this.removeListener(\"error\", handlers.error);\n    }\n  },\n\n  /**\r\n   * Transaction hash event handler. Attaches the hash to the context object\r\n   * so it can be attached to the contract instance after a deployment resolves.\r\n   * @param  {Object} context   execution state\r\n   * @param  {String} hash      transaction hash\r\n   */\n  hash: function (context, hash) {\n    context.transactionHash = hash;\n    context.promiEvent.eventEmitter.emit(\"transactionHash\", hash);\n    this.removeListener(\"transactionHash\", handlers.hash);\n  },\n  confirmation: function (context, number, receipt) {\n    context.promiEvent.eventEmitter.emit(\"confirmation\", number, receipt); // Per web3: initial confirmation index is 0\n\n    if (number === handlers.maxConfirmations + 1) {\n      this.removeListener(\"confirmation\", handlers.confirmation);\n    }\n  },\n\n  /**\r\n   * Receipt event handler. This handler decodes the event logs, re-emits the receipt,\r\n   * and (for method calls only) resolves/rejects the promiEvent with the receipt.\r\n   * @param  {Object} context   execution state\r\n   * @param  {Object} receipt   transaction receipt\r\n   */\n  receipt: async function (context, receipt) {\n    // keep around the raw (not decoded) logs in the raw logs field as a\n    // stopgap until we can get the ABI for all events, not just the current\n    // contract\n    receipt.rawLogs = receipt.logs; // Decode logs, use as receipt.logs for ease of use.\n\n    try {\n      receipt.logs = receipt.logs ? Utils.decodeLogs.call(context.contract, receipt.logs) : [];\n    } catch (error) {\n      return context.promiEvent.reject(error);\n    } // Emit receipt\n\n\n    context.promiEvent.eventEmitter.emit(\"receipt\", receipt); // .new(): Exit early. We need the promiEvent to resolve a contract instance.\n\n    if (context.onlyEmitReceipt) {\n      context.receipt = receipt;\n      return;\n    } // .method(): resolve/reject receipt in handler\n\n\n    if (receipt.status !== undefined && !receipt.status) {\n      var reason = await Reason.get(context.params, context.contract.web3);\n      var error = new StatusError(context.params, receipt.transactionHash, receipt, reason);\n      return context.promiEvent.reject(error);\n    } // This object has some duplicate data but is backward compatible.\n\n\n    context.promiEvent.resolve({\n      tx: receipt.transactionHash,\n      receipt: receipt,\n      logs: receipt.logs\n    });\n    this.removeListener(\"receipt\", handlers.receipt);\n  }\n};\nmodule.exports = handlers;","map":{"version":3,"names":["debug","require","StatusError","Utils","Reason","handlers","maxConfirmations","defaultTimeoutBlocks","timeoutMessage","ignoreTimeoutError","context","error","timedOut","message","includes","shouldWait","contract","timeoutBlocks","setup","emitter","on","bind","hash","confirmation","receipt","promiEvent","eventEmitter","emit","removeListener","transactionHash","number","rawLogs","logs","decodeLogs","call","reject","onlyEmitReceipt","status","undefined","reason","get","params","web3","resolve","tx","module","exports"],"sources":["D:/BlockchainSafetyManagement/client/node_modules/truffle-contract/lib/handlers.js"],"sourcesContent":["const debug = require(\"debug\")(\"contract:handlers\"); // eslint-disable-line no-unused-vars\r\nvar StatusError = require(\"./statuserror\");\r\nvar Utils = require(\"./utils\");\r\nvar Reason = require(\"./reason\");\r\n\r\n/*\r\n  Handlers for events emitted by `send` / `call` etc.\r\n */\r\nvar handlers = {\r\n  // ----------------------------------- Constants -------------------------------------------------\r\n\r\n  maxConfirmations: 24, // Maximum number of confirmation web3 emits\r\n  defaultTimeoutBlocks: 50, // Maximum number of blocks web3 will wait before abandoning tx\r\n  timeoutMessage: \"50 blocks\", // Substring of web3 timeout error.\r\n\r\n  // -----------------------------------  Helpers --------------------------------------------------\r\n\r\n  /**\r\n   * Parses error message and determines if we should squash block timeout errors at user's request.\r\n   * @param  {Object} context execution state\r\n   * @param  {Object} error   error\r\n   * @return {Boolean}\r\n   */\r\n  ignoreTimeoutError: function(context, error) {\r\n    var timedOut =\r\n      error.message && error.message.includes(handlers.timeoutMessage);\r\n\r\n    var shouldWait =\r\n      context.contract &&\r\n      context.contract.timeoutBlocks &&\r\n      context.contract.timeoutBlocks > handlers.defaultTimeoutBlocks;\r\n\r\n    return timedOut && shouldWait;\r\n  },\r\n\r\n  /**\r\n   * Attaches Truffle specific handlers to all of the events emitted by a web3 method.\r\n   * @param {Object}       context  execution state\r\n   * @param {PromiEvent}   emitter  promiEvent returned by a web3 method call\r\n   */\r\n  setup: function(emitter, context) {\r\n    emitter.on(\"error\", handlers.error.bind(emitter, context));\r\n    emitter.on(\"transactionHash\", handlers.hash.bind(emitter, context));\r\n    emitter.on(\"confirmation\", handlers.confirmation.bind(emitter, context));\r\n    emitter.on(\"receipt\", handlers.receipt.bind(emitter, context));\r\n  },\r\n\r\n  // -----------------------------------  Handlers -------------------------------------------------\r\n  /**\r\n   * Error event handler. Emits error unless error is block timeout and user has\r\n   * specified we should wait longer\r\n   * @param  {Object} context   execution state\r\n   * @param  {Object} error     error\r\n   */\r\n  error: function(context, error) {\r\n    if (!handlers.ignoreTimeoutError(context, error)) {\r\n      context.promiEvent.eventEmitter.emit(\"error\", error);\r\n      this.removeListener(\"error\", handlers.error);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Transaction hash event handler. Attaches the hash to the context object\r\n   * so it can be attached to the contract instance after a deployment resolves.\r\n   * @param  {Object} context   execution state\r\n   * @param  {String} hash      transaction hash\r\n   */\r\n  hash: function(context, hash) {\r\n    context.transactionHash = hash;\r\n    context.promiEvent.eventEmitter.emit(\"transactionHash\", hash);\r\n    this.removeListener(\"transactionHash\", handlers.hash);\r\n  },\r\n\r\n  confirmation: function(context, number, receipt) {\r\n    context.promiEvent.eventEmitter.emit(\"confirmation\", number, receipt);\r\n\r\n    // Per web3: initial confirmation index is 0\r\n    if (number === handlers.maxConfirmations + 1) {\r\n      this.removeListener(\"confirmation\", handlers.confirmation);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Receipt event handler. This handler decodes the event logs, re-emits the receipt,\r\n   * and (for method calls only) resolves/rejects the promiEvent with the receipt.\r\n   * @param  {Object} context   execution state\r\n   * @param  {Object} receipt   transaction receipt\r\n   */\r\n  receipt: async function(context, receipt) {\r\n    // keep around the raw (not decoded) logs in the raw logs field as a\r\n    // stopgap until we can get the ABI for all events, not just the current\r\n    // contract\r\n    receipt.rawLogs = receipt.logs;\r\n\r\n    // Decode logs, use as receipt.logs for ease of use.\r\n    try {\r\n      receipt.logs = receipt.logs\r\n        ? Utils.decodeLogs.call(context.contract, receipt.logs)\r\n        : [];\r\n    } catch (error) {\r\n      return context.promiEvent.reject(error);\r\n    }\r\n\r\n    // Emit receipt\r\n    context.promiEvent.eventEmitter.emit(\"receipt\", receipt);\r\n\r\n    // .new(): Exit early. We need the promiEvent to resolve a contract instance.\r\n    if (context.onlyEmitReceipt) {\r\n      context.receipt = receipt;\r\n      return;\r\n    }\r\n\r\n    // .method(): resolve/reject receipt in handler\r\n    if (receipt.status !== undefined && !receipt.status) {\r\n      var reason = await Reason.get(context.params, context.contract.web3);\r\n\r\n      var error = new StatusError(\r\n        context.params,\r\n        receipt.transactionHash,\r\n        receipt,\r\n        reason\r\n      );\r\n\r\n      return context.promiEvent.reject(error);\r\n    }\r\n\r\n    // This object has some duplicate data but is backward compatible.\r\n    context.promiEvent.resolve({\r\n      tx: receipt.transactionHash,\r\n      receipt: receipt,\r\n      logs: receipt.logs\r\n    });\r\n\r\n    this.removeListener(\"receipt\", handlers.receipt);\r\n  }\r\n};\r\n\r\nmodule.exports = handlers;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}
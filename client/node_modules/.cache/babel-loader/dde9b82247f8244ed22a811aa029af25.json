{"ast":null,"code":"'use strict';\n\nvar _Object$setPrototypeO;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar finished = require('./end-of-stream');\n\nvar kLastResolve = Symbol('lastResolve');\nvar kLastReject = Symbol('lastReject');\nvar kError = Symbol('error');\nvar kEnded = Symbol('ended');\nvar kLastPromise = Symbol('lastPromise');\nvar kHandlePromise = Symbol('handlePromise');\nvar kStream = Symbol('stream');\n\nfunction createIterResult(value, done) {\n  return {\n    value: value,\n    done: done\n  };\n}\n\nfunction readAndResolve(iter) {\n  var resolve = iter[kLastResolve];\n\n  if (resolve !== null) {\n    var data = iter[kStream].read(); // we defer if data is null\n    // we can be expecting either 'end' or\n    // 'error'\n\n    if (data !== null) {\n      iter[kLastPromise] = null;\n      iter[kLastResolve] = null;\n      iter[kLastReject] = null;\n      resolve(createIterResult(data, false));\n    }\n  }\n}\n\nfunction onReadable(iter) {\n  // we wait for the next tick, because it might\n  // emit an error with process.nextTick\n  process.nextTick(readAndResolve, iter);\n}\n\nfunction wrapForNext(lastPromise, iter) {\n  return function (resolve, reject) {\n    lastPromise.then(function () {\n      if (iter[kEnded]) {\n        resolve(createIterResult(undefined, true));\n        return;\n      }\n\n      iter[kHandlePromise](resolve, reject);\n    }, reject);\n  };\n}\n\nvar AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\nvar ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {\n  get stream() {\n    return this[kStream];\n  },\n\n  next: function next() {\n    var _this = this; // if we have detected an error in the meanwhile\n    // reject straight away\n\n\n    var error = this[kError];\n\n    if (error !== null) {\n      return Promise.reject(error);\n    }\n\n    if (this[kEnded]) {\n      return Promise.resolve(createIterResult(undefined, true));\n    }\n\n    if (this[kStream].destroyed) {\n      // We need to defer via nextTick because if .destroy(err) is\n      // called, the error will be emitted via nextTick, and\n      // we cannot guarantee that there is no error lingering around\n      // waiting to be emitted.\n      return new Promise(function (resolve, reject) {\n        process.nextTick(function () {\n          if (_this[kError]) {\n            reject(_this[kError]);\n          } else {\n            resolve(createIterResult(undefined, true));\n          }\n        });\n      });\n    } // if we have multiple next() calls\n    // we will wait for the previous Promise to finish\n    // this logic is optimized to support for await loops,\n    // where next() is only called once at a time\n\n\n    var lastPromise = this[kLastPromise];\n    var promise;\n\n    if (lastPromise) {\n      promise = new Promise(wrapForNext(lastPromise, this));\n    } else {\n      // fast path needed to support multiple this.push()\n      // without triggering the next() queue\n      var data = this[kStream].read();\n\n      if (data !== null) {\n        return Promise.resolve(createIterResult(data, false));\n      }\n\n      promise = new Promise(this[kHandlePromise]);\n    }\n\n    this[kLastPromise] = promise;\n    return promise;\n  }\n}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {\n  return this;\n}), _defineProperty(_Object$setPrototypeO, \"return\", function _return() {\n  var _this2 = this; // destroy(err, cb) is a private API\n  // we can guarantee we have that here, because we control the\n  // Readable class this is attached to\n\n\n  return new Promise(function (resolve, reject) {\n    _this2[kStream].destroy(null, function (err) {\n      if (err) {\n        reject(err);\n        return;\n      }\n\n      resolve(createIterResult(undefined, true));\n    });\n  });\n}), _Object$setPrototypeO), AsyncIteratorPrototype);\n\nvar createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {\n  var _Object$create;\n\n  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {\n    value: stream,\n    writable: true\n  }), _defineProperty(_Object$create, kLastResolve, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kLastReject, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kError, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kEnded, {\n    value: stream._readableState.endEmitted,\n    writable: true\n  }), _defineProperty(_Object$create, kHandlePromise, {\n    value: function value(resolve, reject) {\n      var data = iterator[kStream].read();\n\n      if (data) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        resolve(createIterResult(data, false));\n      } else {\n        iterator[kLastResolve] = resolve;\n        iterator[kLastReject] = reject;\n      }\n    },\n    writable: true\n  }), _Object$create));\n  iterator[kLastPromise] = null;\n  finished(stream, function (err) {\n    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise\n      // returned by next() and store the error\n\n      if (reject !== null) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        reject(err);\n      }\n\n      iterator[kError] = err;\n      return;\n    }\n\n    var resolve = iterator[kLastResolve];\n\n    if (resolve !== null) {\n      iterator[kLastPromise] = null;\n      iterator[kLastResolve] = null;\n      iterator[kLastReject] = null;\n      resolve(createIterResult(undefined, true));\n    }\n\n    iterator[kEnded] = true;\n  });\n  stream.on('readable', onReadable.bind(null, iterator));\n  return iterator;\n};\n\nmodule.exports = createReadableStreamAsyncIterator;","map":{"version":3,"names":["_Object$setPrototypeO","_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","finished","require","kLastResolve","Symbol","kLastReject","kError","kEnded","kLastPromise","kHandlePromise","kStream","createIterResult","done","readAndResolve","iter","resolve","data","read","onReadable","process","nextTick","wrapForNext","lastPromise","reject","then","undefined","AsyncIteratorPrototype","getPrototypeOf","ReadableStreamAsyncIteratorPrototype","setPrototypeOf","stream","next","_this","error","Promise","destroyed","promise","asyncIterator","_return","_this2","destroy","err","createReadableStreamAsyncIterator","_Object$create","iterator","create","_readableState","endEmitted","code","on","bind","module","exports"],"sources":["D:/BlockchainSafetyManagement/client/node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/async_iterator.js"],"sourcesContent":["'use strict';\r\n\r\nvar _Object$setPrototypeO;\r\n\r\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\r\n\r\nvar finished = require('./end-of-stream');\r\n\r\nvar kLastResolve = Symbol('lastResolve');\r\nvar kLastReject = Symbol('lastReject');\r\nvar kError = Symbol('error');\r\nvar kEnded = Symbol('ended');\r\nvar kLastPromise = Symbol('lastPromise');\r\nvar kHandlePromise = Symbol('handlePromise');\r\nvar kStream = Symbol('stream');\r\n\r\nfunction createIterResult(value, done) {\r\n  return {\r\n    value: value,\r\n    done: done\r\n  };\r\n}\r\n\r\nfunction readAndResolve(iter) {\r\n  var resolve = iter[kLastResolve];\r\n\r\n  if (resolve !== null) {\r\n    var data = iter[kStream].read(); // we defer if data is null\r\n    // we can be expecting either 'end' or\r\n    // 'error'\r\n\r\n    if (data !== null) {\r\n      iter[kLastPromise] = null;\r\n      iter[kLastResolve] = null;\r\n      iter[kLastReject] = null;\r\n      resolve(createIterResult(data, false));\r\n    }\r\n  }\r\n}\r\n\r\nfunction onReadable(iter) {\r\n  // we wait for the next tick, because it might\r\n  // emit an error with process.nextTick\r\n  process.nextTick(readAndResolve, iter);\r\n}\r\n\r\nfunction wrapForNext(lastPromise, iter) {\r\n  return function (resolve, reject) {\r\n    lastPromise.then(function () {\r\n      if (iter[kEnded]) {\r\n        resolve(createIterResult(undefined, true));\r\n        return;\r\n      }\r\n\r\n      iter[kHandlePromise](resolve, reject);\r\n    }, reject);\r\n  };\r\n}\r\n\r\nvar AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\r\nvar ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {\r\n  get stream() {\r\n    return this[kStream];\r\n  },\r\n\r\n  next: function next() {\r\n    var _this = this;\r\n\r\n    // if we have detected an error in the meanwhile\r\n    // reject straight away\r\n    var error = this[kError];\r\n\r\n    if (error !== null) {\r\n      return Promise.reject(error);\r\n    }\r\n\r\n    if (this[kEnded]) {\r\n      return Promise.resolve(createIterResult(undefined, true));\r\n    }\r\n\r\n    if (this[kStream].destroyed) {\r\n      // We need to defer via nextTick because if .destroy(err) is\r\n      // called, the error will be emitted via nextTick, and\r\n      // we cannot guarantee that there is no error lingering around\r\n      // waiting to be emitted.\r\n      return new Promise(function (resolve, reject) {\r\n        process.nextTick(function () {\r\n          if (_this[kError]) {\r\n            reject(_this[kError]);\r\n          } else {\r\n            resolve(createIterResult(undefined, true));\r\n          }\r\n        });\r\n      });\r\n    } // if we have multiple next() calls\r\n    // we will wait for the previous Promise to finish\r\n    // this logic is optimized to support for await loops,\r\n    // where next() is only called once at a time\r\n\r\n\r\n    var lastPromise = this[kLastPromise];\r\n    var promise;\r\n\r\n    if (lastPromise) {\r\n      promise = new Promise(wrapForNext(lastPromise, this));\r\n    } else {\r\n      // fast path needed to support multiple this.push()\r\n      // without triggering the next() queue\r\n      var data = this[kStream].read();\r\n\r\n      if (data !== null) {\r\n        return Promise.resolve(createIterResult(data, false));\r\n      }\r\n\r\n      promise = new Promise(this[kHandlePromise]);\r\n    }\r\n\r\n    this[kLastPromise] = promise;\r\n    return promise;\r\n  }\r\n}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {\r\n  return this;\r\n}), _defineProperty(_Object$setPrototypeO, \"return\", function _return() {\r\n  var _this2 = this;\r\n\r\n  // destroy(err, cb) is a private API\r\n  // we can guarantee we have that here, because we control the\r\n  // Readable class this is attached to\r\n  return new Promise(function (resolve, reject) {\r\n    _this2[kStream].destroy(null, function (err) {\r\n      if (err) {\r\n        reject(err);\r\n        return;\r\n      }\r\n\r\n      resolve(createIterResult(undefined, true));\r\n    });\r\n  });\r\n}), _Object$setPrototypeO), AsyncIteratorPrototype);\r\n\r\nvar createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {\r\n  var _Object$create;\r\n\r\n  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {\r\n    value: stream,\r\n    writable: true\r\n  }), _defineProperty(_Object$create, kLastResolve, {\r\n    value: null,\r\n    writable: true\r\n  }), _defineProperty(_Object$create, kLastReject, {\r\n    value: null,\r\n    writable: true\r\n  }), _defineProperty(_Object$create, kError, {\r\n    value: null,\r\n    writable: true\r\n  }), _defineProperty(_Object$create, kEnded, {\r\n    value: stream._readableState.endEmitted,\r\n    writable: true\r\n  }), _defineProperty(_Object$create, kHandlePromise, {\r\n    value: function value(resolve, reject) {\r\n      var data = iterator[kStream].read();\r\n\r\n      if (data) {\r\n        iterator[kLastPromise] = null;\r\n        iterator[kLastResolve] = null;\r\n        iterator[kLastReject] = null;\r\n        resolve(createIterResult(data, false));\r\n      } else {\r\n        iterator[kLastResolve] = resolve;\r\n        iterator[kLastReject] = reject;\r\n      }\r\n    },\r\n    writable: true\r\n  }), _Object$create));\r\n  iterator[kLastPromise] = null;\r\n  finished(stream, function (err) {\r\n    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\r\n      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise\r\n      // returned by next() and store the error\r\n\r\n      if (reject !== null) {\r\n        iterator[kLastPromise] = null;\r\n        iterator[kLastResolve] = null;\r\n        iterator[kLastReject] = null;\r\n        reject(err);\r\n      }\r\n\r\n      iterator[kError] = err;\r\n      return;\r\n    }\r\n\r\n    var resolve = iterator[kLastResolve];\r\n\r\n    if (resolve !== null) {\r\n      iterator[kLastPromise] = null;\r\n      iterator[kLastResolve] = null;\r\n      iterator[kLastReject] = null;\r\n      resolve(createIterResult(undefined, true));\r\n    }\r\n\r\n    iterator[kEnded] = true;\r\n  });\r\n  stream.on('readable', onReadable.bind(null, iterator));\r\n  return iterator;\r\n};\r\n\r\nmodule.exports = createReadableStreamAsyncIterator;"],"mappings":"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"},"metadata":{},"sourceType":"script"}
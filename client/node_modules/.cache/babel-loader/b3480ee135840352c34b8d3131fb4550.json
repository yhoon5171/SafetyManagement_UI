{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\n\nvar address_1 = require(\"./address\");\n\nvar bignumber_1 = require(\"./bignumber\");\n\nvar bytes_1 = require(\"./bytes\");\n\nvar utf8_1 = require(\"./utf8\");\n\nvar properties_1 = require(\"./properties\");\n\nvar errors = __importStar(require(\"./errors\"));\n\nvar paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nvar paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\nvar paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\n\nexports.defaultCoerceFunc = function (type, value) {\n  var match = type.match(paramTypeNumber);\n\n  if (match && parseInt(match[2]) <= 48) {\n    return value.toNumber();\n  }\n\n  return value;\n}; ///////////////////////////////////\n// Parsing for Solidity Signatures\n\n\nvar regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\nvar regexIdentifier = new RegExp(\"^[A-Za-z_][A-Za-z0-9_]*$\");\n\nfunction verifyType(type) {\n  // These need to be transformed to their full description\n  if (type.match(/^uint($|[^1-9])/)) {\n    type = 'uint256' + type.substring(4);\n  } else if (type.match(/^int($|[^1-9])/)) {\n    type = 'int256' + type.substring(3);\n  }\n\n  return type;\n}\n\nfunction parseParam(param, allowIndexed) {\n  function throwError(i) {\n    throw new Error('unexpected character \"' + param[i] + '\" at position ' + i + ' in \"' + param + '\"');\n  }\n\n  var parent = {\n    type: '',\n    name: '',\n    state: {\n      allowType: true\n    }\n  };\n  var node = parent;\n\n  for (var i = 0; i < param.length; i++) {\n    var c = param[i];\n\n    switch (c) {\n      case '(':\n        if (!node.state.allowParams) {\n          throwError(i);\n        }\n\n        node.state.allowType = false;\n        node.type = verifyType(node.type);\n        node.components = [{\n          type: '',\n          name: '',\n          parent: node,\n          state: {\n            allowType: true\n          }\n        }];\n        node = node.components[0];\n        break;\n\n      case ')':\n        delete node.state;\n\n        if (allowIndexed && node.name === 'indexed') {\n          node.indexed = true;\n          node.name = '';\n        }\n\n        node.type = verifyType(node.type);\n        var child = node;\n        node = node.parent;\n\n        if (!node) {\n          throwError(i);\n        }\n\n        delete child.parent;\n        node.state.allowParams = false;\n        node.state.allowName = true;\n        node.state.allowArray = true;\n        break;\n\n      case ',':\n        delete node.state;\n\n        if (allowIndexed && node.name === 'indexed') {\n          node.indexed = true;\n          node.name = '';\n        }\n\n        node.type = verifyType(node.type);\n        var sibling = {\n          type: '',\n          name: '',\n          parent: node.parent,\n          state: {\n            allowType: true\n          }\n        };\n        node.parent.components.push(sibling);\n        delete node.parent;\n        node = sibling;\n        break;\n      // Hit a space...\n\n      case ' ':\n        // If reading type, the type is done and may read a param or name\n        if (node.state.allowType) {\n          if (node.type !== '') {\n            node.type = verifyType(node.type);\n            delete node.state.allowType;\n            node.state.allowName = true;\n            node.state.allowParams = true;\n          }\n        } // If reading name, the name is done\n\n\n        if (node.state.allowName) {\n          if (node.name !== '') {\n            if (allowIndexed && node.name === 'indexed') {\n              node.indexed = true;\n              node.name = '';\n            } else {\n              node.state.allowName = false;\n            }\n          }\n        }\n\n        break;\n\n      case '[':\n        if (!node.state.allowArray) {\n          throwError(i);\n        }\n\n        node.type += c;\n        node.state.allowArray = false;\n        node.state.allowName = false;\n        node.state.readArray = true;\n        break;\n\n      case ']':\n        if (!node.state.readArray) {\n          throwError(i);\n        }\n\n        node.type += c;\n        node.state.readArray = false;\n        node.state.allowArray = true;\n        node.state.allowName = true;\n        break;\n\n      default:\n        if (node.state.allowType) {\n          node.type += c;\n          node.state.allowParams = true;\n          node.state.allowArray = true;\n        } else if (node.state.allowName) {\n          node.name += c;\n          delete node.state.allowArray;\n        } else if (node.state.readArray) {\n          node.type += c;\n        } else {\n          throwError(i);\n        }\n\n    }\n  }\n\n  if (node.parent) {\n    throw new Error(\"unexpected eof\");\n  }\n\n  delete parent.state;\n\n  if (allowIndexed && node.name === 'indexed') {\n    node.indexed = true;\n    node.name = '';\n  }\n\n  parent.type = verifyType(parent.type);\n  return parent;\n} // @TODO: Better return type\n\n\nfunction parseSignatureEvent(fragment) {\n  var abi = {\n    anonymous: false,\n    inputs: [],\n    name: '',\n    type: 'event'\n  };\n  var match = fragment.match(regexParen);\n\n  if (!match) {\n    throw new Error('invalid event: ' + fragment);\n  }\n\n  abi.name = match[1].trim();\n  splitNesting(match[2]).forEach(function (param) {\n    param = parseParam(param, true);\n    param.indexed = !!param.indexed;\n    abi.inputs.push(param);\n  });\n  match[3].split(' ').forEach(function (modifier) {\n    switch (modifier) {\n      case 'anonymous':\n        abi.anonymous = true;\n        break;\n\n      case '':\n        break;\n\n      default:\n        console.log('unknown modifier: ' + modifier);\n    }\n  });\n\n  if (abi.name && !abi.name.match(regexIdentifier)) {\n    throw new Error('invalid identifier: \"' + abi.name + '\"');\n  }\n\n  return abi;\n}\n\nfunction parseSignatureFunction(fragment) {\n  var abi = {\n    constant: false,\n    inputs: [],\n    name: '',\n    outputs: [],\n    payable: false,\n    stateMutability: null,\n    type: 'function'\n  };\n  var comps = fragment.split(' returns ');\n  var left = comps[0].match(regexParen);\n\n  if (!left) {\n    throw new Error('invalid signature');\n  }\n\n  abi.name = left[1].trim();\n\n  if (!abi.name.match(regexIdentifier)) {\n    throw new Error('invalid identifier: \"' + left[1] + '\"');\n  }\n\n  splitNesting(left[2]).forEach(function (param) {\n    abi.inputs.push(parseParam(param));\n  });\n  left[3].split(' ').forEach(function (modifier) {\n    switch (modifier) {\n      case 'constant':\n        abi.constant = true;\n        break;\n\n      case 'payable':\n        abi.payable = true;\n        break;\n\n      case 'pure':\n        abi.constant = true;\n        abi.stateMutability = 'pure';\n        break;\n\n      case 'view':\n        abi.constant = true;\n        abi.stateMutability = 'view';\n        break;\n\n      case '':\n        break;\n\n      default:\n        console.log('unknown modifier: ' + modifier);\n    }\n  }); // We have outputs\n\n  if (comps.length > 1) {\n    var right = comps[1].match(regexParen);\n\n    if (right[1].trim() != '' || right[3].trim() != '') {\n      throw new Error('unexpected tokens');\n    }\n\n    splitNesting(right[2]).forEach(function (param) {\n      abi.outputs.push(parseParam(param));\n    });\n  }\n\n  return abi;\n}\n\nfunction parseParamType(type) {\n  return parseParam(type, true);\n}\n\nexports.parseParamType = parseParamType; // @TODO: Allow a second boolean to expose names\n\nfunction formatParamType(paramType) {\n  return getParamCoder(exports.defaultCoerceFunc, paramType).type;\n}\n\nexports.formatParamType = formatParamType; // @TODO: Allow a second boolean to expose names and modifiers\n\nfunction formatSignature(fragment) {\n  return fragment.name + '(' + fragment.inputs.map(function (i) {\n    return formatParamType(i);\n  }).join(',') + ')';\n}\n\nexports.formatSignature = formatSignature;\n\nfunction parseSignature(fragment) {\n  if (typeof fragment === 'string') {\n    // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n    fragment = fragment.replace(/\\(/g, ' (').replace(/\\)/g, ') ').replace(/\\s+/g, ' ');\n    fragment = fragment.trim();\n\n    if (fragment.substring(0, 6) === 'event ') {\n      return parseSignatureEvent(fragment.substring(6).trim());\n    } else {\n      if (fragment.substring(0, 9) === 'function ') {\n        fragment = fragment.substring(9);\n      }\n\n      return parseSignatureFunction(fragment.trim());\n    }\n  }\n\n  throw new Error('unknown signature');\n}\n\nexports.parseSignature = parseSignature;\n\nvar Coder =\n/** @class */\nfunction () {\n  function Coder(coerceFunc, name, type, localName, dynamic) {\n    this.coerceFunc = coerceFunc;\n    this.name = name;\n    this.type = type;\n    this.localName = localName;\n    this.dynamic = dynamic;\n  }\n\n  return Coder;\n}(); // Clones the functionality of an existing Coder, but without a localName\n\n\nvar CoderAnonymous =\n/** @class */\nfunction (_super) {\n  __extends(CoderAnonymous, _super);\n\n  function CoderAnonymous(coder) {\n    var _this = _super.call(this, coder.coerceFunc, coder.name, coder.type, undefined, coder.dynamic) || this;\n\n    properties_1.defineReadOnly(_this, 'coder', coder);\n    return _this;\n  }\n\n  CoderAnonymous.prototype.encode = function (value) {\n    return this.coder.encode(value);\n  };\n\n  CoderAnonymous.prototype.decode = function (data, offset) {\n    return this.coder.decode(data, offset);\n  };\n\n  return CoderAnonymous;\n}(Coder);\n\nvar CoderNull =\n/** @class */\nfunction (_super) {\n  __extends(CoderNull, _super);\n\n  function CoderNull(coerceFunc, localName) {\n    return _super.call(this, coerceFunc, 'null', '', localName, false) || this;\n  }\n\n  CoderNull.prototype.encode = function (value) {\n    return bytes_1.arrayify([]);\n  };\n\n  CoderNull.prototype.decode = function (data, offset) {\n    if (offset > data.length) {\n      throw new Error('invalid null');\n    }\n\n    return {\n      consumed: 0,\n      value: this.coerceFunc('null', undefined)\n    };\n  };\n\n  return CoderNull;\n}(Coder);\n\nvar CoderNumber =\n/** @class */\nfunction (_super) {\n  __extends(CoderNumber, _super);\n\n  function CoderNumber(coerceFunc, size, signed, localName) {\n    var _this = this;\n\n    var name = (signed ? 'int' : 'uint') + size * 8;\n    _this = _super.call(this, coerceFunc, name, name, localName, false) || this;\n    _this.size = size;\n    _this.signed = signed;\n    return _this;\n  }\n\n  CoderNumber.prototype.encode = function (value) {\n    try {\n      var v = bignumber_1.bigNumberify(value);\n      v = v.toTwos(this.size * 8).maskn(this.size * 8); //value = value.toTwos(size * 8).maskn(size * 8);\n\n      if (this.signed) {\n        v = v.fromTwos(this.size * 8).toTwos(256);\n      }\n\n      return bytes_1.padZeros(bytes_1.arrayify(v), 32);\n    } catch (error) {\n      errors.throwError('invalid number value', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: this.name,\n        value: value\n      });\n    }\n\n    return null;\n  };\n\n  CoderNumber.prototype.decode = function (data, offset) {\n    if (data.length < offset + 32) {\n      errors.throwError('insufficient data for ' + this.name + ' type', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: this.name,\n        value: bytes_1.hexlify(data.slice(offset, offset + 32))\n      });\n    }\n\n    var junkLength = 32 - this.size;\n    var value = bignumber_1.bigNumberify(data.slice(offset + junkLength, offset + 32));\n\n    if (this.signed) {\n      value = value.fromTwos(this.size * 8);\n    } else {\n      value = value.maskn(this.size * 8);\n    }\n\n    return {\n      consumed: 32,\n      value: this.coerceFunc(this.name, value)\n    };\n  };\n\n  return CoderNumber;\n}(Coder);\n\nvar uint256Coder = new CoderNumber(function (type, value) {\n  return value;\n}, 32, false, 'none');\n\nvar CoderBoolean =\n/** @class */\nfunction (_super) {\n  __extends(CoderBoolean, _super);\n\n  function CoderBoolean(coerceFunc, localName) {\n    return _super.call(this, coerceFunc, 'bool', 'bool', localName, false) || this;\n  }\n\n  CoderBoolean.prototype.encode = function (value) {\n    return uint256Coder.encode(!!value ? 1 : 0);\n  };\n\n  CoderBoolean.prototype.decode = function (data, offset) {\n    try {\n      var result = uint256Coder.decode(data, offset);\n    } catch (error) {\n      if (error.reason === 'insufficient data for uint256 type') {\n        errors.throwError('insufficient data for boolean type', errors.INVALID_ARGUMENT, {\n          arg: this.localName,\n          coderType: 'boolean',\n          value: error.value\n        });\n      }\n\n      throw error;\n    }\n\n    return {\n      consumed: result.consumed,\n      value: this.coerceFunc('bool', !result.value.isZero())\n    };\n  };\n\n  return CoderBoolean;\n}(Coder);\n\nvar CoderFixedBytes =\n/** @class */\nfunction (_super) {\n  __extends(CoderFixedBytes, _super);\n\n  function CoderFixedBytes(coerceFunc, length, localName) {\n    var _this = this;\n\n    var name = 'bytes' + length;\n    _this = _super.call(this, coerceFunc, name, name, localName, false) || this;\n    _this.length = length;\n    return _this;\n  }\n\n  CoderFixedBytes.prototype.encode = function (value) {\n    var result = new Uint8Array(32);\n\n    try {\n      var data = bytes_1.arrayify(value);\n\n      if (data.length > 32) {\n        throw new Error();\n      }\n\n      result.set(data);\n    } catch (error) {\n      errors.throwError('invalid ' + this.name + ' value', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: this.name,\n        value: error.value || value\n      });\n    }\n\n    return result;\n  };\n\n  CoderFixedBytes.prototype.decode = function (data, offset) {\n    if (data.length < offset + 32) {\n      errors.throwError('insufficient data for ' + name + ' type', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: this.name,\n        value: bytes_1.hexlify(data.slice(offset, offset + 32))\n      });\n    }\n\n    return {\n      consumed: 32,\n      value: this.coerceFunc(this.name, bytes_1.hexlify(data.slice(offset, offset + this.length)))\n    };\n  };\n\n  return CoderFixedBytes;\n}(Coder);\n\nvar CoderAddress =\n/** @class */\nfunction (_super) {\n  __extends(CoderAddress, _super);\n\n  function CoderAddress(coerceFunc, localName) {\n    return _super.call(this, coerceFunc, 'address', 'address', localName, false) || this;\n  }\n\n  CoderAddress.prototype.encode = function (value) {\n    var result = new Uint8Array(32);\n\n    try {\n      result.set(bytes_1.arrayify(address_1.getAddress(value)), 12);\n    } catch (error) {\n      errors.throwError('invalid address', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'address',\n        value: value\n      });\n    }\n\n    return result;\n  };\n\n  CoderAddress.prototype.decode = function (data, offset) {\n    if (data.length < offset + 32) {\n      errors.throwError('insufficuent data for address type', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'address',\n        value: bytes_1.hexlify(data.slice(offset, offset + 32))\n      });\n    }\n\n    return {\n      consumed: 32,\n      value: this.coerceFunc('address', address_1.getAddress(bytes_1.hexlify(data.slice(offset + 12, offset + 32))))\n    };\n  };\n\n  return CoderAddress;\n}(Coder);\n\nfunction _encodeDynamicBytes(value) {\n  var dataLength = 32 * Math.ceil(value.length / 32);\n  var padding = new Uint8Array(dataLength - value.length);\n  return bytes_1.concat([uint256Coder.encode(value.length), value, padding]);\n}\n\nfunction _decodeDynamicBytes(data, offset, localName) {\n  if (data.length < offset + 32) {\n    errors.throwError('insufficient data for dynamicBytes length', errors.INVALID_ARGUMENT, {\n      arg: localName,\n      coderType: 'dynamicBytes',\n      value: bytes_1.hexlify(data.slice(offset, offset + 32))\n    });\n  }\n\n  var length = uint256Coder.decode(data, offset).value;\n\n  try {\n    length = length.toNumber();\n  } catch (error) {\n    errors.throwError('dynamic bytes count too large', errors.INVALID_ARGUMENT, {\n      arg: localName,\n      coderType: 'dynamicBytes',\n      value: length.toString()\n    });\n  }\n\n  if (data.length < offset + 32 + length) {\n    errors.throwError('insufficient data for dynamicBytes type', errors.INVALID_ARGUMENT, {\n      arg: localName,\n      coderType: 'dynamicBytes',\n      value: bytes_1.hexlify(data.slice(offset, offset + 32 + length))\n    });\n  }\n\n  return {\n    consumed: 32 + 32 * Math.ceil(length / 32),\n    value: data.slice(offset + 32, offset + 32 + length)\n  };\n}\n\nvar CoderDynamicBytes =\n/** @class */\nfunction (_super) {\n  __extends(CoderDynamicBytes, _super);\n\n  function CoderDynamicBytes(coerceFunc, localName) {\n    return _super.call(this, coerceFunc, 'bytes', 'bytes', localName, true) || this;\n  }\n\n  CoderDynamicBytes.prototype.encode = function (value) {\n    try {\n      return _encodeDynamicBytes(bytes_1.arrayify(value));\n    } catch (error) {\n      errors.throwError('invalid bytes value', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'bytes',\n        value: error.value\n      });\n    }\n\n    return null;\n  };\n\n  CoderDynamicBytes.prototype.decode = function (data, offset) {\n    var result = _decodeDynamicBytes(data, offset, this.localName);\n\n    result.value = this.coerceFunc('bytes', bytes_1.hexlify(result.value));\n    return result;\n  };\n\n  return CoderDynamicBytes;\n}(Coder);\n\nvar CoderString =\n/** @class */\nfunction (_super) {\n  __extends(CoderString, _super);\n\n  function CoderString(coerceFunc, localName) {\n    return _super.call(this, coerceFunc, 'string', 'string', localName, true) || this;\n  }\n\n  CoderString.prototype.encode = function (value) {\n    if (typeof value !== 'string') {\n      errors.throwError('invalid string value', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'string',\n        value: value\n      });\n    }\n\n    return _encodeDynamicBytes(utf8_1.toUtf8Bytes(value));\n  };\n\n  CoderString.prototype.decode = function (data, offset) {\n    var result = _decodeDynamicBytes(data, offset, this.localName);\n\n    result.value = this.coerceFunc('string', utf8_1.toUtf8String(result.value));\n    return result;\n  };\n\n  return CoderString;\n}(Coder);\n\nfunction alignSize(size) {\n  return 32 * Math.ceil(size / 32);\n}\n\nfunction pack(coders, values) {\n  if (Array.isArray(values)) {// do nothing\n  } else if (values && typeof values === 'object') {\n    var arrayValues = [];\n    coders.forEach(function (coder) {\n      arrayValues.push(values[coder.localName]);\n    });\n    values = arrayValues;\n  } else {\n    errors.throwError('invalid tuple value', errors.INVALID_ARGUMENT, {\n      coderType: 'tuple',\n      value: values\n    });\n  }\n\n  if (coders.length !== values.length) {\n    errors.throwError('types/value length mismatch', errors.INVALID_ARGUMENT, {\n      coderType: 'tuple',\n      value: values\n    });\n  }\n\n  var parts = [];\n  coders.forEach(function (coder, index) {\n    parts.push({\n      dynamic: coder.dynamic,\n      value: coder.encode(values[index])\n    });\n  });\n  var staticSize = 0,\n      dynamicSize = 0;\n  parts.forEach(function (part) {\n    if (part.dynamic) {\n      staticSize += 32;\n      dynamicSize += alignSize(part.value.length);\n    } else {\n      staticSize += alignSize(part.value.length);\n    }\n  });\n  var offset = 0,\n      dynamicOffset = staticSize;\n  var data = new Uint8Array(staticSize + dynamicSize);\n  parts.forEach(function (part) {\n    if (part.dynamic) {\n      //uint256Coder.encode(dynamicOffset).copy(data, offset);\n      data.set(uint256Coder.encode(dynamicOffset), offset);\n      offset += 32; //part.value.copy(data, dynamicOffset);  @TODO\n\n      data.set(part.value, dynamicOffset);\n      dynamicOffset += alignSize(part.value.length);\n    } else {\n      //part.value.copy(data, offset);  @TODO\n      data.set(part.value, offset);\n      offset += alignSize(part.value.length);\n    }\n  });\n  return data;\n}\n\nfunction unpack(coders, data, offset) {\n  var baseOffset = offset;\n  var consumed = 0;\n  var value = [];\n  coders.forEach(function (coder) {\n    if (coder.dynamic) {\n      var dynamicOffset = uint256Coder.decode(data, offset);\n      var result = coder.decode(data, baseOffset + dynamicOffset.value.toNumber()); // The dynamic part is leap-frogged somewhere else; doesn't count towards size\n\n      result.consumed = dynamicOffset.consumed;\n    } else {\n      var result = coder.decode(data, offset);\n    }\n\n    if (result.value != undefined) {\n      value.push(result.value);\n    }\n\n    offset += result.consumed;\n    consumed += result.consumed;\n  });\n  coders.forEach(function (coder, index) {\n    var name = coder.localName;\n\n    if (!name) {\n      return;\n    }\n\n    if (name === 'length') {\n      name = '_length';\n    }\n\n    if (value[name] != null) {\n      return;\n    }\n\n    value[name] = value[index];\n  });\n  return {\n    value: value,\n    consumed: consumed\n  };\n}\n\nvar CoderArray =\n/** @class */\nfunction (_super) {\n  __extends(CoderArray, _super);\n\n  function CoderArray(coerceFunc, coder, length, localName) {\n    var _this = this;\n\n    var type = coder.type + '[' + (length >= 0 ? length : '') + ']';\n    var dynamic = length === -1 || coder.dynamic;\n    _this = _super.call(this, coerceFunc, 'array', type, localName, dynamic) || this;\n    _this.coder = coder;\n    _this.length = length;\n    return _this;\n  }\n\n  CoderArray.prototype.encode = function (value) {\n    if (!Array.isArray(value)) {\n      errors.throwError('expected array value', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'array',\n        value: value\n      });\n    }\n\n    var count = this.length;\n    var result = new Uint8Array(0);\n\n    if (count === -1) {\n      count = value.length;\n      result = uint256Coder.encode(count);\n    }\n\n    errors.checkArgumentCount(count, value.length, 'in coder array' + (this.localName ? \" \" + this.localName : \"\"));\n    var coders = [];\n\n    for (var i = 0; i < value.length; i++) {\n      coders.push(this.coder);\n    }\n\n    return bytes_1.concat([result, pack(coders, value)]);\n  };\n\n  CoderArray.prototype.decode = function (data, offset) {\n    // @TODO:\n    //if (data.length < offset + length * 32) { throw new Error('invalid array'); }\n    var consumed = 0;\n    var count = this.length;\n\n    if (count === -1) {\n      try {\n        var decodedLength = uint256Coder.decode(data, offset);\n      } catch (error) {\n        errors.throwError('insufficient data for dynamic array length', errors.INVALID_ARGUMENT, {\n          arg: this.localName,\n          coderType: 'array',\n          value: error.value\n        });\n      }\n\n      try {\n        count = decodedLength.value.toNumber();\n      } catch (error) {\n        errors.throwError('array count too large', errors.INVALID_ARGUMENT, {\n          arg: this.localName,\n          coderType: 'array',\n          value: decodedLength.value.toString()\n        });\n      }\n\n      consumed += decodedLength.consumed;\n      offset += decodedLength.consumed;\n    }\n\n    var coders = [];\n\n    for (var i = 0; i < count; i++) {\n      coders.push(new CoderAnonymous(this.coder));\n    }\n\n    var result = unpack(coders, data, offset);\n    result.consumed += consumed;\n    result.value = this.coerceFunc(this.type, result.value);\n    return result;\n  };\n\n  return CoderArray;\n}(Coder);\n\nvar CoderTuple =\n/** @class */\nfunction (_super) {\n  __extends(CoderTuple, _super);\n\n  function CoderTuple(coerceFunc, coders, localName) {\n    var _this = this;\n\n    var dynamic = false;\n    var types = [];\n    coders.forEach(function (coder) {\n      if (coder.dynamic) {\n        dynamic = true;\n      }\n\n      types.push(coder.type);\n    });\n    var type = 'tuple(' + types.join(',') + ')';\n    _this = _super.call(this, coerceFunc, 'tuple', type, localName, dynamic) || this;\n    _this.coders = coders;\n    return _this;\n  }\n\n  CoderTuple.prototype.encode = function (value) {\n    return pack(this.coders, value);\n  };\n\n  CoderTuple.prototype.decode = function (data, offset) {\n    var result = unpack(this.coders, data, offset);\n    result.value = this.coerceFunc(this.type, result.value);\n    return result;\n  };\n\n  return CoderTuple;\n}(Coder);\n/*\r\nfunction getTypes(coders) {\r\n    var type = coderTuple(coders).type;\r\n    return type.substring(6, type.length - 1);\r\n}\r\n*/\n\n\nfunction splitNesting(value) {\n  var result = [];\n  var accum = '';\n  var depth = 0;\n\n  for (var offset = 0; offset < value.length; offset++) {\n    var c = value[offset];\n\n    if (c === ',' && depth === 0) {\n      result.push(accum);\n      accum = '';\n    } else {\n      accum += c;\n\n      if (c === '(') {\n        depth++;\n      } else if (c === ')') {\n        depth--;\n\n        if (depth === -1) {\n          throw new Error('unbalanced parenthsis');\n        }\n      }\n    }\n  }\n\n  result.push(accum);\n  return result;\n} // @TODO: Is there a way to return \"class\"?\n\n\nvar paramTypeSimple = {\n  address: CoderAddress,\n  bool: CoderBoolean,\n  string: CoderString,\n  bytes: CoderDynamicBytes\n};\n\nfunction getTupleParamCoder(coerceFunc, components, localName) {\n  if (!components) {\n    components = [];\n  }\n\n  var coders = [];\n  components.forEach(function (component) {\n    coders.push(getParamCoder(coerceFunc, component));\n  });\n  return new CoderTuple(coerceFunc, coders, localName);\n}\n\nfunction getParamCoder(coerceFunc, param) {\n  var coder = paramTypeSimple[param.type];\n\n  if (coder) {\n    return new coder(coerceFunc, param.name);\n  }\n\n  var match = param.type.match(paramTypeNumber);\n\n  if (match) {\n    var size = parseInt(match[2] || \"256\");\n\n    if (size === 0 || size > 256 || size % 8 !== 0) {\n      errors.throwError('invalid ' + match[1] + ' bit length', errors.INVALID_ARGUMENT, {\n        arg: 'param',\n        value: param\n      });\n    }\n\n    return new CoderNumber(coerceFunc, size / 8, match[1] === 'int', param.name);\n  }\n\n  var match = param.type.match(paramTypeBytes);\n\n  if (match) {\n    var size = parseInt(match[1]);\n\n    if (size === 0 || size > 32) {\n      errors.throwError('invalid bytes length', errors.INVALID_ARGUMENT, {\n        arg: 'param',\n        value: param\n      });\n    }\n\n    return new CoderFixedBytes(coerceFunc, size, param.name);\n  }\n\n  var match = param.type.match(paramTypeArray);\n\n  if (match) {\n    var size = parseInt(match[2] || \"-1\");\n    param = properties_1.jsonCopy(param);\n    param.type = match[1];\n    return new CoderArray(coerceFunc, getParamCoder(coerceFunc, param), size, param.name);\n  }\n\n  if (param.type.substring(0, 5) === 'tuple') {\n    return getTupleParamCoder(coerceFunc, param.components, param.name);\n  }\n\n  if (param.type === '') {\n    return new CoderNull(coerceFunc, param.name);\n  }\n\n  errors.throwError('invalid type', errors.INVALID_ARGUMENT, {\n    arg: 'type',\n    value: param.type\n  });\n  return null;\n}\n\nvar AbiCoder =\n/** @class */\nfunction () {\n  function AbiCoder(coerceFunc) {\n    errors.checkNew(this, AbiCoder);\n\n    if (!coerceFunc) {\n      coerceFunc = exports.defaultCoerceFunc;\n    }\n\n    properties_1.defineReadOnly(this, 'coerceFunc', coerceFunc);\n  }\n\n  AbiCoder.prototype.encode = function (types, values) {\n    if (types.length !== values.length) {\n      errors.throwError('types/values length mismatch', errors.INVALID_ARGUMENT, {\n        count: {\n          types: types.length,\n          values: values.length\n        },\n        value: {\n          types: types,\n          values: values\n        }\n      });\n    }\n\n    var coders = [];\n    types.forEach(function (type) {\n      // Convert types to type objects\n      //   - \"uint foo\" => { type: \"uint\", name: \"foo\" }\n      //   - \"tuple(uint, uint)\" => { type: \"tuple\", components: [ { type: \"uint\" }, { type: \"uint\" }, ] }\n      var typeObject = null;\n\n      if (typeof type === 'string') {\n        typeObject = parseParam(type);\n      } else {\n        typeObject = type;\n      }\n\n      coders.push(getParamCoder(this.coerceFunc, typeObject));\n    }, this);\n    return bytes_1.hexlify(new CoderTuple(this.coerceFunc, coders, '_').encode(values));\n  };\n\n  AbiCoder.prototype.decode = function (types, data) {\n    var coders = [];\n    types.forEach(function (type) {\n      // See encode for details\n      var typeObject = null;\n\n      if (typeof type === 'string') {\n        typeObject = parseParam(type);\n      } else {\n        typeObject = properties_1.jsonCopy(type);\n      }\n\n      coders.push(getParamCoder(this.coerceFunc, typeObject));\n    }, this);\n    return new CoderTuple(this.coerceFunc, coders, '_').decode(bytes_1.arrayify(data), 0).value;\n  };\n\n  return AbiCoder;\n}();\n\nexports.AbiCoder = AbiCoder;\nexports.defaultAbiCoder = new AbiCoder();","map":{"version":3,"names":["__extends","extendStatics","Object","setPrototypeOf","__proto__","Array","d","b","p","hasOwnProperty","__","constructor","prototype","create","__importStar","mod","__esModule","result","k","call","defineProperty","exports","value","address_1","require","bignumber_1","bytes_1","utf8_1","properties_1","errors","paramTypeBytes","RegExp","paramTypeNumber","paramTypeArray","defaultCoerceFunc","type","match","parseInt","toNumber","regexParen","regexIdentifier","verifyType","substring","parseParam","param","allowIndexed","throwError","i","Error","parent","name","state","allowType","node","length","c","allowParams","components","indexed","child","allowName","allowArray","sibling","push","readArray","parseSignatureEvent","fragment","abi","anonymous","inputs","trim","splitNesting","forEach","split","modifier","console","log","parseSignatureFunction","constant","outputs","payable","stateMutability","comps","left","right","parseParamType","formatParamType","paramType","getParamCoder","formatSignature","map","join","parseSignature","replace","Coder","coerceFunc","localName","dynamic","CoderAnonymous","_super","coder","_this","undefined","defineReadOnly","encode","decode","data","offset","CoderNull","arrayify","consumed","CoderNumber","size","signed","v","bigNumberify","toTwos","maskn","fromTwos","padZeros","error","INVALID_ARGUMENT","arg","coderType","hexlify","slice","junkLength","uint256Coder","CoderBoolean","reason","isZero","CoderFixedBytes","Uint8Array","set","CoderAddress","getAddress","_encodeDynamicBytes","dataLength","Math","ceil","padding","concat","_decodeDynamicBytes","toString","CoderDynamicBytes","CoderString","toUtf8Bytes","toUtf8String","alignSize","pack","coders","values","isArray","arrayValues","parts","index","staticSize","dynamicSize","part","dynamicOffset","unpack","baseOffset","CoderArray","count","checkArgumentCount","decodedLength","CoderTuple","types","accum","depth","paramTypeSimple","address","bool","string","bytes","getTupleParamCoder","component","jsonCopy","AbiCoder","checkNew","typeObject","defaultAbiCoder"],"sources":["C:/Users/mcnl/Desktop/gong/BlockchainSafetyManagement/client/node_modules/truffle-contract/node_modules/ethers/utils/abi-coder.js"],"sourcesContent":["'use strict';\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\r\nvar address_1 = require(\"./address\");\r\nvar bignumber_1 = require(\"./bignumber\");\r\nvar bytes_1 = require(\"./bytes\");\r\nvar utf8_1 = require(\"./utf8\");\r\nvar properties_1 = require(\"./properties\");\r\nvar errors = __importStar(require(\"./errors\"));\r\nvar paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\r\nvar paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\r\nvar paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\r\nexports.defaultCoerceFunc = function (type, value) {\r\n    var match = type.match(paramTypeNumber);\r\n    if (match && parseInt(match[2]) <= 48) {\r\n        return value.toNumber();\r\n    }\r\n    return value;\r\n};\r\n///////////////////////////////////\r\n// Parsing for Solidity Signatures\r\nvar regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\r\nvar regexIdentifier = new RegExp(\"^[A-Za-z_][A-Za-z0-9_]*$\");\r\nfunction verifyType(type) {\r\n    // These need to be transformed to their full description\r\n    if (type.match(/^uint($|[^1-9])/)) {\r\n        type = 'uint256' + type.substring(4);\r\n    }\r\n    else if (type.match(/^int($|[^1-9])/)) {\r\n        type = 'int256' + type.substring(3);\r\n    }\r\n    return type;\r\n}\r\nfunction parseParam(param, allowIndexed) {\r\n    function throwError(i) {\r\n        throw new Error('unexpected character \"' + param[i] + '\" at position ' + i + ' in \"' + param + '\"');\r\n    }\r\n    var parent = { type: '', name: '', state: { allowType: true } };\r\n    var node = parent;\r\n    for (var i = 0; i < param.length; i++) {\r\n        var c = param[i];\r\n        switch (c) {\r\n            case '(':\r\n                if (!node.state.allowParams) {\r\n                    throwError(i);\r\n                }\r\n                node.state.allowType = false;\r\n                node.type = verifyType(node.type);\r\n                node.components = [{ type: '', name: '', parent: node, state: { allowType: true } }];\r\n                node = node.components[0];\r\n                break;\r\n            case ')':\r\n                delete node.state;\r\n                if (allowIndexed && node.name === 'indexed') {\r\n                    node.indexed = true;\r\n                    node.name = '';\r\n                }\r\n                node.type = verifyType(node.type);\r\n                var child = node;\r\n                node = node.parent;\r\n                if (!node) {\r\n                    throwError(i);\r\n                }\r\n                delete child.parent;\r\n                node.state.allowParams = false;\r\n                node.state.allowName = true;\r\n                node.state.allowArray = true;\r\n                break;\r\n            case ',':\r\n                delete node.state;\r\n                if (allowIndexed && node.name === 'indexed') {\r\n                    node.indexed = true;\r\n                    node.name = '';\r\n                }\r\n                node.type = verifyType(node.type);\r\n                var sibling = { type: '', name: '', parent: node.parent, state: { allowType: true } };\r\n                node.parent.components.push(sibling);\r\n                delete node.parent;\r\n                node = sibling;\r\n                break;\r\n            // Hit a space...\r\n            case ' ':\r\n                // If reading type, the type is done and may read a param or name\r\n                if (node.state.allowType) {\r\n                    if (node.type !== '') {\r\n                        node.type = verifyType(node.type);\r\n                        delete node.state.allowType;\r\n                        node.state.allowName = true;\r\n                        node.state.allowParams = true;\r\n                    }\r\n                }\r\n                // If reading name, the name is done\r\n                if (node.state.allowName) {\r\n                    if (node.name !== '') {\r\n                        if (allowIndexed && node.name === 'indexed') {\r\n                            node.indexed = true;\r\n                            node.name = '';\r\n                        }\r\n                        else {\r\n                            node.state.allowName = false;\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n            case '[':\r\n                if (!node.state.allowArray) {\r\n                    throwError(i);\r\n                }\r\n                node.type += c;\r\n                node.state.allowArray = false;\r\n                node.state.allowName = false;\r\n                node.state.readArray = true;\r\n                break;\r\n            case ']':\r\n                if (!node.state.readArray) {\r\n                    throwError(i);\r\n                }\r\n                node.type += c;\r\n                node.state.readArray = false;\r\n                node.state.allowArray = true;\r\n                node.state.allowName = true;\r\n                break;\r\n            default:\r\n                if (node.state.allowType) {\r\n                    node.type += c;\r\n                    node.state.allowParams = true;\r\n                    node.state.allowArray = true;\r\n                }\r\n                else if (node.state.allowName) {\r\n                    node.name += c;\r\n                    delete node.state.allowArray;\r\n                }\r\n                else if (node.state.readArray) {\r\n                    node.type += c;\r\n                }\r\n                else {\r\n                    throwError(i);\r\n                }\r\n        }\r\n    }\r\n    if (node.parent) {\r\n        throw new Error(\"unexpected eof\");\r\n    }\r\n    delete parent.state;\r\n    if (allowIndexed && node.name === 'indexed') {\r\n        node.indexed = true;\r\n        node.name = '';\r\n    }\r\n    parent.type = verifyType(parent.type);\r\n    return parent;\r\n}\r\n// @TODO: Better return type\r\nfunction parseSignatureEvent(fragment) {\r\n    var abi = {\r\n        anonymous: false,\r\n        inputs: [],\r\n        name: '',\r\n        type: 'event'\r\n    };\r\n    var match = fragment.match(regexParen);\r\n    if (!match) {\r\n        throw new Error('invalid event: ' + fragment);\r\n    }\r\n    abi.name = match[1].trim();\r\n    splitNesting(match[2]).forEach(function (param) {\r\n        param = parseParam(param, true);\r\n        param.indexed = !!param.indexed;\r\n        abi.inputs.push(param);\r\n    });\r\n    match[3].split(' ').forEach(function (modifier) {\r\n        switch (modifier) {\r\n            case 'anonymous':\r\n                abi.anonymous = true;\r\n                break;\r\n            case '':\r\n                break;\r\n            default:\r\n                console.log('unknown modifier: ' + modifier);\r\n        }\r\n    });\r\n    if (abi.name && !abi.name.match(regexIdentifier)) {\r\n        throw new Error('invalid identifier: \"' + abi.name + '\"');\r\n    }\r\n    return abi;\r\n}\r\nfunction parseSignatureFunction(fragment) {\r\n    var abi = {\r\n        constant: false,\r\n        inputs: [],\r\n        name: '',\r\n        outputs: [],\r\n        payable: false,\r\n        stateMutability: null,\r\n        type: 'function'\r\n    };\r\n    var comps = fragment.split(' returns ');\r\n    var left = comps[0].match(regexParen);\r\n    if (!left) {\r\n        throw new Error('invalid signature');\r\n    }\r\n    abi.name = left[1].trim();\r\n    if (!abi.name.match(regexIdentifier)) {\r\n        throw new Error('invalid identifier: \"' + left[1] + '\"');\r\n    }\r\n    splitNesting(left[2]).forEach(function (param) {\r\n        abi.inputs.push(parseParam(param));\r\n    });\r\n    left[3].split(' ').forEach(function (modifier) {\r\n        switch (modifier) {\r\n            case 'constant':\r\n                abi.constant = true;\r\n                break;\r\n            case 'payable':\r\n                abi.payable = true;\r\n                break;\r\n            case 'pure':\r\n                abi.constant = true;\r\n                abi.stateMutability = 'pure';\r\n                break;\r\n            case 'view':\r\n                abi.constant = true;\r\n                abi.stateMutability = 'view';\r\n                break;\r\n            case '':\r\n                break;\r\n            default:\r\n                console.log('unknown modifier: ' + modifier);\r\n        }\r\n    });\r\n    // We have outputs\r\n    if (comps.length > 1) {\r\n        var right = comps[1].match(regexParen);\r\n        if (right[1].trim() != '' || right[3].trim() != '') {\r\n            throw new Error('unexpected tokens');\r\n        }\r\n        splitNesting(right[2]).forEach(function (param) {\r\n            abi.outputs.push(parseParam(param));\r\n        });\r\n    }\r\n    return abi;\r\n}\r\nfunction parseParamType(type) {\r\n    return parseParam(type, true);\r\n}\r\nexports.parseParamType = parseParamType;\r\n// @TODO: Allow a second boolean to expose names\r\nfunction formatParamType(paramType) {\r\n    return getParamCoder(exports.defaultCoerceFunc, paramType).type;\r\n}\r\nexports.formatParamType = formatParamType;\r\n// @TODO: Allow a second boolean to expose names and modifiers\r\nfunction formatSignature(fragment) {\r\n    return fragment.name + '(' + fragment.inputs.map(function (i) { return formatParamType(i); }).join(',') + ')';\r\n}\r\nexports.formatSignature = formatSignature;\r\nfunction parseSignature(fragment) {\r\n    if (typeof (fragment) === 'string') {\r\n        // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\r\n        fragment = fragment.replace(/\\(/g, ' (').replace(/\\)/g, ') ').replace(/\\s+/g, ' ');\r\n        fragment = fragment.trim();\r\n        if (fragment.substring(0, 6) === 'event ') {\r\n            return parseSignatureEvent(fragment.substring(6).trim());\r\n        }\r\n        else {\r\n            if (fragment.substring(0, 9) === 'function ') {\r\n                fragment = fragment.substring(9);\r\n            }\r\n            return parseSignatureFunction(fragment.trim());\r\n        }\r\n    }\r\n    throw new Error('unknown signature');\r\n}\r\nexports.parseSignature = parseSignature;\r\nvar Coder = /** @class */ (function () {\r\n    function Coder(coerceFunc, name, type, localName, dynamic) {\r\n        this.coerceFunc = coerceFunc;\r\n        this.name = name;\r\n        this.type = type;\r\n        this.localName = localName;\r\n        this.dynamic = dynamic;\r\n    }\r\n    return Coder;\r\n}());\r\n// Clones the functionality of an existing Coder, but without a localName\r\nvar CoderAnonymous = /** @class */ (function (_super) {\r\n    __extends(CoderAnonymous, _super);\r\n    function CoderAnonymous(coder) {\r\n        var _this = _super.call(this, coder.coerceFunc, coder.name, coder.type, undefined, coder.dynamic) || this;\r\n        properties_1.defineReadOnly(_this, 'coder', coder);\r\n        return _this;\r\n    }\r\n    CoderAnonymous.prototype.encode = function (value) { return this.coder.encode(value); };\r\n    CoderAnonymous.prototype.decode = function (data, offset) { return this.coder.decode(data, offset); };\r\n    return CoderAnonymous;\r\n}(Coder));\r\nvar CoderNull = /** @class */ (function (_super) {\r\n    __extends(CoderNull, _super);\r\n    function CoderNull(coerceFunc, localName) {\r\n        return _super.call(this, coerceFunc, 'null', '', localName, false) || this;\r\n    }\r\n    CoderNull.prototype.encode = function (value) {\r\n        return bytes_1.arrayify([]);\r\n    };\r\n    CoderNull.prototype.decode = function (data, offset) {\r\n        if (offset > data.length) {\r\n            throw new Error('invalid null');\r\n        }\r\n        return {\r\n            consumed: 0,\r\n            value: this.coerceFunc('null', undefined)\r\n        };\r\n    };\r\n    return CoderNull;\r\n}(Coder));\r\nvar CoderNumber = /** @class */ (function (_super) {\r\n    __extends(CoderNumber, _super);\r\n    function CoderNumber(coerceFunc, size, signed, localName) {\r\n        var _this = this;\r\n        var name = ((signed ? 'int' : 'uint') + (size * 8));\r\n        _this = _super.call(this, coerceFunc, name, name, localName, false) || this;\r\n        _this.size = size;\r\n        _this.signed = signed;\r\n        return _this;\r\n    }\r\n    CoderNumber.prototype.encode = function (value) {\r\n        try {\r\n            var v = bignumber_1.bigNumberify(value);\r\n            v = v.toTwos(this.size * 8).maskn(this.size * 8);\r\n            //value = value.toTwos(size * 8).maskn(size * 8);\r\n            if (this.signed) {\r\n                v = v.fromTwos(this.size * 8).toTwos(256);\r\n            }\r\n            return bytes_1.padZeros(bytes_1.arrayify(v), 32);\r\n        }\r\n        catch (error) {\r\n            errors.throwError('invalid number value', errors.INVALID_ARGUMENT, {\r\n                arg: this.localName,\r\n                coderType: this.name,\r\n                value: value\r\n            });\r\n        }\r\n        return null;\r\n    };\r\n    CoderNumber.prototype.decode = function (data, offset) {\r\n        if (data.length < offset + 32) {\r\n            errors.throwError('insufficient data for ' + this.name + ' type', errors.INVALID_ARGUMENT, {\r\n                arg: this.localName,\r\n                coderType: this.name,\r\n                value: bytes_1.hexlify(data.slice(offset, offset + 32))\r\n            });\r\n        }\r\n        var junkLength = 32 - this.size;\r\n        var value = bignumber_1.bigNumberify(data.slice(offset + junkLength, offset + 32));\r\n        if (this.signed) {\r\n            value = value.fromTwos(this.size * 8);\r\n        }\r\n        else {\r\n            value = value.maskn(this.size * 8);\r\n        }\r\n        return {\r\n            consumed: 32,\r\n            value: this.coerceFunc(this.name, value),\r\n        };\r\n    };\r\n    return CoderNumber;\r\n}(Coder));\r\nvar uint256Coder = new CoderNumber(function (type, value) { return value; }, 32, false, 'none');\r\nvar CoderBoolean = /** @class */ (function (_super) {\r\n    __extends(CoderBoolean, _super);\r\n    function CoderBoolean(coerceFunc, localName) {\r\n        return _super.call(this, coerceFunc, 'bool', 'bool', localName, false) || this;\r\n    }\r\n    CoderBoolean.prototype.encode = function (value) {\r\n        return uint256Coder.encode(!!value ? 1 : 0);\r\n    };\r\n    CoderBoolean.prototype.decode = function (data, offset) {\r\n        try {\r\n            var result = uint256Coder.decode(data, offset);\r\n        }\r\n        catch (error) {\r\n            if (error.reason === 'insufficient data for uint256 type') {\r\n                errors.throwError('insufficient data for boolean type', errors.INVALID_ARGUMENT, {\r\n                    arg: this.localName,\r\n                    coderType: 'boolean',\r\n                    value: error.value\r\n                });\r\n            }\r\n            throw error;\r\n        }\r\n        return {\r\n            consumed: result.consumed,\r\n            value: this.coerceFunc('bool', !result.value.isZero())\r\n        };\r\n    };\r\n    return CoderBoolean;\r\n}(Coder));\r\nvar CoderFixedBytes = /** @class */ (function (_super) {\r\n    __extends(CoderFixedBytes, _super);\r\n    function CoderFixedBytes(coerceFunc, length, localName) {\r\n        var _this = this;\r\n        var name = ('bytes' + length);\r\n        _this = _super.call(this, coerceFunc, name, name, localName, false) || this;\r\n        _this.length = length;\r\n        return _this;\r\n    }\r\n    CoderFixedBytes.prototype.encode = function (value) {\r\n        var result = new Uint8Array(32);\r\n        try {\r\n            var data = bytes_1.arrayify(value);\r\n            if (data.length > 32) {\r\n                throw new Error();\r\n            }\r\n            result.set(data);\r\n        }\r\n        catch (error) {\r\n            errors.throwError('invalid ' + this.name + ' value', errors.INVALID_ARGUMENT, {\r\n                arg: this.localName,\r\n                coderType: this.name,\r\n                value: (error.value || value)\r\n            });\r\n        }\r\n        return result;\r\n    };\r\n    CoderFixedBytes.prototype.decode = function (data, offset) {\r\n        if (data.length < offset + 32) {\r\n            errors.throwError('insufficient data for ' + name + ' type', errors.INVALID_ARGUMENT, {\r\n                arg: this.localName,\r\n                coderType: this.name,\r\n                value: bytes_1.hexlify(data.slice(offset, offset + 32))\r\n            });\r\n        }\r\n        return {\r\n            consumed: 32,\r\n            value: this.coerceFunc(this.name, bytes_1.hexlify(data.slice(offset, offset + this.length)))\r\n        };\r\n    };\r\n    return CoderFixedBytes;\r\n}(Coder));\r\nvar CoderAddress = /** @class */ (function (_super) {\r\n    __extends(CoderAddress, _super);\r\n    function CoderAddress(coerceFunc, localName) {\r\n        return _super.call(this, coerceFunc, 'address', 'address', localName, false) || this;\r\n    }\r\n    CoderAddress.prototype.encode = function (value) {\r\n        var result = new Uint8Array(32);\r\n        try {\r\n            result.set(bytes_1.arrayify(address_1.getAddress(value)), 12);\r\n        }\r\n        catch (error) {\r\n            errors.throwError('invalid address', errors.INVALID_ARGUMENT, {\r\n                arg: this.localName,\r\n                coderType: 'address',\r\n                value: value\r\n            });\r\n        }\r\n        return result;\r\n    };\r\n    CoderAddress.prototype.decode = function (data, offset) {\r\n        if (data.length < offset + 32) {\r\n            errors.throwError('insufficuent data for address type', errors.INVALID_ARGUMENT, {\r\n                arg: this.localName,\r\n                coderType: 'address',\r\n                value: bytes_1.hexlify(data.slice(offset, offset + 32))\r\n            });\r\n        }\r\n        return {\r\n            consumed: 32,\r\n            value: this.coerceFunc('address', address_1.getAddress(bytes_1.hexlify(data.slice(offset + 12, offset + 32))))\r\n        };\r\n    };\r\n    return CoderAddress;\r\n}(Coder));\r\nfunction _encodeDynamicBytes(value) {\r\n    var dataLength = 32 * Math.ceil(value.length / 32);\r\n    var padding = new Uint8Array(dataLength - value.length);\r\n    return bytes_1.concat([\r\n        uint256Coder.encode(value.length),\r\n        value,\r\n        padding\r\n    ]);\r\n}\r\nfunction _decodeDynamicBytes(data, offset, localName) {\r\n    if (data.length < offset + 32) {\r\n        errors.throwError('insufficient data for dynamicBytes length', errors.INVALID_ARGUMENT, {\r\n            arg: localName,\r\n            coderType: 'dynamicBytes',\r\n            value: bytes_1.hexlify(data.slice(offset, offset + 32))\r\n        });\r\n    }\r\n    var length = uint256Coder.decode(data, offset).value;\r\n    try {\r\n        length = length.toNumber();\r\n    }\r\n    catch (error) {\r\n        errors.throwError('dynamic bytes count too large', errors.INVALID_ARGUMENT, {\r\n            arg: localName,\r\n            coderType: 'dynamicBytes',\r\n            value: length.toString()\r\n        });\r\n    }\r\n    if (data.length < offset + 32 + length) {\r\n        errors.throwError('insufficient data for dynamicBytes type', errors.INVALID_ARGUMENT, {\r\n            arg: localName,\r\n            coderType: 'dynamicBytes',\r\n            value: bytes_1.hexlify(data.slice(offset, offset + 32 + length))\r\n        });\r\n    }\r\n    return {\r\n        consumed: 32 + 32 * Math.ceil(length / 32),\r\n        value: data.slice(offset + 32, offset + 32 + length),\r\n    };\r\n}\r\nvar CoderDynamicBytes = /** @class */ (function (_super) {\r\n    __extends(CoderDynamicBytes, _super);\r\n    function CoderDynamicBytes(coerceFunc, localName) {\r\n        return _super.call(this, coerceFunc, 'bytes', 'bytes', localName, true) || this;\r\n    }\r\n    CoderDynamicBytes.prototype.encode = function (value) {\r\n        try {\r\n            return _encodeDynamicBytes(bytes_1.arrayify(value));\r\n        }\r\n        catch (error) {\r\n            errors.throwError('invalid bytes value', errors.INVALID_ARGUMENT, {\r\n                arg: this.localName,\r\n                coderType: 'bytes',\r\n                value: error.value\r\n            });\r\n        }\r\n        return null;\r\n    };\r\n    CoderDynamicBytes.prototype.decode = function (data, offset) {\r\n        var result = _decodeDynamicBytes(data, offset, this.localName);\r\n        result.value = this.coerceFunc('bytes', bytes_1.hexlify(result.value));\r\n        return result;\r\n    };\r\n    return CoderDynamicBytes;\r\n}(Coder));\r\nvar CoderString = /** @class */ (function (_super) {\r\n    __extends(CoderString, _super);\r\n    function CoderString(coerceFunc, localName) {\r\n        return _super.call(this, coerceFunc, 'string', 'string', localName, true) || this;\r\n    }\r\n    CoderString.prototype.encode = function (value) {\r\n        if (typeof (value) !== 'string') {\r\n            errors.throwError('invalid string value', errors.INVALID_ARGUMENT, {\r\n                arg: this.localName,\r\n                coderType: 'string',\r\n                value: value\r\n            });\r\n        }\r\n        return _encodeDynamicBytes(utf8_1.toUtf8Bytes(value));\r\n    };\r\n    CoderString.prototype.decode = function (data, offset) {\r\n        var result = _decodeDynamicBytes(data, offset, this.localName);\r\n        result.value = this.coerceFunc('string', utf8_1.toUtf8String(result.value));\r\n        return result;\r\n    };\r\n    return CoderString;\r\n}(Coder));\r\nfunction alignSize(size) {\r\n    return 32 * Math.ceil(size / 32);\r\n}\r\nfunction pack(coders, values) {\r\n    if (Array.isArray(values)) {\r\n        // do nothing\r\n    }\r\n    else if (values && typeof (values) === 'object') {\r\n        var arrayValues = [];\r\n        coders.forEach(function (coder) {\r\n            arrayValues.push(values[coder.localName]);\r\n        });\r\n        values = arrayValues;\r\n    }\r\n    else {\r\n        errors.throwError('invalid tuple value', errors.INVALID_ARGUMENT, {\r\n            coderType: 'tuple',\r\n            value: values\r\n        });\r\n    }\r\n    if (coders.length !== values.length) {\r\n        errors.throwError('types/value length mismatch', errors.INVALID_ARGUMENT, {\r\n            coderType: 'tuple',\r\n            value: values\r\n        });\r\n    }\r\n    var parts = [];\r\n    coders.forEach(function (coder, index) {\r\n        parts.push({ dynamic: coder.dynamic, value: coder.encode(values[index]) });\r\n    });\r\n    var staticSize = 0, dynamicSize = 0;\r\n    parts.forEach(function (part) {\r\n        if (part.dynamic) {\r\n            staticSize += 32;\r\n            dynamicSize += alignSize(part.value.length);\r\n        }\r\n        else {\r\n            staticSize += alignSize(part.value.length);\r\n        }\r\n    });\r\n    var offset = 0, dynamicOffset = staticSize;\r\n    var data = new Uint8Array(staticSize + dynamicSize);\r\n    parts.forEach(function (part) {\r\n        if (part.dynamic) {\r\n            //uint256Coder.encode(dynamicOffset).copy(data, offset);\r\n            data.set(uint256Coder.encode(dynamicOffset), offset);\r\n            offset += 32;\r\n            //part.value.copy(data, dynamicOffset);  @TODO\r\n            data.set(part.value, dynamicOffset);\r\n            dynamicOffset += alignSize(part.value.length);\r\n        }\r\n        else {\r\n            //part.value.copy(data, offset);  @TODO\r\n            data.set(part.value, offset);\r\n            offset += alignSize(part.value.length);\r\n        }\r\n    });\r\n    return data;\r\n}\r\nfunction unpack(coders, data, offset) {\r\n    var baseOffset = offset;\r\n    var consumed = 0;\r\n    var value = [];\r\n    coders.forEach(function (coder) {\r\n        if (coder.dynamic) {\r\n            var dynamicOffset = uint256Coder.decode(data, offset);\r\n            var result = coder.decode(data, baseOffset + dynamicOffset.value.toNumber());\r\n            // The dynamic part is leap-frogged somewhere else; doesn't count towards size\r\n            result.consumed = dynamicOffset.consumed;\r\n        }\r\n        else {\r\n            var result = coder.decode(data, offset);\r\n        }\r\n        if (result.value != undefined) {\r\n            value.push(result.value);\r\n        }\r\n        offset += result.consumed;\r\n        consumed += result.consumed;\r\n    });\r\n    coders.forEach(function (coder, index) {\r\n        var name = coder.localName;\r\n        if (!name) {\r\n            return;\r\n        }\r\n        if (name === 'length') {\r\n            name = '_length';\r\n        }\r\n        if (value[name] != null) {\r\n            return;\r\n        }\r\n        value[name] = value[index];\r\n    });\r\n    return {\r\n        value: value,\r\n        consumed: consumed\r\n    };\r\n}\r\nvar CoderArray = /** @class */ (function (_super) {\r\n    __extends(CoderArray, _super);\r\n    function CoderArray(coerceFunc, coder, length, localName) {\r\n        var _this = this;\r\n        var type = (coder.type + '[' + (length >= 0 ? length : '') + ']');\r\n        var dynamic = (length === -1 || coder.dynamic);\r\n        _this = _super.call(this, coerceFunc, 'array', type, localName, dynamic) || this;\r\n        _this.coder = coder;\r\n        _this.length = length;\r\n        return _this;\r\n    }\r\n    CoderArray.prototype.encode = function (value) {\r\n        if (!Array.isArray(value)) {\r\n            errors.throwError('expected array value', errors.INVALID_ARGUMENT, {\r\n                arg: this.localName,\r\n                coderType: 'array',\r\n                value: value\r\n            });\r\n        }\r\n        var count = this.length;\r\n        var result = new Uint8Array(0);\r\n        if (count === -1) {\r\n            count = value.length;\r\n            result = uint256Coder.encode(count);\r\n        }\r\n        errors.checkArgumentCount(count, value.length, 'in coder array' + (this.localName ? (\" \" + this.localName) : \"\"));\r\n        var coders = [];\r\n        for (var i = 0; i < value.length; i++) {\r\n            coders.push(this.coder);\r\n        }\r\n        return bytes_1.concat([result, pack(coders, value)]);\r\n    };\r\n    CoderArray.prototype.decode = function (data, offset) {\r\n        // @TODO:\r\n        //if (data.length < offset + length * 32) { throw new Error('invalid array'); }\r\n        var consumed = 0;\r\n        var count = this.length;\r\n        if (count === -1) {\r\n            try {\r\n                var decodedLength = uint256Coder.decode(data, offset);\r\n            }\r\n            catch (error) {\r\n                errors.throwError('insufficient data for dynamic array length', errors.INVALID_ARGUMENT, {\r\n                    arg: this.localName,\r\n                    coderType: 'array',\r\n                    value: error.value\r\n                });\r\n            }\r\n            try {\r\n                count = decodedLength.value.toNumber();\r\n            }\r\n            catch (error) {\r\n                errors.throwError('array count too large', errors.INVALID_ARGUMENT, {\r\n                    arg: this.localName,\r\n                    coderType: 'array',\r\n                    value: decodedLength.value.toString()\r\n                });\r\n            }\r\n            consumed += decodedLength.consumed;\r\n            offset += decodedLength.consumed;\r\n        }\r\n        var coders = [];\r\n        for (var i = 0; i < count; i++) {\r\n            coders.push(new CoderAnonymous(this.coder));\r\n        }\r\n        var result = unpack(coders, data, offset);\r\n        result.consumed += consumed;\r\n        result.value = this.coerceFunc(this.type, result.value);\r\n        return result;\r\n    };\r\n    return CoderArray;\r\n}(Coder));\r\nvar CoderTuple = /** @class */ (function (_super) {\r\n    __extends(CoderTuple, _super);\r\n    function CoderTuple(coerceFunc, coders, localName) {\r\n        var _this = this;\r\n        var dynamic = false;\r\n        var types = [];\r\n        coders.forEach(function (coder) {\r\n            if (coder.dynamic) {\r\n                dynamic = true;\r\n            }\r\n            types.push(coder.type);\r\n        });\r\n        var type = ('tuple(' + types.join(',') + ')');\r\n        _this = _super.call(this, coerceFunc, 'tuple', type, localName, dynamic) || this;\r\n        _this.coders = coders;\r\n        return _this;\r\n    }\r\n    CoderTuple.prototype.encode = function (value) {\r\n        return pack(this.coders, value);\r\n    };\r\n    CoderTuple.prototype.decode = function (data, offset) {\r\n        var result = unpack(this.coders, data, offset);\r\n        result.value = this.coerceFunc(this.type, result.value);\r\n        return result;\r\n    };\r\n    return CoderTuple;\r\n}(Coder));\r\n/*\r\nfunction getTypes(coders) {\r\n    var type = coderTuple(coders).type;\r\n    return type.substring(6, type.length - 1);\r\n}\r\n*/\r\nfunction splitNesting(value) {\r\n    var result = [];\r\n    var accum = '';\r\n    var depth = 0;\r\n    for (var offset = 0; offset < value.length; offset++) {\r\n        var c = value[offset];\r\n        if (c === ',' && depth === 0) {\r\n            result.push(accum);\r\n            accum = '';\r\n        }\r\n        else {\r\n            accum += c;\r\n            if (c === '(') {\r\n                depth++;\r\n            }\r\n            else if (c === ')') {\r\n                depth--;\r\n                if (depth === -1) {\r\n                    throw new Error('unbalanced parenthsis');\r\n                }\r\n            }\r\n        }\r\n    }\r\n    result.push(accum);\r\n    return result;\r\n}\r\n// @TODO: Is there a way to return \"class\"?\r\nvar paramTypeSimple = {\r\n    address: CoderAddress,\r\n    bool: CoderBoolean,\r\n    string: CoderString,\r\n    bytes: CoderDynamicBytes,\r\n};\r\nfunction getTupleParamCoder(coerceFunc, components, localName) {\r\n    if (!components) {\r\n        components = [];\r\n    }\r\n    var coders = [];\r\n    components.forEach(function (component) {\r\n        coders.push(getParamCoder(coerceFunc, component));\r\n    });\r\n    return new CoderTuple(coerceFunc, coders, localName);\r\n}\r\nfunction getParamCoder(coerceFunc, param) {\r\n    var coder = paramTypeSimple[param.type];\r\n    if (coder) {\r\n        return new coder(coerceFunc, param.name);\r\n    }\r\n    var match = param.type.match(paramTypeNumber);\r\n    if (match) {\r\n        var size = parseInt(match[2] || \"256\");\r\n        if (size === 0 || size > 256 || (size % 8) !== 0) {\r\n            errors.throwError('invalid ' + match[1] + ' bit length', errors.INVALID_ARGUMENT, {\r\n                arg: 'param',\r\n                value: param\r\n            });\r\n        }\r\n        return new CoderNumber(coerceFunc, size / 8, (match[1] === 'int'), param.name);\r\n    }\r\n    var match = param.type.match(paramTypeBytes);\r\n    if (match) {\r\n        var size = parseInt(match[1]);\r\n        if (size === 0 || size > 32) {\r\n            errors.throwError('invalid bytes length', errors.INVALID_ARGUMENT, {\r\n                arg: 'param',\r\n                value: param\r\n            });\r\n        }\r\n        return new CoderFixedBytes(coerceFunc, size, param.name);\r\n    }\r\n    var match = param.type.match(paramTypeArray);\r\n    if (match) {\r\n        var size = parseInt(match[2] || \"-1\");\r\n        param = properties_1.jsonCopy(param);\r\n        param.type = match[1];\r\n        return new CoderArray(coerceFunc, getParamCoder(coerceFunc, param), size, param.name);\r\n    }\r\n    if (param.type.substring(0, 5) === 'tuple') {\r\n        return getTupleParamCoder(coerceFunc, param.components, param.name);\r\n    }\r\n    if (param.type === '') {\r\n        return new CoderNull(coerceFunc, param.name);\r\n    }\r\n    errors.throwError('invalid type', errors.INVALID_ARGUMENT, {\r\n        arg: 'type',\r\n        value: param.type\r\n    });\r\n    return null;\r\n}\r\nvar AbiCoder = /** @class */ (function () {\r\n    function AbiCoder(coerceFunc) {\r\n        errors.checkNew(this, AbiCoder);\r\n        if (!coerceFunc) {\r\n            coerceFunc = exports.defaultCoerceFunc;\r\n        }\r\n        properties_1.defineReadOnly(this, 'coerceFunc', coerceFunc);\r\n    }\r\n    AbiCoder.prototype.encode = function (types, values) {\r\n        if (types.length !== values.length) {\r\n            errors.throwError('types/values length mismatch', errors.INVALID_ARGUMENT, {\r\n                count: { types: types.length, values: values.length },\r\n                value: { types: types, values: values }\r\n            });\r\n        }\r\n        var coders = [];\r\n        types.forEach(function (type) {\r\n            // Convert types to type objects\r\n            //   - \"uint foo\" => { type: \"uint\", name: \"foo\" }\r\n            //   - \"tuple(uint, uint)\" => { type: \"tuple\", components: [ { type: \"uint\" }, { type: \"uint\" }, ] }\r\n            var typeObject = null;\r\n            if (typeof (type) === 'string') {\r\n                typeObject = parseParam(type);\r\n            }\r\n            else {\r\n                typeObject = type;\r\n            }\r\n            coders.push(getParamCoder(this.coerceFunc, typeObject));\r\n        }, this);\r\n        return bytes_1.hexlify(new CoderTuple(this.coerceFunc, coders, '_').encode(values));\r\n    };\r\n    AbiCoder.prototype.decode = function (types, data) {\r\n        var coders = [];\r\n        types.forEach(function (type) {\r\n            // See encode for details\r\n            var typeObject = null;\r\n            if (typeof (type) === 'string') {\r\n                typeObject = parseParam(type);\r\n            }\r\n            else {\r\n                typeObject = properties_1.jsonCopy(type);\r\n            }\r\n            coders.push(getParamCoder(this.coerceFunc, typeObject));\r\n        }, this);\r\n        return new CoderTuple(this.coerceFunc, coders, '_').decode(bytes_1.arrayify(data), 0).value;\r\n    };\r\n    return AbiCoder;\r\n}());\r\nexports.AbiCoder = AbiCoder;\r\nexports.defaultAbiCoder = new AbiCoder();\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}
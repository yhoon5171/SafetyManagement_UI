{"ast":null,"code":"\"use strict\";\n/**\n * A minimal base64 implementation for number arrays.\n * @memberof util\n * @namespace\n */\n\nvar base64 = exports;\n/**\n * Calculates the byte length of a base64 encoded string.\n * @param {string} string Base64 encoded string\n * @returns {number} Byte length\n */\n\nbase64.length = function length(string) {\n  var p = string.length;\n  if (!p) return 0;\n  var n = 0;\n\n  while (--p % 4 > 1 && string.charAt(p) === \"=\") {\n    ++n;\n  }\n\n  return Math.ceil(string.length * 3) / 4 - n;\n}; // Base64 encoding table\n\n\nvar b64 = new Array(64); // Base64 decoding table\n\nvar s64 = new Array(123); // 65..90, 97..122, 48..57, 43, 47\n\nfor (var i = 0; i < 64;) {\n  s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\n}\n/**\n * Encodes a buffer to a base64 encoded string.\n * @param {Uint8Array} buffer Source buffer\n * @param {number} start Source start\n * @param {number} end Source end\n * @returns {string} Base64 encoded string\n */\n\n\nbase64.encode = function encode(buffer, start, end) {\n  var parts = null,\n      chunk = [];\n  var i = 0,\n      // output index\n  j = 0,\n      // goto index\n  t; // temporary\n\n  while (start < end) {\n    var b = buffer[start++];\n\n    switch (j) {\n      case 0:\n        chunk[i++] = b64[b >> 2];\n        t = (b & 3) << 4;\n        j = 1;\n        break;\n\n      case 1:\n        chunk[i++] = b64[t | b >> 4];\n        t = (b & 15) << 2;\n        j = 2;\n        break;\n\n      case 2:\n        chunk[i++] = b64[t | b >> 6];\n        chunk[i++] = b64[b & 63];\n        j = 0;\n        break;\n    }\n\n    if (i > 8191) {\n      (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\n      i = 0;\n    }\n  }\n\n  if (j) {\n    chunk[i++] = b64[t];\n    chunk[i++] = 61;\n    if (j === 1) chunk[i++] = 61;\n  }\n\n  if (parts) {\n    if (i) parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\n    return parts.join(\"\");\n  }\n\n  return String.fromCharCode.apply(String, chunk.slice(0, i));\n};\n\nvar invalidEncoding = \"invalid encoding\";\n/**\n * Decodes a base64 encoded string to a buffer.\n * @param {string} string Source string\n * @param {Uint8Array} buffer Destination buffer\n * @param {number} offset Destination offset\n * @returns {number} Number of bytes written\n * @throws {Error} If encoding is invalid\n */\n\nbase64.decode = function decode(string, buffer, offset) {\n  var start = offset;\n  var j = 0,\n      // goto index\n  t; // temporary\n\n  for (var i = 0; i < string.length;) {\n    var c = string.charCodeAt(i++);\n    if (c === 61 && j > 1) break;\n    if ((c = s64[c]) === undefined) throw Error(invalidEncoding);\n\n    switch (j) {\n      case 0:\n        t = c;\n        j = 1;\n        break;\n\n      case 1:\n        buffer[offset++] = t << 2 | (c & 48) >> 4;\n        t = c;\n        j = 2;\n        break;\n\n      case 2:\n        buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\n        t = c;\n        j = 3;\n        break;\n\n      case 3:\n        buffer[offset++] = (t & 3) << 6 | c;\n        j = 0;\n        break;\n    }\n  }\n\n  if (j === 1) throw Error(invalidEncoding);\n  return offset - start;\n};\n/**\n * Tests if the specified string appears to be base64 encoded.\n * @param {string} string String to test\n * @returns {boolean} `true` if probably base64 encoded, otherwise false\n */\n\n\nbase64.test = function test(string) {\n  return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\n};","map":{"version":3,"names":["base64","exports","length","string","p","n","charAt","Math","ceil","b64","Array","s64","i","encode","buffer","start","end","parts","chunk","j","t","b","push","String","fromCharCode","apply","slice","join","invalidEncoding","decode","offset","c","charCodeAt","undefined","Error","test"],"sources":["/home/ubuntu/SafetyManagement_UI/client/node_modules/@protobufjs/base64/index.js"],"sourcesContent":["\"use strict\";\n\n/**\n * A minimal base64 implementation for number arrays.\n * @memberof util\n * @namespace\n */\nvar base64 = exports;\n\n/**\n * Calculates the byte length of a base64 encoded string.\n * @param {string} string Base64 encoded string\n * @returns {number} Byte length\n */\nbase64.length = function length(string) {\n    var p = string.length;\n    if (!p)\n        return 0;\n    var n = 0;\n    while (--p % 4 > 1 && string.charAt(p) === \"=\")\n        ++n;\n    return Math.ceil(string.length * 3) / 4 - n;\n};\n\n// Base64 encoding table\nvar b64 = new Array(64);\n\n// Base64 decoding table\nvar s64 = new Array(123);\n\n// 65..90, 97..122, 48..57, 43, 47\nfor (var i = 0; i < 64;)\n    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\n\n/**\n * Encodes a buffer to a base64 encoded string.\n * @param {Uint8Array} buffer Source buffer\n * @param {number} start Source start\n * @param {number} end Source end\n * @returns {string} Base64 encoded string\n */\nbase64.encode = function encode(buffer, start, end) {\n    var parts = null,\n        chunk = [];\n    var i = 0, // output index\n        j = 0, // goto index\n        t;     // temporary\n    while (start < end) {\n        var b = buffer[start++];\n        switch (j) {\n            case 0:\n                chunk[i++] = b64[b >> 2];\n                t = (b & 3) << 4;\n                j = 1;\n                break;\n            case 1:\n                chunk[i++] = b64[t | b >> 4];\n                t = (b & 15) << 2;\n                j = 2;\n                break;\n            case 2:\n                chunk[i++] = b64[t | b >> 6];\n                chunk[i++] = b64[b & 63];\n                j = 0;\n                break;\n        }\n        if (i > 8191) {\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\n            i = 0;\n        }\n    }\n    if (j) {\n        chunk[i++] = b64[t];\n        chunk[i++] = 61;\n        if (j === 1)\n            chunk[i++] = 61;\n    }\n    if (parts) {\n        if (i)\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\n        return parts.join(\"\");\n    }\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\n};\n\nvar invalidEncoding = \"invalid encoding\";\n\n/**\n * Decodes a base64 encoded string to a buffer.\n * @param {string} string Source string\n * @param {Uint8Array} buffer Destination buffer\n * @param {number} offset Destination offset\n * @returns {number} Number of bytes written\n * @throws {Error} If encoding is invalid\n */\nbase64.decode = function decode(string, buffer, offset) {\n    var start = offset;\n    var j = 0, // goto index\n        t;     // temporary\n    for (var i = 0; i < string.length;) {\n        var c = string.charCodeAt(i++);\n        if (c === 61 && j > 1)\n            break;\n        if ((c = s64[c]) === undefined)\n            throw Error(invalidEncoding);\n        switch (j) {\n            case 0:\n                t = c;\n                j = 1;\n                break;\n            case 1:\n                buffer[offset++] = t << 2 | (c & 48) >> 4;\n                t = c;\n                j = 2;\n                break;\n            case 2:\n                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\n                t = c;\n                j = 3;\n                break;\n            case 3:\n                buffer[offset++] = (t & 3) << 6 | c;\n                j = 0;\n                break;\n        }\n    }\n    if (j === 1)\n        throw Error(invalidEncoding);\n    return offset - start;\n};\n\n/**\n * Tests if the specified string appears to be base64 encoded.\n * @param {string} string String to test\n * @returns {boolean} `true` if probably base64 encoded, otherwise false\n */\nbase64.test = function test(string) {\n    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"/*\r\n    This file is part of web3.js.\r\n\r\n    web3.js is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU Lesser General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    web3.js is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU Lesser General Public License for more details.\r\n\r\n    You should have received a copy of the GNU Lesser General Public License\r\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\n\n/**\r\n * @file index.js\r\n * @author Fabian Vogelsteller <fabian@ethereum.org>\r\n * @author Marek Kotewicz <marek@parity.io>\r\n * @date 2017\r\n */\n'use strict';\n\nvar errors = require('web3-core-helpers').errors;\n\nvar formatters = require('web3-core-helpers').formatters;\n\nvar utils = require('web3-utils');\n\nvar promiEvent = require('web3-core-promievent');\n\nvar Subscriptions = require('web3-core-subscriptions').subscriptions;\n\nvar EthersTransactionUtils = require('@ethersproject/transactions');\n\nvar Method = function Method(options) {\n  if (!options.call || !options.name) {\n    throw new Error('When creating a method you need to provide at least the \"name\" and \"call\" property.');\n  }\n\n  this.name = options.name;\n  this.call = options.call;\n  this.params = options.params || 0;\n  this.inputFormatter = options.inputFormatter;\n  this.outputFormatter = options.outputFormatter;\n  this.transformPayload = options.transformPayload;\n  this.extraFormatters = options.extraFormatters;\n  this.abiCoder = options.abiCoder; // Will be used to encode the revert reason string\n\n  this.requestManager = options.requestManager; // reference to eth.accounts\n\n  this.accounts = options.accounts;\n  this.defaultBlock = options.defaultBlock || 'latest';\n  this.defaultAccount = options.defaultAccount || null;\n  this.transactionBlockTimeout = options.transactionBlockTimeout || 50;\n  this.transactionConfirmationBlocks = options.transactionConfirmationBlocks || 24;\n  this.transactionPollingTimeout = options.transactionPollingTimeout || 750;\n  this.transactionPollingInterval = options.transactionPollingInterval || 1000;\n  this.blockHeaderTimeout = options.blockHeaderTimeout || 10; // 10 seconds\n\n  this.defaultCommon = options.defaultCommon;\n  this.defaultChain = options.defaultChain;\n  this.defaultHardfork = options.defaultHardfork;\n  this.handleRevert = options.handleRevert;\n};\n\nMethod.prototype.setRequestManager = function (requestManager, accounts) {\n  this.requestManager = requestManager; // reference to eth.accounts\n\n  if (accounts) {\n    this.accounts = accounts;\n  }\n};\n\nMethod.prototype.createFunction = function (requestManager, accounts) {\n  var func = this.buildCall();\n  func.call = this.call;\n  this.setRequestManager(requestManager || this.requestManager, accounts || this.accounts);\n  return func;\n};\n\nMethod.prototype.attachToObject = function (obj) {\n  var func = this.buildCall();\n  func.call = this.call;\n  var name = this.name.split('.');\n\n  if (name.length > 1) {\n    obj[name[0]] = obj[name[0]] || {};\n    obj[name[0]][name[1]] = func;\n  } else {\n    obj[name[0]] = func;\n  }\n};\n/**\r\n * Should be used to determine name of the jsonrpc method based on arguments\r\n *\r\n * @method getCall\r\n * @param {Array} arguments\r\n * @return {String} name of jsonrpc method\r\n */\n\n\nMethod.prototype.getCall = function (args) {\n  return typeof this.call === 'function' ? this.call(args) : this.call;\n};\n/**\r\n * Should be used to extract callback from array of arguments. Modifies input param\r\n *\r\n * @method extractCallback\r\n * @param {Array} arguments\r\n * @return {Function|Null} callback, if exists\r\n */\n\n\nMethod.prototype.extractCallback = function (args) {\n  if (typeof args[args.length - 1] === 'function') {\n    return args.pop(); // modify the args array!\n  }\n};\n/**\r\n * Should be called to check if the number of arguments is correct\r\n *\r\n * @method validateArgs\r\n * @param {Array} arguments\r\n * @throws {Error} if it is not\r\n */\n\n\nMethod.prototype.validateArgs = function (args) {\n  if (args.length !== this.params) {\n    throw errors.InvalidNumberOfParams(args.length, this.params, this.name);\n  }\n};\n/**\r\n * Should be called to format input args of method\r\n *\r\n * @method formatInput\r\n * @param {Array}\r\n * @return {Array}\r\n */\n\n\nMethod.prototype.formatInput = function (args) {\n  var _this = this;\n\n  if (!this.inputFormatter) {\n    return args;\n  }\n\n  return this.inputFormatter.map(function (formatter, index) {\n    // bind this for defaultBlock, and defaultAccount\n    return formatter ? formatter.call(_this, args[index]) : args[index];\n  });\n};\n/**\r\n * Should be called to format output(result) of method\r\n *\r\n * @method formatOutput\r\n * @param {Object}\r\n * @return {Object}\r\n */\n\n\nMethod.prototype.formatOutput = function (result) {\n  var _this = this;\n\n  if (Array.isArray(result)) {\n    return result.map(function (res) {\n      return _this.outputFormatter && res ? _this.outputFormatter(res) : res;\n    });\n  } else {\n    return this.outputFormatter && result ? this.outputFormatter(result) : result;\n  }\n};\n/**\r\n * Should create payload from given input args\r\n *\r\n * @method toPayload\r\n * @param {Array} args\r\n * @return {Object}\r\n */\n\n\nMethod.prototype.toPayload = function (args) {\n  var call = this.getCall(args);\n  var callback = this.extractCallback(args);\n  var params = this.formatInput(args);\n  this.validateArgs(params);\n  var payload = {\n    method: call,\n    params: params,\n    callback: callback\n  };\n\n  if (this.transformPayload) {\n    payload = this.transformPayload(payload);\n  }\n\n  return payload;\n};\n\nMethod.prototype._confirmTransaction = function (defer, result, payload) {\n  var method = this,\n      promiseResolved = false,\n      canUnsubscribe = true,\n      timeoutCount = 0,\n      confirmationCount = 0,\n      intervalId = null,\n      blockHeaderTimeoutId = null,\n      lastBlock = null,\n      receiptJSON = '',\n      gasProvided = !!payload.params[0] && typeof payload.params[0] === 'object' && payload.params[0].gas ? payload.params[0].gas : null,\n      isContractDeployment = !!payload.params[0] && typeof payload.params[0] === 'object' && payload.params[0].data && payload.params[0].from && !payload.params[0].to,\n      hasBytecode = isContractDeployment && payload.params[0].data.length > 2; // add custom send Methods\n\n  var _ethereumCalls = [new Method({\n    name: 'getBlockByNumber',\n    call: 'eth_getBlockByNumber',\n    params: 2,\n    inputFormatter: [formatters.inputBlockNumberFormatter, function (val) {\n      return !!val;\n    }],\n    outputFormatter: formatters.outputBlockFormatter\n  }), new Method({\n    name: 'getTransactionReceipt',\n    call: 'eth_getTransactionReceipt',\n    params: 1,\n    inputFormatter: [null],\n    outputFormatter: formatters.outputTransactionReceiptFormatter\n  }), new Method({\n    name: 'getCode',\n    call: 'eth_getCode',\n    params: 2,\n    inputFormatter: [formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter]\n  }), new Method({\n    name: 'getTransactionByHash',\n    call: 'eth_getTransactionByHash',\n    params: 1,\n    inputFormatter: [null],\n    outputFormatter: formatters.outputTransactionFormatter\n  }), new Subscriptions({\n    name: 'subscribe',\n    type: 'eth',\n    subscriptions: {\n      'newBlockHeaders': {\n        subscriptionName: 'newHeads',\n        params: 0,\n        outputFormatter: formatters.outputBlockFormatter\n      }\n    }\n  })]; // attach methods to this._ethereumCall\n\n  var _ethereumCall = {};\n\n  _ethereumCalls.forEach(mthd => {\n    mthd.attachToObject(_ethereumCall);\n    mthd.requestManager = method.requestManager; // assign rather than call setRequestManager()\n  }); // fire \"receipt\" and confirmation events and resolve after\n\n\n  var checkConfirmation = function (existingReceipt, isPolling, err, blockHeader, sub) {\n    if (!err) {\n      // create fake unsubscribe\n      if (!sub) {\n        sub = {\n          unsubscribe: function () {\n            clearInterval(intervalId);\n            clearTimeout(blockHeaderTimeoutId);\n          }\n        };\n      } // if we have a valid receipt we don't need to send a request\n\n\n      return (existingReceipt ? promiEvent.resolve(existingReceipt) : _ethereumCall.getTransactionReceipt(result) // catch error from requesting receipt\n      ).catch(function (err) {\n        sub.unsubscribe();\n        promiseResolved = true;\n\n        utils._fireError({\n          message: 'Failed to check for transaction receipt:',\n          data: err\n        }, defer.eventEmitter, defer.reject);\n      }) // if CONFIRMATION listener exists check for confirmations, by setting canUnsubscribe = false\n      .then(async function (receipt) {\n        if (!receipt || !receipt.blockHash) {\n          throw new Error('Receipt missing or blockHash null');\n        } // apply extra formatters\n\n\n        if (method.extraFormatters && method.extraFormatters.receiptFormatter) {\n          receipt = method.extraFormatters.receiptFormatter(receipt);\n        } // check if confirmation listener exists\n\n\n        if (defer.eventEmitter.listeners('confirmation').length > 0) {\n          var block; // If there was an immediately retrieved receipt, it's already\n          // been confirmed by the direct call to checkConfirmation needed\n          // for parity instant-seal\n\n          if (existingReceipt === undefined || confirmationCount !== 0) {\n            // Get latest block to emit with confirmation\n            var latestBlock = await _ethereumCall.getBlockByNumber('latest');\n            var latestBlockHash = latestBlock ? latestBlock.hash : null;\n\n            if (isPolling) {\n              // Check if actually a new block is existing on polling\n              if (lastBlock) {\n                block = await _ethereumCall.getBlockByNumber(lastBlock.number + 1);\n\n                if (block) {\n                  lastBlock = block;\n                  defer.eventEmitter.emit('confirmation', confirmationCount, receipt, latestBlockHash);\n                }\n              } else {\n                block = await _ethereumCall.getBlockByNumber(receipt.blockNumber);\n                lastBlock = block;\n                defer.eventEmitter.emit('confirmation', confirmationCount, receipt, latestBlockHash);\n              }\n            } else {\n              defer.eventEmitter.emit('confirmation', confirmationCount, receipt, latestBlockHash);\n            }\n          }\n\n          if (isPolling && block || !isPolling) {\n            confirmationCount++;\n          }\n\n          canUnsubscribe = false;\n\n          if (confirmationCount === method.transactionConfirmationBlocks + 1) {\n            // add 1 so we account for conf 0\n            sub.unsubscribe();\n            defer.eventEmitter.removeAllListeners();\n          }\n        }\n\n        return receipt;\n      }) // CHECK for CONTRACT DEPLOYMENT\n      .then(async function (receipt) {\n        if (isContractDeployment && !promiseResolved) {\n          if (!receipt.contractAddress) {\n            if (canUnsubscribe) {\n              sub.unsubscribe();\n              promiseResolved = true;\n            }\n\n            utils._fireError(errors.NoContractAddressFoundError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n\n            return;\n          }\n\n          var code;\n\n          try {\n            code = await _ethereumCall.getCode(receipt.contractAddress);\n          } catch (err) {// ignore;\n          }\n\n          if (!code) {\n            return;\n          } // If deployment is status.true and there was a real\n          // bytecode string, assume it was successful.\n\n\n          var deploymentSuccess = receipt.status === true && hasBytecode;\n\n          if (deploymentSuccess || code.length > 2) {\n            defer.eventEmitter.emit('receipt', receipt); // if contract, return instance instead of receipt\n\n            if (method.extraFormatters && method.extraFormatters.contractDeployFormatter) {\n              defer.resolve(method.extraFormatters.contractDeployFormatter(receipt));\n            } else {\n              defer.resolve(receipt);\n            } // need to remove listeners, as they aren't removed automatically when succesfull\n\n\n            if (canUnsubscribe) {\n              defer.eventEmitter.removeAllListeners();\n            }\n          } else {\n            utils._fireError(errors.ContractCodeNotStoredError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n          }\n\n          if (canUnsubscribe) {\n            sub.unsubscribe();\n          }\n\n          promiseResolved = true;\n        }\n\n        return receipt;\n      }) // CHECK for normal tx check for receipt only\n      .then(async function (receipt) {\n        if (!isContractDeployment && !promiseResolved) {\n          if (!receipt.outOfGas && (!gasProvided || gasProvided !== receipt.gasUsed) && (receipt.status === true || receipt.status === '0x1' || typeof receipt.status === 'undefined')) {\n            defer.eventEmitter.emit('receipt', receipt);\n            defer.resolve(receipt); // need to remove listeners, as they aren't removed automatically when succesfull\n\n            if (canUnsubscribe) {\n              defer.eventEmitter.removeAllListeners();\n            }\n          } else {\n            receiptJSON = JSON.stringify(receipt, null, 2);\n\n            if (receipt.status === false || receipt.status === '0x0') {\n              try {\n                var revertMessage = null;\n\n                if (method.handleRevert && (method.call === 'eth_sendTransaction' || method.call === 'eth_sendRawTransaction')) {\n                  var txReplayOptions = payload.params[0]; // If send was raw, fetch the transaction and reconstitute the\n                  // original params so they can be replayed with `eth_call`\n\n                  if (method.call === 'eth_sendRawTransaction') {\n                    var rawTransactionHex = payload.params[0];\n                    var parsedTx = EthersTransactionUtils.parse(rawTransactionHex);\n                    txReplayOptions = formatters.inputTransactionFormatter({\n                      data: parsedTx.data,\n                      to: parsedTx.to,\n                      from: parsedTx.from,\n                      gas: parsedTx.gasLimit.toHexString(),\n                      gasPrice: parsedTx.gasPrice.toHexString(),\n                      value: parsedTx.value.toHexString()\n                    });\n                  } // Get revert reason string with eth_call\n\n\n                  revertMessage = await method.getRevertReason(txReplayOptions, receipt.blockNumber);\n\n                  if (revertMessage) {\n                    // Only throw a revert error if a revert reason is existing\n                    utils._fireError(errors.TransactionRevertInstructionError(revertMessage.reason, revertMessage.signature, receipt), defer.eventEmitter, defer.reject, null, receipt);\n                  } else {\n                    throw false; // Throw false and let the try/catch statement handle the error correctly after\n                  }\n                } else {\n                  throw false; // Throw false and let the try/catch statement handle the error correctly after\n                }\n              } catch (error) {\n                // Throw an normal revert error if no revert reason is given or the detection of it is disabled\n                utils._fireError(errors.TransactionRevertedWithoutReasonError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n              }\n            } else {\n              // Throw OOG if status is not existing and provided gas and used gas are equal\n              utils._fireError(errors.TransactionOutOfGasError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n            }\n          }\n\n          if (canUnsubscribe) {\n            sub.unsubscribe();\n          }\n\n          promiseResolved = true;\n        }\n      }) // time out the transaction if not mined after 50 blocks\n      .catch(function () {\n        timeoutCount++; // check to see if we are http polling\n\n        if (!!isPolling) {\n          // polling timeout is different than transactionBlockTimeout blocks since we are triggering every second\n          if (timeoutCount - 1 >= method.transactionPollingTimeout) {\n            sub.unsubscribe();\n            promiseResolved = true;\n\n            utils._fireError(errors.TransactionError('Transaction was not mined within ' + method.transactionPollingTimeout + ' seconds, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\n          }\n        } else {\n          if (timeoutCount - 1 >= method.transactionBlockTimeout) {\n            sub.unsubscribe();\n            promiseResolved = true;\n\n            utils._fireError(errors.TransactionError('Transaction was not mined within ' + method.transactionBlockTimeout + ' blocks, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\n          }\n        }\n      });\n    } else {\n      sub.unsubscribe();\n      promiseResolved = true;\n\n      utils._fireError({\n        message: 'Failed to subscribe to new newBlockHeaders to confirm the transaction receipts.',\n        data: err\n      }, defer.eventEmitter, defer.reject);\n    }\n  }; // start watching for confirmation depending on the support features of the provider\n\n\n  var startWatching = function (existingReceipt) {\n    let blockHeaderArrived = false;\n\n    const startInterval = () => {\n      intervalId = setInterval(checkConfirmation.bind(null, existingReceipt, true), method.transactionPollingInterval);\n    }; // If provider do not support event subscription use polling\n\n\n    if (!this.requestManager.provider.on) {\n      return startInterval();\n    } // Subscribe to new block headers to look for tx receipt\n\n\n    _ethereumCall.subscribe('newBlockHeaders', function (err, blockHeader, sub) {\n      blockHeaderArrived = true;\n\n      if (err || !blockHeader) {\n        // fall back to polling\n        return startInterval();\n      }\n\n      checkConfirmation(existingReceipt, false, err, blockHeader, sub);\n    }); // Fallback to polling if tx receipt didn't arrived in \"blockHeaderTimeout\" [10 seconds]\n\n\n    blockHeaderTimeoutId = setTimeout(() => {\n      if (!blockHeaderArrived) {\n        startInterval();\n      }\n    }, this.blockHeaderTimeout * 1000);\n  }.bind(this); // first check if we already have a confirmed transaction\n\n\n  _ethereumCall.getTransactionReceipt(result).then(function (receipt) {\n    if (receipt && receipt.blockHash) {\n      if (defer.eventEmitter.listeners('confirmation').length > 0) {\n        // We must keep on watching for new Blocks, if a confirmation listener is present\n        startWatching(receipt);\n      }\n\n      checkConfirmation(receipt, false);\n    } else if (!promiseResolved) {\n      startWatching();\n    }\n  }).catch(function () {\n    if (!promiseResolved) startWatching();\n  });\n};\n\nvar getWallet = function (from, accounts) {\n  var wallet = null; // is index given\n\n  if (typeof from === 'number') {\n    wallet = accounts.wallet[from]; // is account given\n  } else if (!!from && typeof from === 'object' && from.address && from.privateKey) {\n    wallet = from; // search in wallet for address\n  } else {\n    wallet = accounts.wallet[from.toLowerCase()];\n  }\n\n  return wallet;\n};\n\nMethod.prototype.buildCall = function () {\n  var method = this,\n      isSendTx = method.call === 'eth_sendTransaction' || method.call === 'eth_sendRawTransaction',\n      // || method.call === 'personal_sendTransaction'\n  isCall = method.call === 'eth_call'; // actual send function\n\n  var send = function () {\n    var defer = promiEvent(!isSendTx),\n        payload = method.toPayload(Array.prototype.slice.call(arguments)); // CALLBACK function\n\n    var sendTxCallback = function (err, result) {\n      if (method.handleRevert && isCall && method.abiCoder) {\n        var reasonData; // Ganache / Geth <= 1.9.13 return the reason data as a successful eth_call response\n        // Geth >= 1.9.15 attaches the reason data to an error object.\n        // Geth 1.9.14 is missing revert reason (https://github.com/ethereum/web3.js/issues/3520)\n\n        if (!err && method.isRevertReasonString(result)) {\n          reasonData = result.substring(10);\n        } else if (err && err.data) {\n          reasonData = err.data.substring(10);\n        }\n\n        if (reasonData) {\n          var reason = method.abiCoder.decodeParameter('string', '0x' + reasonData);\n          var signature = 'Error(String)';\n\n          utils._fireError(errors.RevertInstructionError(reason, signature), defer.eventEmitter, defer.reject, payload.callback, {\n            reason: reason,\n            signature: signature\n          });\n\n          return;\n        }\n      }\n\n      try {\n        result = method.formatOutput(result);\n      } catch (e) {\n        err = e;\n      }\n\n      if (result instanceof Error) {\n        err = result;\n      }\n\n      if (!err) {\n        if (payload.callback) {\n          payload.callback(null, result);\n        }\n      } else {\n        if (err.error) {\n          err = err.error;\n        }\n\n        return utils._fireError(err, defer.eventEmitter, defer.reject, payload.callback);\n      } // return PROMISE\n\n\n      if (!isSendTx) {\n        if (!err) {\n          defer.resolve(result);\n        } // return PROMIEVENT\n\n      } else {\n        defer.eventEmitter.emit('transactionHash', result);\n\n        method._confirmTransaction(defer, result, payload);\n      }\n    }; // SENDS the SIGNED SIGNATURE\n\n\n    var sendSignedTx = function (sign) {\n      var signedPayload = { ...payload,\n        method: 'eth_sendRawTransaction',\n        params: [sign.rawTransaction]\n      };\n      method.requestManager.send(signedPayload, sendTxCallback);\n    };\n\n    var sendRequest = function (payload, method) {\n      if (method && method.accounts && method.accounts.wallet && method.accounts.wallet.length) {\n        var wallet; // ETH_SENDTRANSACTION\n\n        if (payload.method === 'eth_sendTransaction') {\n          var tx = payload.params[0];\n          wallet = getWallet(!!tx && typeof tx === 'object' ? tx.from : null, method.accounts); // If wallet was found, sign tx, and send using sendRawTransaction\n\n          if (wallet && wallet.privateKey) {\n            var tx = JSON.parse(JSON.stringify(tx));\n            delete tx.from;\n\n            if (method.defaultChain && !tx.chain) {\n              tx.chain = method.defaultChain;\n            }\n\n            if (method.defaultHardfork && !tx.hardfork) {\n              tx.hardfork = method.defaultHardfork;\n            }\n\n            if (method.defaultCommon && !tx.common) {\n              tx.common = method.defaultCommon;\n            }\n\n            method.accounts.signTransaction(tx, wallet.privateKey).then(sendSignedTx).catch(function (err) {\n              if (typeof defer.eventEmitter.listeners === 'function' && defer.eventEmitter.listeners('error').length) {\n                try {\n                  defer.eventEmitter.emit('error', err);\n                } catch (err) {// Ignore userland error prevent it to bubble up within web3.\n                }\n\n                defer.eventEmitter.removeAllListeners();\n                defer.eventEmitter.catch(function () {});\n              }\n\n              defer.reject(err);\n            });\n            return;\n          } // ETH_SIGN\n\n        } else if (payload.method === 'eth_sign') {\n          var data = payload.params[1];\n          wallet = getWallet(payload.params[0], method.accounts); // If wallet was found, sign tx, and send using sendRawTransaction\n\n          if (wallet && wallet.privateKey) {\n            var sign = method.accounts.sign(data, wallet.privateKey);\n\n            if (payload.callback) {\n              payload.callback(null, sign.signature);\n            }\n\n            defer.resolve(sign.signature);\n            return;\n          }\n        }\n      }\n\n      return method.requestManager.send(payload, sendTxCallback);\n    }; // Send the actual transaction\n\n\n    if (isSendTx && !!payload.params[0] && typeof payload.params[0] === 'object' && typeof payload.params[0].gasPrice === 'undefined' && (typeof payload.params[0].maxPriorityFeePerGas === 'undefined' || typeof payload.params[0].maxFeePerGas === 'undefined')) {\n      _handleTxPricing(method, payload.params[0]).then(txPricing => {\n        if (txPricing.gasPrice !== undefined) {\n          payload.params[0].gasPrice = txPricing.gasPrice;\n        } else if (txPricing.maxPriorityFeePerGas !== undefined && txPricing.maxFeePerGas !== undefined) {\n          payload.params[0].maxPriorityFeePerGas = txPricing.maxPriorityFeePerGas;\n          payload.params[0].maxFeePerGas = txPricing.maxFeePerGas;\n        }\n\n        if (isSendTx) {\n          setTimeout(() => {\n            defer.eventEmitter.emit('sending', payload);\n          }, 0);\n        }\n\n        sendRequest(payload, method);\n      });\n    } else {\n      if (isSendTx) {\n        setTimeout(() => {\n          defer.eventEmitter.emit('sending', payload);\n        }, 0);\n      }\n\n      sendRequest(payload, method);\n    }\n\n    if (isSendTx) {\n      setTimeout(() => {\n        defer.eventEmitter.emit('sent', payload);\n      }, 0);\n    }\n\n    return defer.eventEmitter;\n  }; // necessary to attach things to the method\n\n\n  send.method = method; // necessary for batch requests\n\n  send.request = this.request.bind(this);\n  return send;\n};\n\nfunction _handleTxPricing(method, tx) {\n  return new Promise((resolve, reject) => {\n    try {\n      var getBlockByNumber = new Method({\n        name: 'getBlockByNumber',\n        call: 'eth_getBlockByNumber',\n        params: 2,\n        inputFormatter: [function (blockNumber) {\n          return blockNumber ? utils.toHex(blockNumber) : 'latest';\n        }, function () {\n          return false;\n        }]\n      }).createFunction(method.requestManager);\n      var getGasPrice = new Method({\n        name: 'getGasPrice',\n        call: 'eth_gasPrice',\n        params: 0\n      }).createFunction(method.requestManager);\n      Promise.all([getBlockByNumber(), getGasPrice()]).then(responses => {\n        const [block, gasPrice] = responses;\n\n        if ((tx.type === '0x2' || tx.type === undefined) && block && block.baseFeePerGas) {\n          // The network supports EIP-1559\n          // Taken from https://github.com/ethers-io/ethers.js/blob/ba6854bdd5a912fe873d5da494cb5c62c190adde/packages/abstract-provider/src.ts/index.ts#L230\n          let maxPriorityFeePerGas, maxFeePerGas;\n\n          if (tx.gasPrice) {\n            // Using legacy gasPrice property on an eip-1559 network,\n            // so use gasPrice as both fee properties\n            maxPriorityFeePerGas = tx.gasPrice;\n            maxFeePerGas = tx.gasPrice;\n            delete tx.gasPrice;\n          } else {\n            maxPriorityFeePerGas = tx.maxPriorityFeePerGas || '0x9502F900'; // 2.5 Gwei\n\n            maxFeePerGas = tx.maxFeePerGas || utils.toHex(utils.toBN(block.baseFeePerGas).mul(utils.toBN(2)).add(utils.toBN(maxPriorityFeePerGas)));\n          }\n\n          resolve({\n            maxFeePerGas,\n            maxPriorityFeePerGas\n          });\n        } else {\n          if (tx.maxPriorityFeePerGas || tx.maxFeePerGas) throw Error(\"Network doesn't support eip-1559\");\n          resolve({\n            gasPrice\n          });\n        }\n      });\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n/**\r\n * Returns the revert reason string if existing or otherwise false.\r\n *\r\n * @method getRevertReason\r\n *\r\n * @param {Object} txOptions\r\n * @param {Number} blockNumber\r\n *\r\n * @returns {Promise<Boolean|String>}\r\n */\n\n\nMethod.prototype.getRevertReason = function (txOptions, blockNumber) {\n  var self = this;\n  return new Promise(function (resolve, reject) {\n    new Method({\n      name: 'call',\n      call: 'eth_call',\n      params: 2,\n      abiCoder: self.abiCoder,\n      handleRevert: true\n    }).createFunction(self.requestManager)(txOptions, utils.numberToHex(blockNumber)).then(function () {\n      resolve(false);\n    }).catch(function (error) {\n      if (error.reason) {\n        resolve({\n          reason: error.reason,\n          signature: error.signature\n        });\n      } else {\n        reject(error);\n      }\n    });\n  });\n};\n/**\r\n * Checks if the given hex string is a revert message from the EVM\r\n *\r\n * @method isRevertReasonString\r\n *\r\n * @param {String} data - Hex string prefixed with 0x\r\n *\r\n * @returns {Boolean}\r\n */\n\n\nMethod.prototype.isRevertReasonString = function (data) {\n  return typeof data === 'string' && (data.length - 2) / 2 % 32 === 4 && data.substring(0, 10) === '0x08c379a0';\n};\n/**\r\n * Should be called to create the pure JSONRPC request which can be used in a batch request\r\n *\r\n * @method request\r\n * @return {Object} jsonrpc request\r\n */\n\n\nMethod.prototype.request = function () {\n  var payload = this.toPayload(Array.prototype.slice.call(arguments));\n  payload.format = this.formatOutput.bind(this);\n  return payload;\n};\n\nmodule.exports = Method;","map":{"version":3,"names":["errors","require","formatters","utils","promiEvent","Subscriptions","subscriptions","EthersTransactionUtils","Method","options","call","name","Error","params","inputFormatter","outputFormatter","transformPayload","extraFormatters","abiCoder","requestManager","accounts","defaultBlock","defaultAccount","transactionBlockTimeout","transactionConfirmationBlocks","transactionPollingTimeout","transactionPollingInterval","blockHeaderTimeout","defaultCommon","defaultChain","defaultHardfork","handleRevert","prototype","setRequestManager","createFunction","func","buildCall","attachToObject","obj","split","length","getCall","args","extractCallback","pop","validateArgs","InvalidNumberOfParams","formatInput","_this","map","formatter","index","formatOutput","result","Array","isArray","res","toPayload","callback","payload","method","_confirmTransaction","defer","promiseResolved","canUnsubscribe","timeoutCount","confirmationCount","intervalId","blockHeaderTimeoutId","lastBlock","receiptJSON","gasProvided","gas","isContractDeployment","data","from","to","hasBytecode","_ethereumCalls","inputBlockNumberFormatter","val","outputBlockFormatter","outputTransactionReceiptFormatter","inputAddressFormatter","inputDefaultBlockNumberFormatter","outputTransactionFormatter","type","subscriptionName","_ethereumCall","forEach","mthd","checkConfirmation","existingReceipt","isPolling","err","blockHeader","sub","unsubscribe","clearInterval","clearTimeout","resolve","getTransactionReceipt","catch","_fireError","message","eventEmitter","reject","then","receipt","blockHash","receiptFormatter","listeners","block","undefined","latestBlock","getBlockByNumber","latestBlockHash","hash","number","emit","blockNumber","removeAllListeners","contractAddress","NoContractAddressFoundError","code","getCode","deploymentSuccess","status","contractDeployFormatter","ContractCodeNotStoredError","outOfGas","gasUsed","JSON","stringify","revertMessage","txReplayOptions","rawTransactionHex","parsedTx","parse","inputTransactionFormatter","gasLimit","toHexString","gasPrice","value","getRevertReason","TransactionRevertInstructionError","reason","signature","error","TransactionRevertedWithoutReasonError","TransactionOutOfGasError","TransactionError","startWatching","blockHeaderArrived","startInterval","setInterval","bind","provider","on","subscribe","setTimeout","getWallet","wallet","address","privateKey","toLowerCase","isSendTx","isCall","send","slice","arguments","sendTxCallback","reasonData","isRevertReasonString","substring","decodeParameter","RevertInstructionError","e","sendSignedTx","sign","signedPayload","rawTransaction","sendRequest","tx","chain","hardfork","common","signTransaction","maxPriorityFeePerGas","maxFeePerGas","_handleTxPricing","txPricing","request","Promise","toHex","getGasPrice","all","responses","baseFeePerGas","toBN","mul","add","txOptions","self","numberToHex","format","module","exports"],"sources":["D:/BlockchainSafetyManagement/client/node_modules/web3-core-method/lib/index.js"],"sourcesContent":["/*\r\n    This file is part of web3.js.\r\n\r\n    web3.js is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU Lesser General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    web3.js is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU Lesser General Public License for more details.\r\n\r\n    You should have received a copy of the GNU Lesser General Public License\r\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n/**\r\n * @file index.js\r\n * @author Fabian Vogelsteller <fabian@ethereum.org>\r\n * @author Marek Kotewicz <marek@parity.io>\r\n * @date 2017\r\n */\r\n'use strict';\r\nvar errors = require('web3-core-helpers').errors;\r\nvar formatters = require('web3-core-helpers').formatters;\r\nvar utils = require('web3-utils');\r\nvar promiEvent = require('web3-core-promievent');\r\nvar Subscriptions = require('web3-core-subscriptions').subscriptions;\r\nvar EthersTransactionUtils = require('@ethersproject/transactions');\r\nvar Method = function Method(options) {\r\n    if (!options.call || !options.name) {\r\n        throw new Error('When creating a method you need to provide at least the \"name\" and \"call\" property.');\r\n    }\r\n    this.name = options.name;\r\n    this.call = options.call;\r\n    this.params = options.params || 0;\r\n    this.inputFormatter = options.inputFormatter;\r\n    this.outputFormatter = options.outputFormatter;\r\n    this.transformPayload = options.transformPayload;\r\n    this.extraFormatters = options.extraFormatters;\r\n    this.abiCoder = options.abiCoder; // Will be used to encode the revert reason string\r\n    this.requestManager = options.requestManager;\r\n    // reference to eth.accounts\r\n    this.accounts = options.accounts;\r\n    this.defaultBlock = options.defaultBlock || 'latest';\r\n    this.defaultAccount = options.defaultAccount || null;\r\n    this.transactionBlockTimeout = options.transactionBlockTimeout || 50;\r\n    this.transactionConfirmationBlocks = options.transactionConfirmationBlocks || 24;\r\n    this.transactionPollingTimeout = options.transactionPollingTimeout || 750;\r\n    this.transactionPollingInterval = options.transactionPollingInterval || 1000;\r\n    this.blockHeaderTimeout = options.blockHeaderTimeout || 10; // 10 seconds\r\n    this.defaultCommon = options.defaultCommon;\r\n    this.defaultChain = options.defaultChain;\r\n    this.defaultHardfork = options.defaultHardfork;\r\n    this.handleRevert = options.handleRevert;\r\n};\r\nMethod.prototype.setRequestManager = function (requestManager, accounts) {\r\n    this.requestManager = requestManager;\r\n    // reference to eth.accounts\r\n    if (accounts) {\r\n        this.accounts = accounts;\r\n    }\r\n};\r\nMethod.prototype.createFunction = function (requestManager, accounts) {\r\n    var func = this.buildCall();\r\n    func.call = this.call;\r\n    this.setRequestManager(requestManager || this.requestManager, accounts || this.accounts);\r\n    return func;\r\n};\r\nMethod.prototype.attachToObject = function (obj) {\r\n    var func = this.buildCall();\r\n    func.call = this.call;\r\n    var name = this.name.split('.');\r\n    if (name.length > 1) {\r\n        obj[name[0]] = obj[name[0]] || {};\r\n        obj[name[0]][name[1]] = func;\r\n    }\r\n    else {\r\n        obj[name[0]] = func;\r\n    }\r\n};\r\n/**\r\n * Should be used to determine name of the jsonrpc method based on arguments\r\n *\r\n * @method getCall\r\n * @param {Array} arguments\r\n * @return {String} name of jsonrpc method\r\n */\r\nMethod.prototype.getCall = function (args) {\r\n    return typeof this.call === 'function' ? this.call(args) : this.call;\r\n};\r\n/**\r\n * Should be used to extract callback from array of arguments. Modifies input param\r\n *\r\n * @method extractCallback\r\n * @param {Array} arguments\r\n * @return {Function|Null} callback, if exists\r\n */\r\nMethod.prototype.extractCallback = function (args) {\r\n    if (typeof (args[args.length - 1]) === 'function') {\r\n        return args.pop(); // modify the args array!\r\n    }\r\n};\r\n/**\r\n * Should be called to check if the number of arguments is correct\r\n *\r\n * @method validateArgs\r\n * @param {Array} arguments\r\n * @throws {Error} if it is not\r\n */\r\nMethod.prototype.validateArgs = function (args) {\r\n    if (args.length !== this.params) {\r\n        throw errors.InvalidNumberOfParams(args.length, this.params, this.name);\r\n    }\r\n};\r\n/**\r\n * Should be called to format input args of method\r\n *\r\n * @method formatInput\r\n * @param {Array}\r\n * @return {Array}\r\n */\r\nMethod.prototype.formatInput = function (args) {\r\n    var _this = this;\r\n    if (!this.inputFormatter) {\r\n        return args;\r\n    }\r\n    return this.inputFormatter.map(function (formatter, index) {\r\n        // bind this for defaultBlock, and defaultAccount\r\n        return formatter ? formatter.call(_this, args[index]) : args[index];\r\n    });\r\n};\r\n/**\r\n * Should be called to format output(result) of method\r\n *\r\n * @method formatOutput\r\n * @param {Object}\r\n * @return {Object}\r\n */\r\nMethod.prototype.formatOutput = function (result) {\r\n    var _this = this;\r\n    if (Array.isArray(result)) {\r\n        return result.map(function (res) {\r\n            return _this.outputFormatter && res ? _this.outputFormatter(res) : res;\r\n        });\r\n    }\r\n    else {\r\n        return this.outputFormatter && result ? this.outputFormatter(result) : result;\r\n    }\r\n};\r\n/**\r\n * Should create payload from given input args\r\n *\r\n * @method toPayload\r\n * @param {Array} args\r\n * @return {Object}\r\n */\r\nMethod.prototype.toPayload = function (args) {\r\n    var call = this.getCall(args);\r\n    var callback = this.extractCallback(args);\r\n    var params = this.formatInput(args);\r\n    this.validateArgs(params);\r\n    var payload = {\r\n        method: call,\r\n        params: params,\r\n        callback: callback\r\n    };\r\n    if (this.transformPayload) {\r\n        payload = this.transformPayload(payload);\r\n    }\r\n    return payload;\r\n};\r\nMethod.prototype._confirmTransaction = function (defer, result, payload) {\r\n    var method = this, promiseResolved = false, canUnsubscribe = true, timeoutCount = 0, confirmationCount = 0, intervalId = null, blockHeaderTimeoutId = null, lastBlock = null, receiptJSON = '', gasProvided = ((!!payload.params[0] && typeof payload.params[0] === 'object') && payload.params[0].gas) ? payload.params[0].gas : null, isContractDeployment = (!!payload.params[0] && typeof payload.params[0] === 'object') &&\r\n        payload.params[0].data &&\r\n        payload.params[0].from &&\r\n        !payload.params[0].to, hasBytecode = isContractDeployment && payload.params[0].data.length > 2;\r\n    // add custom send Methods\r\n    var _ethereumCalls = [\r\n        new Method({\r\n            name: 'getBlockByNumber',\r\n            call: 'eth_getBlockByNumber',\r\n            params: 2,\r\n            inputFormatter: [formatters.inputBlockNumberFormatter, function (val) {\r\n                    return !!val;\r\n                }],\r\n            outputFormatter: formatters.outputBlockFormatter\r\n        }),\r\n        new Method({\r\n            name: 'getTransactionReceipt',\r\n            call: 'eth_getTransactionReceipt',\r\n            params: 1,\r\n            inputFormatter: [null],\r\n            outputFormatter: formatters.outputTransactionReceiptFormatter\r\n        }),\r\n        new Method({\r\n            name: 'getCode',\r\n            call: 'eth_getCode',\r\n            params: 2,\r\n            inputFormatter: [formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter]\r\n        }),\r\n        new Method({\r\n            name: 'getTransactionByHash',\r\n            call: 'eth_getTransactionByHash',\r\n            params: 1,\r\n            inputFormatter: [null],\r\n            outputFormatter: formatters.outputTransactionFormatter\r\n        }),\r\n        new Subscriptions({\r\n            name: 'subscribe',\r\n            type: 'eth',\r\n            subscriptions: {\r\n                'newBlockHeaders': {\r\n                    subscriptionName: 'newHeads',\r\n                    params: 0,\r\n                    outputFormatter: formatters.outputBlockFormatter\r\n                }\r\n            }\r\n        })\r\n    ];\r\n    // attach methods to this._ethereumCall\r\n    var _ethereumCall = {};\r\n    _ethereumCalls.forEach(mthd => {\r\n        mthd.attachToObject(_ethereumCall);\r\n        mthd.requestManager = method.requestManager; // assign rather than call setRequestManager()\r\n    });\r\n    // fire \"receipt\" and confirmation events and resolve after\r\n    var checkConfirmation = function (existingReceipt, isPolling, err, blockHeader, sub) {\r\n        if (!err) {\r\n            // create fake unsubscribe\r\n            if (!sub) {\r\n                sub = {\r\n                    unsubscribe: function () {\r\n                        clearInterval(intervalId);\r\n                        clearTimeout(blockHeaderTimeoutId);\r\n                    }\r\n                };\r\n            }\r\n            // if we have a valid receipt we don't need to send a request\r\n            return (existingReceipt ? promiEvent.resolve(existingReceipt) : _ethereumCall.getTransactionReceipt(result))\r\n                // catch error from requesting receipt\r\n                .catch(function (err) {\r\n                sub.unsubscribe();\r\n                promiseResolved = true;\r\n                utils._fireError({\r\n                    message: 'Failed to check for transaction receipt:',\r\n                    data: err\r\n                }, defer.eventEmitter, defer.reject);\r\n            })\r\n                // if CONFIRMATION listener exists check for confirmations, by setting canUnsubscribe = false\r\n                .then(async function (receipt) {\r\n                if (!receipt || !receipt.blockHash) {\r\n                    throw new Error('Receipt missing or blockHash null');\r\n                }\r\n                // apply extra formatters\r\n                if (method.extraFormatters && method.extraFormatters.receiptFormatter) {\r\n                    receipt = method.extraFormatters.receiptFormatter(receipt);\r\n                }\r\n                // check if confirmation listener exists\r\n                if (defer.eventEmitter.listeners('confirmation').length > 0) {\r\n                    var block;\r\n                    // If there was an immediately retrieved receipt, it's already\r\n                    // been confirmed by the direct call to checkConfirmation needed\r\n                    // for parity instant-seal\r\n                    if (existingReceipt === undefined || confirmationCount !== 0) {\r\n                        // Get latest block to emit with confirmation\r\n                        var latestBlock = await _ethereumCall.getBlockByNumber('latest');\r\n                        var latestBlockHash = latestBlock ? latestBlock.hash : null;\r\n                        if (isPolling) { // Check if actually a new block is existing on polling\r\n                            if (lastBlock) {\r\n                                block = await _ethereumCall.getBlockByNumber(lastBlock.number + 1);\r\n                                if (block) {\r\n                                    lastBlock = block;\r\n                                    defer.eventEmitter.emit('confirmation', confirmationCount, receipt, latestBlockHash);\r\n                                }\r\n                            }\r\n                            else {\r\n                                block = await _ethereumCall.getBlockByNumber(receipt.blockNumber);\r\n                                lastBlock = block;\r\n                                defer.eventEmitter.emit('confirmation', confirmationCount, receipt, latestBlockHash);\r\n                            }\r\n                        }\r\n                        else {\r\n                            defer.eventEmitter.emit('confirmation', confirmationCount, receipt, latestBlockHash);\r\n                        }\r\n                    }\r\n                    if ((isPolling && block) || !isPolling) {\r\n                        confirmationCount++;\r\n                    }\r\n                    canUnsubscribe = false;\r\n                    if (confirmationCount === method.transactionConfirmationBlocks + 1) { // add 1 so we account for conf 0\r\n                        sub.unsubscribe();\r\n                        defer.eventEmitter.removeAllListeners();\r\n                    }\r\n                }\r\n                return receipt;\r\n            })\r\n                // CHECK for CONTRACT DEPLOYMENT\r\n                .then(async function (receipt) {\r\n                if (isContractDeployment && !promiseResolved) {\r\n                    if (!receipt.contractAddress) {\r\n                        if (canUnsubscribe) {\r\n                            sub.unsubscribe();\r\n                            promiseResolved = true;\r\n                        }\r\n                        utils._fireError(errors.NoContractAddressFoundError(receipt), defer.eventEmitter, defer.reject, null, receipt);\r\n                        return;\r\n                    }\r\n                    var code;\r\n                    try {\r\n                        code = await _ethereumCall.getCode(receipt.contractAddress);\r\n                    }\r\n                    catch (err) {\r\n                        // ignore;\r\n                    }\r\n                    if (!code) {\r\n                        return;\r\n                    }\r\n                    // If deployment is status.true and there was a real\r\n                    // bytecode string, assume it was successful.\r\n                    var deploymentSuccess = receipt.status === true && hasBytecode;\r\n                    if (deploymentSuccess || code.length > 2) {\r\n                        defer.eventEmitter.emit('receipt', receipt);\r\n                        // if contract, return instance instead of receipt\r\n                        if (method.extraFormatters && method.extraFormatters.contractDeployFormatter) {\r\n                            defer.resolve(method.extraFormatters.contractDeployFormatter(receipt));\r\n                        }\r\n                        else {\r\n                            defer.resolve(receipt);\r\n                        }\r\n                        // need to remove listeners, as they aren't removed automatically when succesfull\r\n                        if (canUnsubscribe) {\r\n                            defer.eventEmitter.removeAllListeners();\r\n                        }\r\n                    }\r\n                    else {\r\n                        utils._fireError(errors.ContractCodeNotStoredError(receipt), defer.eventEmitter, defer.reject, null, receipt);\r\n                    }\r\n                    if (canUnsubscribe) {\r\n                        sub.unsubscribe();\r\n                    }\r\n                    promiseResolved = true;\r\n                }\r\n                return receipt;\r\n            })\r\n                // CHECK for normal tx check for receipt only\r\n                .then(async function (receipt) {\r\n                if (!isContractDeployment && !promiseResolved) {\r\n                    if (!receipt.outOfGas &&\r\n                        (!gasProvided || gasProvided !== receipt.gasUsed) &&\r\n                        (receipt.status === true || receipt.status === '0x1' || typeof receipt.status === 'undefined')) {\r\n                        defer.eventEmitter.emit('receipt', receipt);\r\n                        defer.resolve(receipt);\r\n                        // need to remove listeners, as they aren't removed automatically when succesfull\r\n                        if (canUnsubscribe) {\r\n                            defer.eventEmitter.removeAllListeners();\r\n                        }\r\n                    }\r\n                    else {\r\n                        receiptJSON = JSON.stringify(receipt, null, 2);\r\n                        if (receipt.status === false || receipt.status === '0x0') {\r\n                            try {\r\n                                var revertMessage = null;\r\n                                if (method.handleRevert &&\r\n                                    (method.call === 'eth_sendTransaction' || method.call === 'eth_sendRawTransaction')) {\r\n                                    var txReplayOptions = payload.params[0];\r\n                                    // If send was raw, fetch the transaction and reconstitute the\r\n                                    // original params so they can be replayed with `eth_call`\r\n                                    if (method.call === 'eth_sendRawTransaction') {\r\n                                        var rawTransactionHex = payload.params[0];\r\n                                        var parsedTx = EthersTransactionUtils.parse(rawTransactionHex);\r\n                                        txReplayOptions = formatters.inputTransactionFormatter({\r\n                                            data: parsedTx.data,\r\n                                            to: parsedTx.to,\r\n                                            from: parsedTx.from,\r\n                                            gas: parsedTx.gasLimit.toHexString(),\r\n                                            gasPrice: parsedTx.gasPrice.toHexString(),\r\n                                            value: parsedTx.value.toHexString()\r\n                                        });\r\n                                    }\r\n                                    // Get revert reason string with eth_call\r\n                                    revertMessage = await method.getRevertReason(txReplayOptions, receipt.blockNumber);\r\n                                    if (revertMessage) { // Only throw a revert error if a revert reason is existing\r\n                                        utils._fireError(errors.TransactionRevertInstructionError(revertMessage.reason, revertMessage.signature, receipt), defer.eventEmitter, defer.reject, null, receipt);\r\n                                    }\r\n                                    else {\r\n                                        throw false; // Throw false and let the try/catch statement handle the error correctly after\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    throw false; // Throw false and let the try/catch statement handle the error correctly after\r\n                                }\r\n                            }\r\n                            catch (error) {\r\n                                // Throw an normal revert error if no revert reason is given or the detection of it is disabled\r\n                                utils._fireError(errors.TransactionRevertedWithoutReasonError(receipt), defer.eventEmitter, defer.reject, null, receipt);\r\n                            }\r\n                        }\r\n                        else {\r\n                            // Throw OOG if status is not existing and provided gas and used gas are equal\r\n                            utils._fireError(errors.TransactionOutOfGasError(receipt), defer.eventEmitter, defer.reject, null, receipt);\r\n                        }\r\n                    }\r\n                    if (canUnsubscribe) {\r\n                        sub.unsubscribe();\r\n                    }\r\n                    promiseResolved = true;\r\n                }\r\n            })\r\n                // time out the transaction if not mined after 50 blocks\r\n                .catch(function () {\r\n                timeoutCount++;\r\n                // check to see if we are http polling\r\n                if (!!isPolling) {\r\n                    // polling timeout is different than transactionBlockTimeout blocks since we are triggering every second\r\n                    if (timeoutCount - 1 >= method.transactionPollingTimeout) {\r\n                        sub.unsubscribe();\r\n                        promiseResolved = true;\r\n                        utils._fireError(errors.TransactionError('Transaction was not mined within ' + method.transactionPollingTimeout + ' seconds, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\r\n                    }\r\n                }\r\n                else {\r\n                    if (timeoutCount - 1 >= method.transactionBlockTimeout) {\r\n                        sub.unsubscribe();\r\n                        promiseResolved = true;\r\n                        utils._fireError(errors.TransactionError('Transaction was not mined within ' + method.transactionBlockTimeout + ' blocks, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            sub.unsubscribe();\r\n            promiseResolved = true;\r\n            utils._fireError({\r\n                message: 'Failed to subscribe to new newBlockHeaders to confirm the transaction receipts.',\r\n                data: err\r\n            }, defer.eventEmitter, defer.reject);\r\n        }\r\n    };\r\n    // start watching for confirmation depending on the support features of the provider\r\n    var startWatching = function (existingReceipt) {\r\n        let blockHeaderArrived = false;\r\n        const startInterval = () => {\r\n            intervalId = setInterval(checkConfirmation.bind(null, existingReceipt, true), method.transactionPollingInterval);\r\n        };\r\n        // If provider do not support event subscription use polling\r\n        if (!this.requestManager.provider.on) {\r\n            return startInterval();\r\n        }\r\n        // Subscribe to new block headers to look for tx receipt\r\n        _ethereumCall.subscribe('newBlockHeaders', function (err, blockHeader, sub) {\r\n            blockHeaderArrived = true;\r\n            if (err || !blockHeader) {\r\n                // fall back to polling\r\n                return startInterval();\r\n            }\r\n            checkConfirmation(existingReceipt, false, err, blockHeader, sub);\r\n        });\r\n        // Fallback to polling if tx receipt didn't arrived in \"blockHeaderTimeout\" [10 seconds]\r\n        blockHeaderTimeoutId = setTimeout(() => {\r\n            if (!blockHeaderArrived) {\r\n                startInterval();\r\n            }\r\n        }, this.blockHeaderTimeout * 1000);\r\n    }.bind(this);\r\n    // first check if we already have a confirmed transaction\r\n    _ethereumCall.getTransactionReceipt(result)\r\n        .then(function (receipt) {\r\n        if (receipt && receipt.blockHash) {\r\n            if (defer.eventEmitter.listeners('confirmation').length > 0) {\r\n                // We must keep on watching for new Blocks, if a confirmation listener is present\r\n                startWatching(receipt);\r\n            }\r\n            checkConfirmation(receipt, false);\r\n        }\r\n        else if (!promiseResolved) {\r\n            startWatching();\r\n        }\r\n    })\r\n        .catch(function () {\r\n        if (!promiseResolved)\r\n            startWatching();\r\n    });\r\n};\r\nvar getWallet = function (from, accounts) {\r\n    var wallet = null;\r\n    // is index given\r\n    if (typeof from === 'number') {\r\n        wallet = accounts.wallet[from];\r\n        // is account given\r\n    }\r\n    else if (!!from && typeof from === 'object' && from.address && from.privateKey) {\r\n        wallet = from;\r\n        // search in wallet for address\r\n    }\r\n    else {\r\n        wallet = accounts.wallet[from.toLowerCase()];\r\n    }\r\n    return wallet;\r\n};\r\nMethod.prototype.buildCall = function () {\r\n    var method = this, isSendTx = (method.call === 'eth_sendTransaction' || method.call === 'eth_sendRawTransaction'), // || method.call === 'personal_sendTransaction'\r\n    isCall = (method.call === 'eth_call');\r\n    // actual send function\r\n    var send = function () {\r\n        var defer = promiEvent(!isSendTx), payload = method.toPayload(Array.prototype.slice.call(arguments));\r\n        // CALLBACK function\r\n        var sendTxCallback = function (err, result) {\r\n            if (method.handleRevert && isCall && method.abiCoder) {\r\n                var reasonData;\r\n                // Ganache / Geth <= 1.9.13 return the reason data as a successful eth_call response\r\n                // Geth >= 1.9.15 attaches the reason data to an error object.\r\n                // Geth 1.9.14 is missing revert reason (https://github.com/ethereum/web3.js/issues/3520)\r\n                if (!err && method.isRevertReasonString(result)) {\r\n                    reasonData = result.substring(10);\r\n                }\r\n                else if (err && err.data) {\r\n                    reasonData = err.data.substring(10);\r\n                }\r\n                if (reasonData) {\r\n                    var reason = method.abiCoder.decodeParameter('string', '0x' + reasonData);\r\n                    var signature = 'Error(String)';\r\n                    utils._fireError(errors.RevertInstructionError(reason, signature), defer.eventEmitter, defer.reject, payload.callback, {\r\n                        reason: reason,\r\n                        signature: signature\r\n                    });\r\n                    return;\r\n                }\r\n            }\r\n            try {\r\n                result = method.formatOutput(result);\r\n            }\r\n            catch (e) {\r\n                err = e;\r\n            }\r\n            if (result instanceof Error) {\r\n                err = result;\r\n            }\r\n            if (!err) {\r\n                if (payload.callback) {\r\n                    payload.callback(null, result);\r\n                }\r\n            }\r\n            else {\r\n                if (err.error) {\r\n                    err = err.error;\r\n                }\r\n                return utils._fireError(err, defer.eventEmitter, defer.reject, payload.callback);\r\n            }\r\n            // return PROMISE\r\n            if (!isSendTx) {\r\n                if (!err) {\r\n                    defer.resolve(result);\r\n                }\r\n                // return PROMIEVENT\r\n            }\r\n            else {\r\n                defer.eventEmitter.emit('transactionHash', result);\r\n                method._confirmTransaction(defer, result, payload);\r\n            }\r\n        };\r\n        // SENDS the SIGNED SIGNATURE\r\n        var sendSignedTx = function (sign) {\r\n            var signedPayload = { ...payload,\r\n                method: 'eth_sendRawTransaction',\r\n                params: [sign.rawTransaction]\r\n            };\r\n            method.requestManager.send(signedPayload, sendTxCallback);\r\n        };\r\n        var sendRequest = function (payload, method) {\r\n            if (method && method.accounts && method.accounts.wallet && method.accounts.wallet.length) {\r\n                var wallet;\r\n                // ETH_SENDTRANSACTION\r\n                if (payload.method === 'eth_sendTransaction') {\r\n                    var tx = payload.params[0];\r\n                    wallet = getWallet((!!tx && typeof tx === 'object') ? tx.from : null, method.accounts);\r\n                    // If wallet was found, sign tx, and send using sendRawTransaction\r\n                    if (wallet && wallet.privateKey) {\r\n                        var tx = JSON.parse(JSON.stringify(tx));\r\n                        delete tx.from;\r\n                        if (method.defaultChain && !tx.chain) {\r\n                            tx.chain = method.defaultChain;\r\n                        }\r\n                        if (method.defaultHardfork && !tx.hardfork) {\r\n                            tx.hardfork = method.defaultHardfork;\r\n                        }\r\n                        if (method.defaultCommon && !tx.common) {\r\n                            tx.common = method.defaultCommon;\r\n                        }\r\n                        method.accounts.signTransaction(tx, wallet.privateKey)\r\n                            .then(sendSignedTx)\r\n                            .catch(function (err) {\r\n                            if (typeof defer.eventEmitter.listeners === 'function' && defer.eventEmitter.listeners('error').length) {\r\n                                try {\r\n                                    defer.eventEmitter.emit('error', err);\r\n                                }\r\n                                catch (err) {\r\n                                    // Ignore userland error prevent it to bubble up within web3.\r\n                                }\r\n                                defer.eventEmitter.removeAllListeners();\r\n                                defer.eventEmitter.catch(function () {\r\n                                });\r\n                            }\r\n                            defer.reject(err);\r\n                        });\r\n                        return;\r\n                    }\r\n                    // ETH_SIGN\r\n                }\r\n                else if (payload.method === 'eth_sign') {\r\n                    var data = payload.params[1];\r\n                    wallet = getWallet(payload.params[0], method.accounts);\r\n                    // If wallet was found, sign tx, and send using sendRawTransaction\r\n                    if (wallet && wallet.privateKey) {\r\n                        var sign = method.accounts.sign(data, wallet.privateKey);\r\n                        if (payload.callback) {\r\n                            payload.callback(null, sign.signature);\r\n                        }\r\n                        defer.resolve(sign.signature);\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            return method.requestManager.send(payload, sendTxCallback);\r\n        };\r\n        // Send the actual transaction\r\n        if (isSendTx\r\n            && !!payload.params[0]\r\n            && typeof payload.params[0] === 'object'\r\n            && (typeof payload.params[0].gasPrice === 'undefined'\r\n                && (typeof payload.params[0].maxPriorityFeePerGas === 'undefined'\r\n                    || typeof payload.params[0].maxFeePerGas === 'undefined'))) {\r\n            _handleTxPricing(method, payload.params[0]).then(txPricing => {\r\n                if (txPricing.gasPrice !== undefined) {\r\n                    payload.params[0].gasPrice = txPricing.gasPrice;\r\n                }\r\n                else if (txPricing.maxPriorityFeePerGas !== undefined\r\n                    && txPricing.maxFeePerGas !== undefined) {\r\n                    payload.params[0].maxPriorityFeePerGas = txPricing.maxPriorityFeePerGas;\r\n                    payload.params[0].maxFeePerGas = txPricing.maxFeePerGas;\r\n                }\r\n                if (isSendTx) {\r\n                    setTimeout(() => {\r\n                        defer.eventEmitter.emit('sending', payload);\r\n                    }, 0);\r\n                }\r\n                sendRequest(payload, method);\r\n            });\r\n        }\r\n        else {\r\n            if (isSendTx) {\r\n                setTimeout(() => {\r\n                    defer.eventEmitter.emit('sending', payload);\r\n                }, 0);\r\n            }\r\n            sendRequest(payload, method);\r\n        }\r\n        if (isSendTx) {\r\n            setTimeout(() => {\r\n                defer.eventEmitter.emit('sent', payload);\r\n            }, 0);\r\n        }\r\n        return defer.eventEmitter;\r\n    };\r\n    // necessary to attach things to the method\r\n    send.method = method;\r\n    // necessary for batch requests\r\n    send.request = this.request.bind(this);\r\n    return send;\r\n};\r\nfunction _handleTxPricing(method, tx) {\r\n    return new Promise((resolve, reject) => {\r\n        try {\r\n            var getBlockByNumber = (new Method({\r\n                name: 'getBlockByNumber',\r\n                call: 'eth_getBlockByNumber',\r\n                params: 2,\r\n                inputFormatter: [function (blockNumber) {\r\n                        return blockNumber ? utils.toHex(blockNumber) : 'latest';\r\n                    }, function () {\r\n                        return false;\r\n                    }]\r\n            })).createFunction(method.requestManager);\r\n            var getGasPrice = (new Method({\r\n                name: 'getGasPrice',\r\n                call: 'eth_gasPrice',\r\n                params: 0\r\n            })).createFunction(method.requestManager);\r\n            Promise.all([\r\n                getBlockByNumber(),\r\n                getGasPrice()\r\n            ]).then(responses => {\r\n                const [block, gasPrice] = responses;\r\n                if ((tx.type === '0x2' || tx.type === undefined) &&\r\n                    (block && block.baseFeePerGas)) {\r\n                    // The network supports EIP-1559\r\n                    // Taken from https://github.com/ethers-io/ethers.js/blob/ba6854bdd5a912fe873d5da494cb5c62c190adde/packages/abstract-provider/src.ts/index.ts#L230\r\n                    let maxPriorityFeePerGas, maxFeePerGas;\r\n                    if (tx.gasPrice) {\r\n                        // Using legacy gasPrice property on an eip-1559 network,\r\n                        // so use gasPrice as both fee properties\r\n                        maxPriorityFeePerGas = tx.gasPrice;\r\n                        maxFeePerGas = tx.gasPrice;\r\n                        delete tx.gasPrice;\r\n                    }\r\n                    else {\r\n                        maxPriorityFeePerGas = tx.maxPriorityFeePerGas || '0x9502F900'; // 2.5 Gwei\r\n                        maxFeePerGas = tx.maxFeePerGas ||\r\n                            utils.toHex(utils.toBN(block.baseFeePerGas)\r\n                                .mul(utils.toBN(2))\r\n                                .add(utils.toBN(maxPriorityFeePerGas)));\r\n                    }\r\n                    resolve({ maxFeePerGas, maxPriorityFeePerGas });\r\n                }\r\n                else {\r\n                    if (tx.maxPriorityFeePerGas || tx.maxFeePerGas)\r\n                        throw Error(\"Network doesn't support eip-1559\");\r\n                    resolve({ gasPrice });\r\n                }\r\n            });\r\n        }\r\n        catch (error) {\r\n            reject(error);\r\n        }\r\n    });\r\n}\r\n/**\r\n * Returns the revert reason string if existing or otherwise false.\r\n *\r\n * @method getRevertReason\r\n *\r\n * @param {Object} txOptions\r\n * @param {Number} blockNumber\r\n *\r\n * @returns {Promise<Boolean|String>}\r\n */\r\nMethod.prototype.getRevertReason = function (txOptions, blockNumber) {\r\n    var self = this;\r\n    return new Promise(function (resolve, reject) {\r\n        (new Method({\r\n            name: 'call',\r\n            call: 'eth_call',\r\n            params: 2,\r\n            abiCoder: self.abiCoder,\r\n            handleRevert: true\r\n        }))\r\n            .createFunction(self.requestManager)(txOptions, utils.numberToHex(blockNumber))\r\n            .then(function () {\r\n            resolve(false);\r\n        })\r\n            .catch(function (error) {\r\n            if (error.reason) {\r\n                resolve({\r\n                    reason: error.reason,\r\n                    signature: error.signature\r\n                });\r\n            }\r\n            else {\r\n                reject(error);\r\n            }\r\n        });\r\n    });\r\n};\r\n/**\r\n * Checks if the given hex string is a revert message from the EVM\r\n *\r\n * @method isRevertReasonString\r\n *\r\n * @param {String} data - Hex string prefixed with 0x\r\n *\r\n * @returns {Boolean}\r\n */\r\nMethod.prototype.isRevertReasonString = function (data) {\r\n    return typeof data === 'string' && ((data.length - 2) / 2) % 32 === 4 && data.substring(0, 10) === '0x08c379a0';\r\n};\r\n/**\r\n * Should be called to create the pure JSONRPC request which can be used in a batch request\r\n *\r\n * @method request\r\n * @return {Object} jsonrpc request\r\n */\r\nMethod.prototype.request = function () {\r\n    var payload = this.toPayload(Array.prototype.slice.call(arguments));\r\n    payload.format = this.formatOutput.bind(this);\r\n    return payload;\r\n};\r\nmodule.exports = Method;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}
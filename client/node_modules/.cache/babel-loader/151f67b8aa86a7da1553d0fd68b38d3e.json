{"ast":null,"code":"const Web3Shim = require(\"truffle-interface-adapter\").Web3Shim;\n\nconst utils = require(\"../utils\");\n\nconst execute = require(\"../execute\");\n\nconst bootstrap = require(\"./bootstrap\");\n\nmodule.exports = Contract => ({\n  setProvider(provider) {\n    if (!provider) {\n      throw new Error(`Invalid provider passed to setProvider(); provider is ${provider}`);\n    }\n\n    this.web3.setProvider(provider);\n    this.currentProvider = provider;\n  },\n\n  new() {\n    utils.checkProvider(this);\n\n    if (!this.bytecode || this.bytecode === \"0x\") {\n      throw new Error(`${this.contractName} error: contract binary not set. Can't deploy new instance.\\n` + `This contract may be abstract, not implement an abstract parent's methods completely\\n` + `or not invoke an inherited contract's constructor correctly\\n`);\n    }\n\n    var constructorABI = this.abi.filter(i => i.type === \"constructor\")[0];\n    return execute.deploy.call(this, constructorABI)(...arguments);\n  },\n\n  async at(address) {\n    if (address == null || typeof address !== \"string\" || address.length !== 42) {\n      throw new Error(`Invalid address passed to ${this.contractName}.at(): ${address}`);\n    }\n\n    try {\n      await this.detectNetwork();\n      const onChainCode = await this.web3.eth.getCode(address);\n      await utils.checkCode(onChainCode, this.contractName, address);\n      return new this(address);\n    } catch (error) {\n      throw error;\n    }\n  },\n\n  async deployed() {\n    try {\n      utils.checkProvider(this);\n      await this.detectNetwork();\n      utils.checkNetworkArtifactMatch(this);\n      utils.checkDeployment(this);\n      return new this(this.address);\n    } catch (error) {\n      throw error;\n    }\n  },\n\n  defaults(class_defaults) {\n    if (this.class_defaults == null) {\n      this.class_defaults = {};\n    }\n\n    if (class_defaults == null) {\n      class_defaults = {};\n    }\n\n    Object.keys(class_defaults).forEach(key => {\n      const value = class_defaults[key];\n      this.class_defaults[key] = value;\n    });\n    return this.class_defaults;\n  },\n\n  hasNetwork(network_id) {\n    return this._json.networks[`${network_id}`] != null;\n  },\n\n  isDeployed() {\n    if (this.network_id == null) {\n      return false;\n    }\n\n    if (this._json.networks[this.network_id] == null) {\n      return false;\n    }\n\n    return !!this.network.address;\n  },\n\n  async detectNetwork() {\n    // if artifacts already have a network_id and network configuration synced,\n    // use that network and use latest block gasLimit\n    if (this.network_id && this.networks[this.network_id] != null) {\n      try {\n        const {\n          gasLimit\n        } = await this.web3.eth.getBlock(\"latest\");\n        return {\n          id: this.network_id,\n          blockLimit: gasLimit\n        };\n      } catch (error) {\n        throw error;\n      }\n    } // since artifacts don't have a network_id synced with a network configuration,\n    // poll chain for network_id and sync artifacts\n\n\n    try {\n      const chainNetworkID = await this.web3.eth.net.getId();\n      const {\n        gasLimit\n      } = await this.web3.eth.getBlock(\"latest\");\n      return await utils.setInstanceNetworkID(this, chainNetworkID, gasLimit);\n    } catch (error) {\n      throw error;\n    }\n  },\n\n  setNetwork(network_id) {\n    if (!network_id) return;\n    this.network_id = `${network_id}`;\n  },\n\n  setNetworkType() {\n    let networkType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"ethereum\";\n\n    if (this.web3) {\n      this.web3.setNetworkType(networkType);\n    }\n\n    this.networkType = networkType;\n  },\n\n  setWallet(wallet) {\n    this.web3.eth.accounts.wallet = wallet;\n  },\n\n  // Overrides the deployed address to null.\n  // You must call this explicitly so you don't inadvertently do this otherwise.\n  resetAddress() {\n    delete this.network.address;\n  },\n\n  link(name, address) {\n    // Case: Contract.link(instance)\n    if (typeof name === \"function\") {\n      const contract = name;\n\n      if (contract.isDeployed() === false) {\n        throw new Error(\"Cannot link contract without an address.\");\n      }\n\n      this.link(contract.contractName, contract.address); // Merge events so this contract knows about library's events\n\n      Object.keys(contract.events).forEach(topic => {\n        this.network.events[topic] = contract.events[topic];\n      });\n      return;\n    } // Case: Contract.link({<libraryName>: <address>, ... })\n\n\n    if (typeof name === \"object\") {\n      const obj = name;\n      Object.keys(obj).forEach(name => {\n        const a = obj[name];\n        this.link(name, a);\n      });\n      return;\n    } // Case: Contract.link(<libraryName>, <address>)\n\n\n    if (this._json.networks[this.network_id] == null) {\n      this._json.networks[this.network_id] = {\n        events: {},\n        links: {}\n      };\n    }\n\n    this.network.links[name] = address;\n  },\n\n  // Note, this function can be called with two input types:\n  // 1. Object with a bunch of data; this data will be merged with the json data of contract being cloned.\n  // 2. network id; this will clone the contract and set a specific network id upon cloning.\n  clone(json) {\n    json = json || {};\n\n    const temp = function TruffleContract() {\n      this.constructor = temp;\n      return Contract.apply(this, arguments);\n    };\n\n    temp.prototype = Object.create(this.prototype);\n    let network_id; // If we have a network id passed\n\n    if (typeof json !== \"object\") {\n      network_id = json;\n      json = this._json;\n    }\n\n    json = utils.merge({}, this._json || {}, json);\n    temp._constructorMethods = this._constructorMethods;\n    temp._properties = this._properties;\n    temp._property_values = {};\n    temp._json = json;\n    bootstrap(temp);\n    temp.web3 = new Web3Shim({\n      type: temp.networkType\n    });\n    temp.class_defaults = temp.prototype.defaults || {};\n\n    if (network_id) {\n      temp.setNetwork(network_id);\n    } // Copy over custom key/values to the contract class\n\n\n    Object.keys(json).forEach(key => {\n      if (key.indexOf(\"x-\") !== 0) return;\n      temp[key] = json[key];\n    });\n    return temp;\n  },\n\n  addProp(key, fn) {\n    const getter = () => {\n      if (fn.get != null) {\n        return fn.get.call(this);\n      }\n\n      return this._property_values[key] || fn.call(this);\n    };\n\n    const setter = val => {\n      if (fn.set != null) {\n        fn.set.call(this, val);\n        return;\n      } // If there's not a setter, then the property is immutable.\n\n\n      throw new Error(`${key} property is immutable`);\n    };\n\n    const definition = {};\n    definition.enumerable = false;\n    definition.configurable = false;\n    definition.get = getter;\n    definition.set = setter;\n    Object.defineProperty(this, key, definition);\n  },\n\n  toJSON() {\n    return this._json;\n  },\n\n  decodeLogs: utils.decodeLogs\n});","map":{"version":3,"names":["Web3Shim","require","utils","execute","bootstrap","module","exports","Contract","setProvider","provider","Error","web3","currentProvider","new","checkProvider","bytecode","contractName","constructorABI","abi","filter","i","type","deploy","call","arguments","at","address","length","detectNetwork","onChainCode","eth","getCode","checkCode","error","deployed","checkNetworkArtifactMatch","checkDeployment","defaults","class_defaults","Object","keys","forEach","key","value","hasNetwork","network_id","_json","networks","isDeployed","network","gasLimit","getBlock","id","blockLimit","chainNetworkID","net","getId","setInstanceNetworkID","setNetwork","setNetworkType","networkType","setWallet","wallet","accounts","resetAddress","link","name","contract","events","topic","obj","a","links","clone","json","temp","TruffleContract","constructor","apply","prototype","create","merge","_constructorMethods","_properties","_property_values","indexOf","addProp","fn","getter","get","setter","val","set","definition","enumerable","configurable","defineProperty","toJSON","decodeLogs"],"sources":["C:/Users/mcnl/Desktop/gong/BlockchainSafetyManagement/client/node_modules/truffle-contract/lib/contract/constructorMethods.js"],"sourcesContent":["const Web3Shim = require(\"truffle-interface-adapter\").Web3Shim;\r\nconst utils = require(\"../utils\");\r\nconst execute = require(\"../execute\");\r\nconst bootstrap = require(\"./bootstrap\");\r\n\r\nmodule.exports = Contract => ({\r\n  setProvider(provider) {\r\n    if (!provider) {\r\n      throw new Error(\r\n        `Invalid provider passed to setProvider(); provider is ${provider}`\r\n      );\r\n    }\r\n\r\n    this.web3.setProvider(provider);\r\n    this.currentProvider = provider;\r\n  },\r\n\r\n  new() {\r\n    utils.checkProvider(this);\r\n\r\n    if (!this.bytecode || this.bytecode === \"0x\") {\r\n      throw new Error(\r\n        `${\r\n          this.contractName\r\n        } error: contract binary not set. Can't deploy new instance.\\n` +\r\n          `This contract may be abstract, not implement an abstract parent's methods completely\\n` +\r\n          `or not invoke an inherited contract's constructor correctly\\n`\r\n      );\r\n    }\r\n\r\n    var constructorABI = this.abi.filter(i => i.type === \"constructor\")[0];\r\n\r\n    return execute.deploy.call(this, constructorABI)(...arguments);\r\n  },\r\n\r\n  async at(address) {\r\n    if (\r\n      address == null ||\r\n      typeof address !== \"string\" ||\r\n      address.length !== 42\r\n    ) {\r\n      throw new Error(\r\n        `Invalid address passed to ${this.contractName}.at(): ${address}`\r\n      );\r\n    }\r\n\r\n    try {\r\n      await this.detectNetwork();\r\n      const onChainCode = await this.web3.eth.getCode(address);\r\n      await utils.checkCode(onChainCode, this.contractName, address);\r\n      return new this(address);\r\n    } catch (error) {\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  async deployed() {\r\n    try {\r\n      utils.checkProvider(this);\r\n      await this.detectNetwork();\r\n      utils.checkNetworkArtifactMatch(this);\r\n      utils.checkDeployment(this);\r\n      return new this(this.address);\r\n    } catch (error) {\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  defaults(class_defaults) {\r\n    if (this.class_defaults == null) {\r\n      this.class_defaults = {};\r\n    }\r\n\r\n    if (class_defaults == null) {\r\n      class_defaults = {};\r\n    }\r\n\r\n    Object.keys(class_defaults).forEach(key => {\r\n      const value = class_defaults[key];\r\n      this.class_defaults[key] = value;\r\n    });\r\n\r\n    return this.class_defaults;\r\n  },\r\n\r\n  hasNetwork(network_id) {\r\n    return this._json.networks[`${network_id}`] != null;\r\n  },\r\n\r\n  isDeployed() {\r\n    if (this.network_id == null) {\r\n      return false;\r\n    }\r\n\r\n    if (this._json.networks[this.network_id] == null) {\r\n      return false;\r\n    }\r\n\r\n    return !!this.network.address;\r\n  },\r\n\r\n  async detectNetwork() {\r\n    // if artifacts already have a network_id and network configuration synced,\r\n    // use that network and use latest block gasLimit\r\n    if (this.network_id && this.networks[this.network_id] != null) {\r\n      try {\r\n        const { gasLimit } = await this.web3.eth.getBlock(\"latest\");\r\n        return { id: this.network_id, blockLimit: gasLimit };\r\n      } catch (error) {\r\n        throw error;\r\n      }\r\n    }\r\n    // since artifacts don't have a network_id synced with a network configuration,\r\n    // poll chain for network_id and sync artifacts\r\n    try {\r\n      const chainNetworkID = await this.web3.eth.net.getId();\r\n      const { gasLimit } = await this.web3.eth.getBlock(\"latest\");\r\n      return await utils.setInstanceNetworkID(this, chainNetworkID, gasLimit);\r\n    } catch (error) {\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  setNetwork(network_id) {\r\n    if (!network_id) return;\r\n    this.network_id = `${network_id}`;\r\n  },\r\n\r\n  setNetworkType(networkType = \"ethereum\") {\r\n    if (this.web3) {\r\n      this.web3.setNetworkType(networkType);\r\n    }\r\n\r\n    this.networkType = networkType;\r\n  },\r\n\r\n  setWallet(wallet) {\r\n    this.web3.eth.accounts.wallet = wallet;\r\n  },\r\n\r\n  // Overrides the deployed address to null.\r\n  // You must call this explicitly so you don't inadvertently do this otherwise.\r\n  resetAddress() {\r\n    delete this.network.address;\r\n  },\r\n\r\n  link(name, address) {\r\n    // Case: Contract.link(instance)\r\n    if (typeof name === \"function\") {\r\n      const contract = name;\r\n\r\n      if (contract.isDeployed() === false) {\r\n        throw new Error(\"Cannot link contract without an address.\");\r\n      }\r\n\r\n      this.link(contract.contractName, contract.address);\r\n\r\n      // Merge events so this contract knows about library's events\r\n      Object.keys(contract.events).forEach(topic => {\r\n        this.network.events[topic] = contract.events[topic];\r\n      });\r\n\r\n      return;\r\n    }\r\n\r\n    // Case: Contract.link({<libraryName>: <address>, ... })\r\n    if (typeof name === \"object\") {\r\n      const obj = name;\r\n      Object.keys(obj).forEach(name => {\r\n        const a = obj[name];\r\n        this.link(name, a);\r\n      });\r\n      return;\r\n    }\r\n\r\n    // Case: Contract.link(<libraryName>, <address>)\r\n    if (this._json.networks[this.network_id] == null) {\r\n      this._json.networks[this.network_id] = {\r\n        events: {},\r\n        links: {}\r\n      };\r\n    }\r\n\r\n    this.network.links[name] = address;\r\n  },\r\n\r\n  // Note, this function can be called with two input types:\r\n  // 1. Object with a bunch of data; this data will be merged with the json data of contract being cloned.\r\n  // 2. network id; this will clone the contract and set a specific network id upon cloning.\r\n  clone(json) {\r\n    json = json || {};\r\n\r\n    const temp = function TruffleContract() {\r\n      this.constructor = temp;\r\n      return Contract.apply(this, arguments);\r\n    };\r\n\r\n    temp.prototype = Object.create(this.prototype);\r\n\r\n    let network_id;\r\n\r\n    // If we have a network id passed\r\n    if (typeof json !== \"object\") {\r\n      network_id = json;\r\n      json = this._json;\r\n    }\r\n\r\n    json = utils.merge({}, this._json || {}, json);\r\n\r\n    temp._constructorMethods = this._constructorMethods;\r\n    temp._properties = this._properties;\r\n\r\n    temp._property_values = {};\r\n    temp._json = json;\r\n\r\n    bootstrap(temp);\r\n\r\n    temp.web3 = new Web3Shim({\r\n      type: temp.networkType\r\n    });\r\n    temp.class_defaults = temp.prototype.defaults || {};\r\n\r\n    if (network_id) {\r\n      temp.setNetwork(network_id);\r\n    }\r\n\r\n    // Copy over custom key/values to the contract class\r\n    Object.keys(json).forEach(key => {\r\n      if (key.indexOf(\"x-\") !== 0) return;\r\n      temp[key] = json[key];\r\n    });\r\n\r\n    return temp;\r\n  },\r\n\r\n  addProp(key, fn) {\r\n    const getter = () => {\r\n      if (fn.get != null) {\r\n        return fn.get.call(this);\r\n      }\r\n\r\n      return this._property_values[key] || fn.call(this);\r\n    };\r\n\r\n    const setter = val => {\r\n      if (fn.set != null) {\r\n        fn.set.call(this, val);\r\n        return;\r\n      }\r\n\r\n      // If there's not a setter, then the property is immutable.\r\n      throw new Error(`${key} property is immutable`);\r\n    };\r\n\r\n    const definition = {};\r\n    definition.enumerable = false;\r\n    definition.configurable = false;\r\n    definition.get = getter;\r\n    definition.set = setter;\r\n\r\n    Object.defineProperty(this, key, definition);\r\n  },\r\n\r\n  toJSON() {\r\n    return this._json;\r\n  },\r\n\r\n  decodeLogs: utils.decodeLogs\r\n});\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}
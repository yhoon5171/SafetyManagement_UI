{"ast":null,"code":"// TODO: this is a temporary fix to hide those libraries from the browser. A\n// slightly better long-term solution would be to split this file into two,\n// separating the functions that are used on Node.js from the functions that\n// are used only on the browser.\nmodule.exports = function (_ref) {\n  var fs = _ref.fs,\n      files = _ref.files,\n      os = _ref.os,\n      path = _ref.path,\n      child_process = _ref.child_process,\n      mimetype = _ref.mimetype,\n      defaultArchives = _ref.defaultArchives,\n      request = _ref.request,\n      downloadUrl = _ref.downloadUrl,\n      bytes = _ref.bytes,\n      hash = _ref.hash,\n      pick = _ref.pick; // ∀ a . String -> JSON -> Map String a -o Map String a\n  //   Inserts a key/val pair in an object impurely.\n\n  var impureInsert = function impureInsert(key) {\n    return function (val) {\n      return function (map) {\n        return map[key] = val, map;\n      };\n    };\n  }; // String -> JSON -> Map String JSON\n  //   Merges an array of keys and an array of vals into an object.\n\n\n  var toMap = function toMap(keys) {\n    return function (vals) {\n      var map = {};\n\n      for (var i = 0, l = keys.length; i < l; ++i) {\n        map[keys[i]] = vals[i];\n      }\n\n      return map;\n    };\n  }; // ∀ a . Map String a -> Map String a -> Map String a\n  //   Merges two maps into one.\n\n\n  var merge = function merge(a) {\n    return function (b) {\n      var map = {};\n\n      for (var key in a) {\n        map[key] = a[key];\n      }\n\n      for (var _key in b) {\n        map[_key] = b[_key];\n      }\n\n      return map;\n    };\n  }; // ∀ a . [a] -> [a] -> Bool\n\n\n  var equals = function equals(a) {\n    return function (b) {\n      if (a.length !== b.length) {\n        return false;\n      } else {\n        for (var i = 0, l = a.length; i < l; ++i) {\n          if (a[i] !== b[i]) return false;\n        }\n      }\n\n      return true;\n    };\n  }; // String -> String -> String\n\n\n  var rawUrl = function rawUrl(swarmUrl) {\n    return function (hash) {\n      return \"\".concat(swarmUrl, \"/bzzr:/\").concat(hash);\n    };\n  }; // String -> String -> Promise Uint8Array\n  //   Gets the raw contents of a Swarm hash address.\n\n\n  var downloadData = function downloadData(swarmUrl) {\n    return function (hash) {\n      return request(rawUrl(swarmUrl)(hash), {\n        responseType: \"arraybuffer\"\n      }).then(function (arrayBuffer) {\n        var uint8Array = new Uint8Array(arrayBuffer);\n        var error404 = [52, 48, 52, 32, 112, 97, 103, 101, 32, 110, 111, 116, 32, 102, 111, 117, 110, 100, 10];\n        if (equals(uint8Array)(error404)) throw \"Error 404.\";\n        return uint8Array;\n      });\n    };\n  }; // type Entry = {\"type\": String, \"hash\": String}\n  // type File = {\"type\": String, \"data\": Uint8Array}\n  // String -> String -> Promise (Map String Entry)\n  //   Solves the manifest of a Swarm address recursively.\n  //   Returns a map from full paths to entries.\n\n\n  var downloadEntries = function downloadEntries(swarmUrl) {\n    return function (hash) {\n      var search = function search(hash) {\n        return function (path) {\n          return function (routes) {\n            // Formats an entry to the Swarm.js type.\n            var format = function format(entry) {\n              return {\n                type: entry.contentType,\n                hash: entry.hash\n              };\n            }; // To download a single entry:\n            //   if type is bzz-manifest, go deeper\n            //   if not, add it to the routing table\n\n\n            var downloadEntry = function downloadEntry(entry) {\n              if (entry.path === undefined) {\n                return Promise.resolve();\n              } else {\n                return entry.contentType === \"application/bzz-manifest+json\" ? search(entry.hash)(path + entry.path)(routes) : Promise.resolve(impureInsert(path + entry.path)(format(entry))(routes));\n              }\n            }; // Downloads the initial manifest and then each entry.\n\n\n            return downloadData(swarmUrl)(hash).then(function (text) {\n              return JSON.parse(toString(text)).entries;\n            }).then(function (entries) {\n              return Promise.all(entries.map(downloadEntry));\n            }).then(function () {\n              return routes;\n            });\n          };\n        };\n      };\n\n      return search(hash)(\"\")({});\n    };\n  }; // String -> String -> Promise (Map String String)\n  //   Same as `downloadEntries`, but returns only hashes (no types).\n\n\n  var downloadRoutes = function downloadRoutes(swarmUrl) {\n    return function (hash) {\n      return downloadEntries(swarmUrl)(hash).then(function (entries) {\n        return toMap(Object.keys(entries))(Object.keys(entries).map(function (route) {\n          return entries[route].hash;\n        }));\n      });\n    };\n  }; // String -> String -> Promise (Map String File)\n  //   Gets the entire directory tree in a Swarm address.\n  //   Returns a promise mapping paths to file contents.\n\n\n  var downloadDirectory = function downloadDirectory(swarmUrl) {\n    return function (hash) {\n      return downloadEntries(swarmUrl)(hash).then(function (entries) {\n        var paths = Object.keys(entries);\n        var hashs = paths.map(function (path) {\n          return entries[path].hash;\n        });\n        var types = paths.map(function (path) {\n          return entries[path].type;\n        });\n        var datas = hashs.map(downloadData(swarmUrl));\n\n        var files = function files(datas) {\n          return datas.map(function (data, i) {\n            return {\n              type: types[i],\n              data: data\n            };\n          });\n        };\n\n        return Promise.all(datas).then(function (datas) {\n          return toMap(paths)(files(datas));\n        });\n      });\n    };\n  }; // String -> String -> String -> Promise String\n  //   Gets the raw contents of a Swarm hash address.\n  //   Returns a promise with the downloaded file path.\n\n\n  var downloadDataToDisk = function downloadDataToDisk(swarmUrl) {\n    return function (hash) {\n      return function (filePath) {\n        return files.download(rawUrl(swarmUrl)(hash))(filePath);\n      };\n    };\n  }; // String -> String -> String -> Promise (Map String String)\n  //   Gets the entire directory tree in a Swarm address.\n  //   Returns a promise mapping paths to file contents.\n\n\n  var downloadDirectoryToDisk = function downloadDirectoryToDisk(swarmUrl) {\n    return function (hash) {\n      return function (dirPath) {\n        return downloadRoutes(swarmUrl)(hash).then(function (routingTable) {\n          var downloads = [];\n\n          for (var route in routingTable) {\n            if (route.length > 0) {\n              var filePath = path.join(dirPath, route);\n              downloads.push(downloadDataToDisk(swarmUrl)(routingTable[route])(filePath));\n            }\n\n            ;\n          }\n\n          ;\n          return Promise.all(downloads).then(function () {\n            return dirPath;\n          });\n        });\n      };\n    };\n  }; // String -> Uint8Array -> Promise String\n  //   Uploads raw data to Swarm.\n  //   Returns a promise with the uploaded hash.\n\n\n  var uploadData = function uploadData(swarmUrl) {\n    return function (data) {\n      return request(\"\".concat(swarmUrl, \"/bzzr:/\"), {\n        body: typeof data === \"string\" ? fromString(data) : data,\n        method: \"POST\"\n      });\n    };\n  }; // String -> String -> String -> File -> Promise String\n  //   Uploads a file to the Swarm manifest at a given hash, under a specific\n  //   route. Returns a promise containing the uploaded hash.\n  //   FIXME: for some reasons Swarm-Gateways is sometimes returning\n  //   error 404 (bad request), so we retry up to 3 times. Why?\n\n\n  var uploadToManifest = function uploadToManifest(swarmUrl) {\n    return function (hash) {\n      return function (route) {\n        return function (file) {\n          var attempt = function attempt(n) {\n            var slashRoute = route[0] === \"/\" ? route : \"/\" + route;\n            var url = \"\".concat(swarmUrl, \"/bzz:/\").concat(hash).concat(slashRoute);\n            var opt = {\n              method: \"PUT\",\n              headers: {\n                \"Content-Type\": file.type\n              },\n              body: file.data\n            };\n            return request(url, opt).then(function (response) {\n              if (response.indexOf(\"error\") !== -1) {\n                throw response;\n              }\n\n              return response;\n            }).catch(function (e) {\n              return n > 0 && attempt(n - 1);\n            });\n          };\n\n          return attempt(3);\n        };\n      };\n    };\n  }; // String -> {type: String, data: Uint8Array} -> Promise String\n\n\n  var uploadFile = function uploadFile(swarmUrl) {\n    return function (file) {\n      return uploadDirectory(swarmUrl)({\n        \"\": file\n      });\n    };\n  }; // String -> String -> Promise String\n\n\n  var uploadFileFromDisk = function uploadFileFromDisk(swarmUrl) {\n    return function (filePath) {\n      return fs.readFile(filePath).then(function (data) {\n        return uploadFile(swarmUrl)({\n          type: mimetype.lookup(filePath),\n          data: data\n        });\n      });\n    };\n  }; // String -> Map String File -> Promise String\n  //   Uploads a directory to Swarm. The directory is\n  //   represented as a map of routes and files.\n  //   A default path is encoded by having a \"\" route.\n\n\n  var uploadDirectory = function uploadDirectory(swarmUrl) {\n    return function (directory) {\n      return uploadData(swarmUrl)(\"{}\").then(function (hash) {\n        var uploadRoute = function uploadRoute(route) {\n          return function (hash) {\n            return uploadToManifest(swarmUrl)(hash)(route)(directory[route]);\n          };\n        };\n\n        var uploadToHash = function uploadToHash(hash, route) {\n          return hash.then(uploadRoute(route));\n        };\n\n        return Object.keys(directory).reduce(uploadToHash, Promise.resolve(hash));\n      });\n    };\n  }; // String -> Promise String\n\n\n  var uploadDataFromDisk = function uploadDataFromDisk(swarmUrl) {\n    return function (filePath) {\n      return fs.readFile(filePath).then(uploadData(swarmUrl));\n    };\n  }; // String -> Nullable String -> String -> Promise String\n\n\n  var uploadDirectoryFromDisk = function uploadDirectoryFromDisk(swarmUrl) {\n    return function (defaultPath) {\n      return function (dirPath) {\n        return files.directoryTree(dirPath).then(function (fullPaths) {\n          return Promise.all(fullPaths.map(function (path) {\n            return fs.readFile(path);\n          })).then(function (datas) {\n            var paths = fullPaths.map(function (path) {\n              return path.slice(dirPath.length);\n            });\n            var types = fullPaths.map(function (path) {\n              return mimetype.lookup(path) || \"text/plain\";\n            });\n            return toMap(paths)(datas.map(function (data, i) {\n              return {\n                type: types[i],\n                data: data\n              };\n            }));\n          });\n        }).then(function (directory) {\n          return merge(defaultPath ? {\n            \"\": directory[defaultPath]\n          } : {})(directory);\n        }).then(uploadDirectory(swarmUrl));\n      };\n    };\n  }; // String -> UploadInfo -> Promise String\n  //   Simplified multi-type upload which calls the correct\n  //   one based on the type of the argument given.\n\n\n  var _upload = function upload(swarmUrl) {\n    return function (arg) {\n      // Upload raw data from browser\n      if (arg.pick === \"data\") {\n        return pick.data().then(uploadData(swarmUrl)); // Upload a file from browser\n      } else if (arg.pick === \"file\") {\n        return pick.file().then(uploadFile(swarmUrl)); // Upload a directory from browser\n      } else if (arg.pick === \"directory\") {\n        return pick.directory().then(uploadDirectory(swarmUrl)); // Upload directory/file from disk\n      } else if (arg.path) {\n        switch (arg.kind) {\n          case \"data\":\n            return uploadDataFromDisk(swarmUrl)(arg.path);\n\n          case \"file\":\n            return uploadFileFromDisk(swarmUrl)(arg.path);\n\n          case \"directory\":\n            return uploadDirectoryFromDisk(swarmUrl)(arg.defaultFile)(arg.path);\n        }\n\n        ; // Upload UTF-8 string or raw data (buffer)\n      } else if (arg.length || typeof arg === \"string\") {\n        return uploadData(swarmUrl)(arg); // Upload directory with JSON\n      } else if (arg instanceof Object) {\n        return uploadDirectory(swarmUrl)(arg);\n      }\n\n      return Promise.reject(new Error(\"Bad arguments\"));\n    };\n  }; // String -> String -> Nullable String -> Promise (String | Uint8Array | Map String Uint8Array)\n  //   Simplified multi-type download which calls the correct function based on\n  //   the type of the argument given, and on whether the Swwarm address has a\n  //   directory or a file.\n\n\n  var _download = function download(swarmUrl) {\n    return function (hash) {\n      return function (path) {\n        return isDirectory(swarmUrl)(hash).then(function (isDir) {\n          if (isDir) {\n            return path ? downloadDirectoryToDisk(swarmUrl)(hash)(path) : downloadDirectory(swarmUrl)(hash);\n          } else {\n            return path ? downloadDataToDisk(swarmUrl)(hash)(path) : downloadData(swarmUrl)(hash);\n          }\n        });\n      };\n    };\n  }; // String -> Promise String\n  //   Downloads the Swarm binaries into a path. Returns a promise that only\n  //   resolves when the exact Swarm file is there, and verified to be correct.\n  //   If it was already there to begin with, skips the download.\n\n\n  var downloadBinary = function downloadBinary(path, archives) {\n    var system = os.platform().replace(\"win32\", \"windows\") + \"-\" + (os.arch() === \"x64\" ? \"amd64\" : \"386\");\n    var archive = (archives || defaultArchives)[system];\n    var archiveUrl = downloadUrl + archive.archive + \".tar.gz\";\n    var archiveMD5 = archive.archiveMD5;\n    var binaryMD5 = archive.binaryMD5;\n    return files.safeDownloadArchived(archiveUrl)(archiveMD5)(binaryMD5)(path);\n  }; // type SwarmSetup = {\n  //   account : String,\n  //   password : String,\n  //   dataDir : String,\n  //   binPath : String,\n  //   ensApi : String,\n  //   onDownloadProgress : Number ~> (),\n  //   archives : [{\n  //     archive: String,\n  //     binaryMD5: String,\n  //     archiveMD5: String\n  //   }]\n  // }\n  // SwarmSetup ~> Promise Process\n  //   Starts the Swarm process.\n\n\n  var startProcess = function startProcess(swarmSetup) {\n    return new Promise(function (resolve, reject) {\n      var spawn = child_process.spawn;\n\n      var hasString = function hasString(str) {\n        return function (buffer) {\n          return ('' + buffer).indexOf(str) !== -1;\n        };\n      };\n\n      var account = swarmSetup.account,\n          password = swarmSetup.password,\n          dataDir = swarmSetup.dataDir,\n          ensApi = swarmSetup.ensApi,\n          privateKey = swarmSetup.privateKey;\n      var STARTUP_TIMEOUT_SECS = 3;\n      var WAITING_PASSWORD = 0;\n      var STARTING = 1;\n      var LISTENING = 2;\n      var PASSWORD_PROMPT_HOOK = \"Passphrase\";\n      var LISTENING_HOOK = \"Swarm http proxy started\";\n      var state = WAITING_PASSWORD;\n      var swarmProcess = spawn(swarmSetup.binPath, ['--bzzaccount', account || privateKey, '--datadir', dataDir, '--ens-api', ensApi]);\n\n      var handleProcessOutput = function handleProcessOutput(data) {\n        if (state === WAITING_PASSWORD && hasString(PASSWORD_PROMPT_HOOK)(data)) {\n          setTimeout(function () {\n            state = STARTING;\n            swarmProcess.stdin.write(password + '\\n');\n          }, 500);\n        } else if (hasString(LISTENING_HOOK)(data)) {\n          state = LISTENING;\n          clearTimeout(timeout);\n          resolve(swarmProcess);\n        }\n      };\n\n      swarmProcess.stdout.on('data', handleProcessOutput);\n      swarmProcess.stderr.on('data', handleProcessOutput); //swarmProcess.on('close', () => setTimeout(restart, 2000));\n\n      var restart = function restart() {\n        return startProcess(swarmSetup).then(resolve).catch(reject);\n      };\n\n      var error = function error() {\n        return reject(new Error(\"Couldn't start swarm process.\"));\n      };\n\n      var timeout = setTimeout(error, 20000);\n    });\n  }; // Process ~> Promise ()\n  //   Stops the Swarm process.\n\n\n  var stopProcess = function stopProcess(process) {\n    return new Promise(function (resolve, reject) {\n      process.stderr.removeAllListeners('data');\n      process.stdout.removeAllListeners('data');\n      process.stdin.removeAllListeners('error');\n      process.removeAllListeners('error');\n      process.removeAllListeners('exit');\n      process.kill('SIGINT');\n      var killTimeout = setTimeout(function () {\n        return process.kill('SIGKILL');\n      }, 8000);\n      process.once('close', function () {\n        clearTimeout(killTimeout);\n        resolve();\n      });\n    });\n  }; // SwarmSetup -> (SwarmAPI -> Promise ()) -> Promise ()\n  //   Receives a Swarm configuration object and a callback function. It then\n  //   checks if a local Swarm node is running. If no local Swarm is found, it\n  //   downloads the Swarm binaries to the dataDir (if not there), checksums,\n  //   starts the Swarm process and calls the callback function with an API\n  //   object using the local node. That callback must return a promise which\n  //   will resolve when it is done using the API, so that this function can\n  //   close the Swarm process properly. Returns a promise that resolves when the\n  //   user is done with the API and the Swarm process is closed.\n  //   TODO: check if Swarm process is already running (improve `isAvailable`)\n\n\n  var local = function local(swarmSetup) {\n    return function (useAPI) {\n      return _isAvailable(\"http://localhost:8500\").then(function (isAvailable) {\n        return isAvailable ? useAPI(at(\"http://localhost:8500\")).then(function () {}) : downloadBinary(swarmSetup.binPath, swarmSetup.archives).onData(function (data) {\n          return (swarmSetup.onProgress || function () {})(data.length);\n        }).then(function () {\n          return startProcess(swarmSetup);\n        }).then(function (process) {\n          return useAPI(at(\"http://localhost:8500\")).then(function () {\n            return process;\n          });\n        }).then(stopProcess);\n      });\n    };\n  }; // String ~> Promise Bool\n  //   Returns true if Swarm is available on `url`.\n  //   Perfoms a test upload to determine that.\n  //   TODO: improve this?\n\n\n  var _isAvailable = function isAvailable(swarmUrl) {\n    var testFile = \"test\";\n    var testHash = \"c9a99c7d326dcc6316f32fe2625b311f6dc49a175e6877681ded93137d3569e7\";\n    return uploadData(swarmUrl)(testFile).then(function (hash) {\n      return hash === testHash;\n    }).catch(function () {\n      return false;\n    });\n  }; // String -> String ~> Promise Bool\n  //   Returns a Promise which is true if that Swarm address is a directory.\n  //   Determines that by checking that it (i) is a JSON, (ii) has a .entries.\n  //   TODO: improve this?\n\n\n  var isDirectory = function isDirectory(swarmUrl) {\n    return function (hash) {\n      return downloadData(swarmUrl)(hash).then(function (data) {\n        try {\n          return !!JSON.parse(toString(data)).entries;\n        } catch (e) {\n          return false;\n        }\n      });\n    };\n  }; // Uncurries a function; used to allow the f(x,y,z) style on exports.\n\n\n  var uncurry = function uncurry(f) {\n    return function (a, b, c, d, e) {\n      var p; // Hardcoded because efficiency (`arguments` is very slow).\n\n      if (typeof a !== \"undefined\") p = f(a);\n      if (typeof b !== \"undefined\") p = f(b);\n      if (typeof c !== \"undefined\") p = f(c);\n      if (typeof d !== \"undefined\") p = f(d);\n      if (typeof e !== \"undefined\") p = f(e);\n      return p;\n    };\n  }; // () -> Promise Bool\n  //   Not sure how to mock Swarm to test it properly. Ideas?\n\n\n  var test = function test() {\n    return Promise.resolve(true);\n  }; // Uint8Array -> String\n\n\n  var toString = function toString(uint8Array) {\n    return bytes.toString(bytes.fromUint8Array(uint8Array));\n  }; // String -> Uint8Array\n\n\n  var fromString = function fromString(string) {\n    return bytes.toUint8Array(bytes.fromString(string));\n  }; // String -> SwarmAPI\n  //   Fixes the `swarmUrl`, returning an API where you don't have to pass it.\n\n\n  var at = function at(swarmUrl) {\n    return {\n      download: function download(hash, path) {\n        return _download(swarmUrl)(hash)(path);\n      },\n      downloadData: uncurry(downloadData(swarmUrl)),\n      downloadDataToDisk: uncurry(downloadDataToDisk(swarmUrl)),\n      downloadDirectory: uncurry(downloadDirectory(swarmUrl)),\n      downloadDirectoryToDisk: uncurry(downloadDirectoryToDisk(swarmUrl)),\n      downloadEntries: uncurry(downloadEntries(swarmUrl)),\n      downloadRoutes: uncurry(downloadRoutes(swarmUrl)),\n      isAvailable: function isAvailable() {\n        return _isAvailable(swarmUrl);\n      },\n      upload: function upload(arg) {\n        return _upload(swarmUrl)(arg);\n      },\n      uploadData: uncurry(uploadData(swarmUrl)),\n      uploadFile: uncurry(uploadFile(swarmUrl)),\n      uploadFileFromDisk: uncurry(uploadFile(swarmUrl)),\n      uploadDataFromDisk: uncurry(uploadDataFromDisk(swarmUrl)),\n      uploadDirectory: uncurry(uploadDirectory(swarmUrl)),\n      uploadDirectoryFromDisk: uncurry(uploadDirectoryFromDisk(swarmUrl)),\n      uploadToManifest: uncurry(uploadToManifest(swarmUrl)),\n      pick: pick,\n      hash: hash,\n      fromString: fromString,\n      toString: toString\n    };\n  };\n\n  return {\n    at: at,\n    local: local,\n    download: _download,\n    downloadBinary: downloadBinary,\n    downloadData: downloadData,\n    downloadDataToDisk: downloadDataToDisk,\n    downloadDirectory: downloadDirectory,\n    downloadDirectoryToDisk: downloadDirectoryToDisk,\n    downloadEntries: downloadEntries,\n    downloadRoutes: downloadRoutes,\n    isAvailable: _isAvailable,\n    startProcess: startProcess,\n    stopProcess: stopProcess,\n    upload: _upload,\n    uploadData: uploadData,\n    uploadDataFromDisk: uploadDataFromDisk,\n    uploadFile: uploadFile,\n    uploadFileFromDisk: uploadFileFromDisk,\n    uploadDirectory: uploadDirectory,\n    uploadDirectoryFromDisk: uploadDirectoryFromDisk,\n    uploadToManifest: uploadToManifest,\n    pick: pick,\n    hash: hash,\n    fromString: fromString,\n    toString: toString\n  };\n};","map":{"version":3,"names":["module","exports","_ref","fs","files","os","path","child_process","mimetype","defaultArchives","request","downloadUrl","bytes","hash","pick","impureInsert","key","val","map","toMap","keys","vals","i","l","length","merge","a","b","_key","equals","rawUrl","swarmUrl","concat","downloadData","responseType","then","arrayBuffer","uint8Array","Uint8Array","error404","downloadEntries","search","routes","format","entry","type","contentType","downloadEntry","undefined","Promise","resolve","text","JSON","parse","toString","entries","all","downloadRoutes","Object","route","downloadDirectory","paths","hashs","types","datas","data","downloadDataToDisk","filePath","download","downloadDirectoryToDisk","dirPath","routingTable","downloads","join","push","uploadData","body","fromString","method","uploadToManifest","file","attempt","n","slashRoute","url","opt","headers","response","indexOf","catch","e","uploadFile","uploadDirectory","uploadFileFromDisk","readFile","lookup","directory","uploadRoute","uploadToHash","reduce","uploadDataFromDisk","uploadDirectoryFromDisk","defaultPath","directoryTree","fullPaths","slice","_upload","upload","arg","kind","defaultFile","reject","Error","_download","isDirectory","isDir","downloadBinary","archives","system","platform","replace","arch","archive","archiveUrl","archiveMD5","binaryMD5","safeDownloadArchived","startProcess","swarmSetup","spawn","hasString","str","buffer","account","password","dataDir","ensApi","privateKey","STARTUP_TIMEOUT_SECS","WAITING_PASSWORD","STARTING","LISTENING","PASSWORD_PROMPT_HOOK","LISTENING_HOOK","state","swarmProcess","binPath","handleProcessOutput","setTimeout","stdin","write","clearTimeout","timeout","stdout","on","stderr","restart","error","stopProcess","process","removeAllListeners","kill","killTimeout","once","local","useAPI","_isAvailable","isAvailable","at","onData","onProgress","testFile","testHash","uncurry","f","c","d","p","test","fromUint8Array","string","toUint8Array"],"sources":["C:/Users/mcnl/Desktop/gong/BlockchainSafetyManagement/client/node_modules/truffle-interface-adapter/node_modules/swarm-js/lib/swarm.js"],"sourcesContent":["// TODO: this is a temporary fix to hide those libraries from the browser. A\r\n// slightly better long-term solution would be to split this file into two,\r\n// separating the functions that are used on Node.js from the functions that\r\n// are used only on the browser.\r\nmodule.exports = function (_ref) {\r\n  var fs = _ref.fs,\r\n      files = _ref.files,\r\n      os = _ref.os,\r\n      path = _ref.path,\r\n      child_process = _ref.child_process,\r\n      mimetype = _ref.mimetype,\r\n      defaultArchives = _ref.defaultArchives,\r\n      request = _ref.request,\r\n      downloadUrl = _ref.downloadUrl,\r\n      bytes = _ref.bytes,\r\n      hash = _ref.hash,\r\n      pick = _ref.pick;\r\n\r\n  // ∀ a . String -> JSON -> Map String a -o Map String a\r\n  //   Inserts a key/val pair in an object impurely.\r\n  var impureInsert = function impureInsert(key) {\r\n    return function (val) {\r\n      return function (map) {\r\n        return map[key] = val, map;\r\n      };\r\n    };\r\n  }; // String -> JSON -> Map String JSON\r\n  //   Merges an array of keys and an array of vals into an object.\r\n\r\n\r\n  var toMap = function toMap(keys) {\r\n    return function (vals) {\r\n      var map = {};\r\n\r\n      for (var i = 0, l = keys.length; i < l; ++i) {\r\n        map[keys[i]] = vals[i];\r\n      }\r\n\r\n      return map;\r\n    };\r\n  }; // ∀ a . Map String a -> Map String a -> Map String a\r\n  //   Merges two maps into one.\r\n\r\n\r\n  var merge = function merge(a) {\r\n    return function (b) {\r\n      var map = {};\r\n\r\n      for (var key in a) {\r\n        map[key] = a[key];\r\n      }\r\n\r\n      for (var _key in b) {\r\n        map[_key] = b[_key];\r\n      }\r\n\r\n      return map;\r\n    };\r\n  }; // ∀ a . [a] -> [a] -> Bool\r\n\r\n\r\n  var equals = function equals(a) {\r\n    return function (b) {\r\n      if (a.length !== b.length) {\r\n        return false;\r\n      } else {\r\n        for (var i = 0, l = a.length; i < l; ++i) {\r\n          if (a[i] !== b[i]) return false;\r\n        }\r\n      }\r\n\r\n      return true;\r\n    };\r\n  }; // String -> String -> String\r\n\r\n\r\n  var rawUrl = function rawUrl(swarmUrl) {\r\n    return function (hash) {\r\n      return \"\".concat(swarmUrl, \"/bzzr:/\").concat(hash);\r\n    };\r\n  }; // String -> String -> Promise Uint8Array\r\n  //   Gets the raw contents of a Swarm hash address.\r\n\r\n\r\n  var downloadData = function downloadData(swarmUrl) {\r\n    return function (hash) {\r\n      return request(rawUrl(swarmUrl)(hash), {\r\n        responseType: \"arraybuffer\"\r\n      }).then(function (arrayBuffer) {\r\n        var uint8Array = new Uint8Array(arrayBuffer);\r\n        var error404 = [52, 48, 52, 32, 112, 97, 103, 101, 32, 110, 111, 116, 32, 102, 111, 117, 110, 100, 10];\r\n        if (equals(uint8Array)(error404)) throw \"Error 404.\";\r\n        return uint8Array;\r\n      });\r\n    };\r\n  }; // type Entry = {\"type\": String, \"hash\": String}\r\n  // type File = {\"type\": String, \"data\": Uint8Array}\r\n  // String -> String -> Promise (Map String Entry)\r\n  //   Solves the manifest of a Swarm address recursively.\r\n  //   Returns a map from full paths to entries.\r\n\r\n\r\n  var downloadEntries = function downloadEntries(swarmUrl) {\r\n    return function (hash) {\r\n      var search = function search(hash) {\r\n        return function (path) {\r\n          return function (routes) {\r\n            // Formats an entry to the Swarm.js type.\r\n            var format = function format(entry) {\r\n              return {\r\n                type: entry.contentType,\r\n                hash: entry.hash\r\n              };\r\n            }; // To download a single entry:\r\n            //   if type is bzz-manifest, go deeper\r\n            //   if not, add it to the routing table\r\n\r\n\r\n            var downloadEntry = function downloadEntry(entry) {\r\n              if (entry.path === undefined) {\r\n                return Promise.resolve();\r\n              } else {\r\n                return entry.contentType === \"application/bzz-manifest+json\" ? search(entry.hash)(path + entry.path)(routes) : Promise.resolve(impureInsert(path + entry.path)(format(entry))(routes));\r\n              }\r\n            }; // Downloads the initial manifest and then each entry.\r\n\r\n\r\n            return downloadData(swarmUrl)(hash).then(function (text) {\r\n              return JSON.parse(toString(text)).entries;\r\n            }).then(function (entries) {\r\n              return Promise.all(entries.map(downloadEntry));\r\n            }).then(function () {\r\n              return routes;\r\n            });\r\n          };\r\n        };\r\n      };\r\n\r\n      return search(hash)(\"\")({});\r\n    };\r\n  }; // String -> String -> Promise (Map String String)\r\n  //   Same as `downloadEntries`, but returns only hashes (no types).\r\n\r\n\r\n  var downloadRoutes = function downloadRoutes(swarmUrl) {\r\n    return function (hash) {\r\n      return downloadEntries(swarmUrl)(hash).then(function (entries) {\r\n        return toMap(Object.keys(entries))(Object.keys(entries).map(function (route) {\r\n          return entries[route].hash;\r\n        }));\r\n      });\r\n    };\r\n  }; // String -> String -> Promise (Map String File)\r\n  //   Gets the entire directory tree in a Swarm address.\r\n  //   Returns a promise mapping paths to file contents.\r\n\r\n\r\n  var downloadDirectory = function downloadDirectory(swarmUrl) {\r\n    return function (hash) {\r\n      return downloadEntries(swarmUrl)(hash).then(function (entries) {\r\n        var paths = Object.keys(entries);\r\n        var hashs = paths.map(function (path) {\r\n          return entries[path].hash;\r\n        });\r\n        var types = paths.map(function (path) {\r\n          return entries[path].type;\r\n        });\r\n        var datas = hashs.map(downloadData(swarmUrl));\r\n\r\n        var files = function files(datas) {\r\n          return datas.map(function (data, i) {\r\n            return {\r\n              type: types[i],\r\n              data: data\r\n            };\r\n          });\r\n        };\r\n\r\n        return Promise.all(datas).then(function (datas) {\r\n          return toMap(paths)(files(datas));\r\n        });\r\n      });\r\n    };\r\n  }; // String -> String -> String -> Promise String\r\n  //   Gets the raw contents of a Swarm hash address.\r\n  //   Returns a promise with the downloaded file path.\r\n\r\n\r\n  var downloadDataToDisk = function downloadDataToDisk(swarmUrl) {\r\n    return function (hash) {\r\n      return function (filePath) {\r\n        return files.download(rawUrl(swarmUrl)(hash))(filePath);\r\n      };\r\n    };\r\n  }; // String -> String -> String -> Promise (Map String String)\r\n  //   Gets the entire directory tree in a Swarm address.\r\n  //   Returns a promise mapping paths to file contents.\r\n\r\n\r\n  var downloadDirectoryToDisk = function downloadDirectoryToDisk(swarmUrl) {\r\n    return function (hash) {\r\n      return function (dirPath) {\r\n        return downloadRoutes(swarmUrl)(hash).then(function (routingTable) {\r\n          var downloads = [];\r\n\r\n          for (var route in routingTable) {\r\n            if (route.length > 0) {\r\n              var filePath = path.join(dirPath, route);\r\n              downloads.push(downloadDataToDisk(swarmUrl)(routingTable[route])(filePath));\r\n            }\r\n\r\n            ;\r\n          }\r\n\r\n          ;\r\n          return Promise.all(downloads).then(function () {\r\n            return dirPath;\r\n          });\r\n        });\r\n      };\r\n    };\r\n  }; // String -> Uint8Array -> Promise String\r\n  //   Uploads raw data to Swarm.\r\n  //   Returns a promise with the uploaded hash.\r\n\r\n\r\n  var uploadData = function uploadData(swarmUrl) {\r\n    return function (data) {\r\n      return request(\"\".concat(swarmUrl, \"/bzzr:/\"), {\r\n        body: typeof data === \"string\" ? fromString(data) : data,\r\n        method: \"POST\"\r\n      });\r\n    };\r\n  }; // String -> String -> String -> File -> Promise String\r\n  //   Uploads a file to the Swarm manifest at a given hash, under a specific\r\n  //   route. Returns a promise containing the uploaded hash.\r\n  //   FIXME: for some reasons Swarm-Gateways is sometimes returning\r\n  //   error 404 (bad request), so we retry up to 3 times. Why?\r\n\r\n\r\n  var uploadToManifest = function uploadToManifest(swarmUrl) {\r\n    return function (hash) {\r\n      return function (route) {\r\n        return function (file) {\r\n          var attempt = function attempt(n) {\r\n            var slashRoute = route[0] === \"/\" ? route : \"/\" + route;\r\n            var url = \"\".concat(swarmUrl, \"/bzz:/\").concat(hash).concat(slashRoute);\r\n            var opt = {\r\n              method: \"PUT\",\r\n              headers: {\r\n                \"Content-Type\": file.type\r\n              },\r\n              body: file.data\r\n            };\r\n            return request(url, opt).then(function (response) {\r\n              if (response.indexOf(\"error\") !== -1) {\r\n                throw response;\r\n              }\r\n\r\n              return response;\r\n            }).catch(function (e) {\r\n              return n > 0 && attempt(n - 1);\r\n            });\r\n          };\r\n\r\n          return attempt(3);\r\n        };\r\n      };\r\n    };\r\n  }; // String -> {type: String, data: Uint8Array} -> Promise String\r\n\r\n\r\n  var uploadFile = function uploadFile(swarmUrl) {\r\n    return function (file) {\r\n      return uploadDirectory(swarmUrl)({\r\n        \"\": file\r\n      });\r\n    };\r\n  }; // String -> String -> Promise String\r\n\r\n\r\n  var uploadFileFromDisk = function uploadFileFromDisk(swarmUrl) {\r\n    return function (filePath) {\r\n      return fs.readFile(filePath).then(function (data) {\r\n        return uploadFile(swarmUrl)({\r\n          type: mimetype.lookup(filePath),\r\n          data: data\r\n        });\r\n      });\r\n    };\r\n  }; // String -> Map String File -> Promise String\r\n  //   Uploads a directory to Swarm. The directory is\r\n  //   represented as a map of routes and files.\r\n  //   A default path is encoded by having a \"\" route.\r\n\r\n\r\n  var uploadDirectory = function uploadDirectory(swarmUrl) {\r\n    return function (directory) {\r\n      return uploadData(swarmUrl)(\"{}\").then(function (hash) {\r\n        var uploadRoute = function uploadRoute(route) {\r\n          return function (hash) {\r\n            return uploadToManifest(swarmUrl)(hash)(route)(directory[route]);\r\n          };\r\n        };\r\n\r\n        var uploadToHash = function uploadToHash(hash, route) {\r\n          return hash.then(uploadRoute(route));\r\n        };\r\n\r\n        return Object.keys(directory).reduce(uploadToHash, Promise.resolve(hash));\r\n      });\r\n    };\r\n  }; // String -> Promise String\r\n\r\n\r\n  var uploadDataFromDisk = function uploadDataFromDisk(swarmUrl) {\r\n    return function (filePath) {\r\n      return fs.readFile(filePath).then(uploadData(swarmUrl));\r\n    };\r\n  }; // String -> Nullable String -> String -> Promise String\r\n\r\n\r\n  var uploadDirectoryFromDisk = function uploadDirectoryFromDisk(swarmUrl) {\r\n    return function (defaultPath) {\r\n      return function (dirPath) {\r\n        return files.directoryTree(dirPath).then(function (fullPaths) {\r\n          return Promise.all(fullPaths.map(function (path) {\r\n            return fs.readFile(path);\r\n          })).then(function (datas) {\r\n            var paths = fullPaths.map(function (path) {\r\n              return path.slice(dirPath.length);\r\n            });\r\n            var types = fullPaths.map(function (path) {\r\n              return mimetype.lookup(path) || \"text/plain\";\r\n            });\r\n            return toMap(paths)(datas.map(function (data, i) {\r\n              return {\r\n                type: types[i],\r\n                data: data\r\n              };\r\n            }));\r\n          });\r\n        }).then(function (directory) {\r\n          return merge(defaultPath ? {\r\n            \"\": directory[defaultPath]\r\n          } : {})(directory);\r\n        }).then(uploadDirectory(swarmUrl));\r\n      };\r\n    };\r\n  }; // String -> UploadInfo -> Promise String\r\n  //   Simplified multi-type upload which calls the correct\r\n  //   one based on the type of the argument given.\r\n\r\n\r\n  var _upload = function upload(swarmUrl) {\r\n    return function (arg) {\r\n      // Upload raw data from browser\r\n      if (arg.pick === \"data\") {\r\n        return pick.data().then(uploadData(swarmUrl)); // Upload a file from browser\r\n      } else if (arg.pick === \"file\") {\r\n        return pick.file().then(uploadFile(swarmUrl)); // Upload a directory from browser\r\n      } else if (arg.pick === \"directory\") {\r\n        return pick.directory().then(uploadDirectory(swarmUrl)); // Upload directory/file from disk\r\n      } else if (arg.path) {\r\n        switch (arg.kind) {\r\n          case \"data\":\r\n            return uploadDataFromDisk(swarmUrl)(arg.path);\r\n\r\n          case \"file\":\r\n            return uploadFileFromDisk(swarmUrl)(arg.path);\r\n\r\n          case \"directory\":\r\n            return uploadDirectoryFromDisk(swarmUrl)(arg.defaultFile)(arg.path);\r\n        }\r\n\r\n        ; // Upload UTF-8 string or raw data (buffer)\r\n      } else if (arg.length || typeof arg === \"string\") {\r\n        return uploadData(swarmUrl)(arg); // Upload directory with JSON\r\n      } else if (arg instanceof Object) {\r\n        return uploadDirectory(swarmUrl)(arg);\r\n      }\r\n\r\n      return Promise.reject(new Error(\"Bad arguments\"));\r\n    };\r\n  }; // String -> String -> Nullable String -> Promise (String | Uint8Array | Map String Uint8Array)\r\n  //   Simplified multi-type download which calls the correct function based on\r\n  //   the type of the argument given, and on whether the Swwarm address has a\r\n  //   directory or a file.\r\n\r\n\r\n  var _download = function download(swarmUrl) {\r\n    return function (hash) {\r\n      return function (path) {\r\n        return isDirectory(swarmUrl)(hash).then(function (isDir) {\r\n          if (isDir) {\r\n            return path ? downloadDirectoryToDisk(swarmUrl)(hash)(path) : downloadDirectory(swarmUrl)(hash);\r\n          } else {\r\n            return path ? downloadDataToDisk(swarmUrl)(hash)(path) : downloadData(swarmUrl)(hash);\r\n          }\r\n        });\r\n      };\r\n    };\r\n  }; // String -> Promise String\r\n  //   Downloads the Swarm binaries into a path. Returns a promise that only\r\n  //   resolves when the exact Swarm file is there, and verified to be correct.\r\n  //   If it was already there to begin with, skips the download.\r\n\r\n\r\n  var downloadBinary = function downloadBinary(path, archives) {\r\n    var system = os.platform().replace(\"win32\", \"windows\") + \"-\" + (os.arch() === \"x64\" ? \"amd64\" : \"386\");\r\n    var archive = (archives || defaultArchives)[system];\r\n    var archiveUrl = downloadUrl + archive.archive + \".tar.gz\";\r\n    var archiveMD5 = archive.archiveMD5;\r\n    var binaryMD5 = archive.binaryMD5;\r\n    return files.safeDownloadArchived(archiveUrl)(archiveMD5)(binaryMD5)(path);\r\n  }; // type SwarmSetup = {\r\n  //   account : String,\r\n  //   password : String,\r\n  //   dataDir : String,\r\n  //   binPath : String,\r\n  //   ensApi : String,\r\n  //   onDownloadProgress : Number ~> (),\r\n  //   archives : [{\r\n  //     archive: String,\r\n  //     binaryMD5: String,\r\n  //     archiveMD5: String\r\n  //   }]\r\n  // }\r\n  // SwarmSetup ~> Promise Process\r\n  //   Starts the Swarm process.\r\n\r\n\r\n  var startProcess = function startProcess(swarmSetup) {\r\n    return new Promise(function (resolve, reject) {\r\n      var spawn = child_process.spawn;\r\n\r\n      var hasString = function hasString(str) {\r\n        return function (buffer) {\r\n          return ('' + buffer).indexOf(str) !== -1;\r\n        };\r\n      };\r\n\r\n      var account = swarmSetup.account,\r\n          password = swarmSetup.password,\r\n          dataDir = swarmSetup.dataDir,\r\n          ensApi = swarmSetup.ensApi,\r\n          privateKey = swarmSetup.privateKey;\r\n      var STARTUP_TIMEOUT_SECS = 3;\r\n      var WAITING_PASSWORD = 0;\r\n      var STARTING = 1;\r\n      var LISTENING = 2;\r\n      var PASSWORD_PROMPT_HOOK = \"Passphrase\";\r\n      var LISTENING_HOOK = \"Swarm http proxy started\";\r\n      var state = WAITING_PASSWORD;\r\n      var swarmProcess = spawn(swarmSetup.binPath, ['--bzzaccount', account || privateKey, '--datadir', dataDir, '--ens-api', ensApi]);\r\n\r\n      var handleProcessOutput = function handleProcessOutput(data) {\r\n        if (state === WAITING_PASSWORD && hasString(PASSWORD_PROMPT_HOOK)(data)) {\r\n          setTimeout(function () {\r\n            state = STARTING;\r\n            swarmProcess.stdin.write(password + '\\n');\r\n          }, 500);\r\n        } else if (hasString(LISTENING_HOOK)(data)) {\r\n          state = LISTENING;\r\n          clearTimeout(timeout);\r\n          resolve(swarmProcess);\r\n        }\r\n      };\r\n\r\n      swarmProcess.stdout.on('data', handleProcessOutput);\r\n      swarmProcess.stderr.on('data', handleProcessOutput); //swarmProcess.on('close', () => setTimeout(restart, 2000));\r\n\r\n      var restart = function restart() {\r\n        return startProcess(swarmSetup).then(resolve).catch(reject);\r\n      };\r\n\r\n      var error = function error() {\r\n        return reject(new Error(\"Couldn't start swarm process.\"));\r\n      };\r\n\r\n      var timeout = setTimeout(error, 20000);\r\n    });\r\n  }; // Process ~> Promise ()\r\n  //   Stops the Swarm process.\r\n\r\n\r\n  var stopProcess = function stopProcess(process) {\r\n    return new Promise(function (resolve, reject) {\r\n      process.stderr.removeAllListeners('data');\r\n      process.stdout.removeAllListeners('data');\r\n      process.stdin.removeAllListeners('error');\r\n      process.removeAllListeners('error');\r\n      process.removeAllListeners('exit');\r\n      process.kill('SIGINT');\r\n      var killTimeout = setTimeout(function () {\r\n        return process.kill('SIGKILL');\r\n      }, 8000);\r\n      process.once('close', function () {\r\n        clearTimeout(killTimeout);\r\n        resolve();\r\n      });\r\n    });\r\n  }; // SwarmSetup -> (SwarmAPI -> Promise ()) -> Promise ()\r\n  //   Receives a Swarm configuration object and a callback function. It then\r\n  //   checks if a local Swarm node is running. If no local Swarm is found, it\r\n  //   downloads the Swarm binaries to the dataDir (if not there), checksums,\r\n  //   starts the Swarm process and calls the callback function with an API\r\n  //   object using the local node. That callback must return a promise which\r\n  //   will resolve when it is done using the API, so that this function can\r\n  //   close the Swarm process properly. Returns a promise that resolves when the\r\n  //   user is done with the API and the Swarm process is closed.\r\n  //   TODO: check if Swarm process is already running (improve `isAvailable`)\r\n\r\n\r\n  var local = function local(swarmSetup) {\r\n    return function (useAPI) {\r\n      return _isAvailable(\"http://localhost:8500\").then(function (isAvailable) {\r\n        return isAvailable ? useAPI(at(\"http://localhost:8500\")).then(function () {}) : downloadBinary(swarmSetup.binPath, swarmSetup.archives).onData(function (data) {\r\n          return (swarmSetup.onProgress || function () {})(data.length);\r\n        }).then(function () {\r\n          return startProcess(swarmSetup);\r\n        }).then(function (process) {\r\n          return useAPI(at(\"http://localhost:8500\")).then(function () {\r\n            return process;\r\n          });\r\n        }).then(stopProcess);\r\n      });\r\n    };\r\n  }; // String ~> Promise Bool\r\n  //   Returns true if Swarm is available on `url`.\r\n  //   Perfoms a test upload to determine that.\r\n  //   TODO: improve this?\r\n\r\n\r\n  var _isAvailable = function isAvailable(swarmUrl) {\r\n    var testFile = \"test\";\r\n    var testHash = \"c9a99c7d326dcc6316f32fe2625b311f6dc49a175e6877681ded93137d3569e7\";\r\n    return uploadData(swarmUrl)(testFile).then(function (hash) {\r\n      return hash === testHash;\r\n    }).catch(function () {\r\n      return false;\r\n    });\r\n  }; // String -> String ~> Promise Bool\r\n  //   Returns a Promise which is true if that Swarm address is a directory.\r\n  //   Determines that by checking that it (i) is a JSON, (ii) has a .entries.\r\n  //   TODO: improve this?\r\n\r\n\r\n  var isDirectory = function isDirectory(swarmUrl) {\r\n    return function (hash) {\r\n      return downloadData(swarmUrl)(hash).then(function (data) {\r\n        try {\r\n          return !!JSON.parse(toString(data)).entries;\r\n        } catch (e) {\r\n          return false;\r\n        }\r\n      });\r\n    };\r\n  }; // Uncurries a function; used to allow the f(x,y,z) style on exports.\r\n\r\n\r\n  var uncurry = function uncurry(f) {\r\n    return function (a, b, c, d, e) {\r\n      var p; // Hardcoded because efficiency (`arguments` is very slow).\r\n\r\n      if (typeof a !== \"undefined\") p = f(a);\r\n      if (typeof b !== \"undefined\") p = f(b);\r\n      if (typeof c !== \"undefined\") p = f(c);\r\n      if (typeof d !== \"undefined\") p = f(d);\r\n      if (typeof e !== \"undefined\") p = f(e);\r\n      return p;\r\n    };\r\n  }; // () -> Promise Bool\r\n  //   Not sure how to mock Swarm to test it properly. Ideas?\r\n\r\n\r\n  var test = function test() {\r\n    return Promise.resolve(true);\r\n  }; // Uint8Array -> String\r\n\r\n\r\n  var toString = function toString(uint8Array) {\r\n    return bytes.toString(bytes.fromUint8Array(uint8Array));\r\n  }; // String -> Uint8Array\r\n\r\n\r\n  var fromString = function fromString(string) {\r\n    return bytes.toUint8Array(bytes.fromString(string));\r\n  }; // String -> SwarmAPI\r\n  //   Fixes the `swarmUrl`, returning an API where you don't have to pass it.\r\n\r\n\r\n  var at = function at(swarmUrl) {\r\n    return {\r\n      download: function download(hash, path) {\r\n        return _download(swarmUrl)(hash)(path);\r\n      },\r\n      downloadData: uncurry(downloadData(swarmUrl)),\r\n      downloadDataToDisk: uncurry(downloadDataToDisk(swarmUrl)),\r\n      downloadDirectory: uncurry(downloadDirectory(swarmUrl)),\r\n      downloadDirectoryToDisk: uncurry(downloadDirectoryToDisk(swarmUrl)),\r\n      downloadEntries: uncurry(downloadEntries(swarmUrl)),\r\n      downloadRoutes: uncurry(downloadRoutes(swarmUrl)),\r\n      isAvailable: function isAvailable() {\r\n        return _isAvailable(swarmUrl);\r\n      },\r\n      upload: function upload(arg) {\r\n        return _upload(swarmUrl)(arg);\r\n      },\r\n      uploadData: uncurry(uploadData(swarmUrl)),\r\n      uploadFile: uncurry(uploadFile(swarmUrl)),\r\n      uploadFileFromDisk: uncurry(uploadFile(swarmUrl)),\r\n      uploadDataFromDisk: uncurry(uploadDataFromDisk(swarmUrl)),\r\n      uploadDirectory: uncurry(uploadDirectory(swarmUrl)),\r\n      uploadDirectoryFromDisk: uncurry(uploadDirectoryFromDisk(swarmUrl)),\r\n      uploadToManifest: uncurry(uploadToManifest(swarmUrl)),\r\n      pick: pick,\r\n      hash: hash,\r\n      fromString: fromString,\r\n      toString: toString\r\n    };\r\n  };\r\n\r\n  return {\r\n    at: at,\r\n    local: local,\r\n    download: _download,\r\n    downloadBinary: downloadBinary,\r\n    downloadData: downloadData,\r\n    downloadDataToDisk: downloadDataToDisk,\r\n    downloadDirectory: downloadDirectory,\r\n    downloadDirectoryToDisk: downloadDirectoryToDisk,\r\n    downloadEntries: downloadEntries,\r\n    downloadRoutes: downloadRoutes,\r\n    isAvailable: _isAvailable,\r\n    startProcess: startProcess,\r\n    stopProcess: stopProcess,\r\n    upload: _upload,\r\n    uploadData: uploadData,\r\n    uploadDataFromDisk: uploadDataFromDisk,\r\n    uploadFile: uploadFile,\r\n    uploadFileFromDisk: uploadFileFromDisk,\r\n    uploadDirectory: uploadDirectory,\r\n    uploadDirectoryFromDisk: uploadDirectoryFromDisk,\r\n    uploadToManifest: uploadToManifest,\r\n    pick: pick,\r\n    hash: hash,\r\n    fromString: fromString,\r\n    toString: toString\r\n  };\r\n};"],"mappings":"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"},"metadata":{},"sourceType":"script"}
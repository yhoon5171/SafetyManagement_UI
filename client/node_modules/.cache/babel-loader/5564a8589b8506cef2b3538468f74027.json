{"ast":null,"code":"/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * @file index.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @author Marek Kotewicz <marek@parity.io>\n * @date 2017\n */\n\"use strict\";\n\nvar _ = require('underscore');\n\nvar errors = require('web3-core-helpers').errors;\n\nvar formatters = require('web3-core-helpers').formatters;\n\nvar utils = require('web3-utils');\n\nvar promiEvent = require('web3-core-promievent');\n\nvar Subscriptions = require('web3-core-subscriptions').subscriptions;\n\nvar TIMEOUTBLOCK = 50;\nvar POLLINGTIMEOUT = 15 * TIMEOUTBLOCK; // ~average block time (seconds) * TIMEOUTBLOCK\n\nvar CONFIRMATIONBLOCKS = 24;\n\nvar Method = function Method(options) {\n  if (!options.call || !options.name) {\n    throw new Error('When creating a method you need to provide at least the \"name\" and \"call\" property.');\n  }\n\n  this.name = options.name;\n  this.call = options.call;\n  this.params = options.params || 0;\n  this.inputFormatter = options.inputFormatter;\n  this.outputFormatter = options.outputFormatter;\n  this.transformPayload = options.transformPayload;\n  this.extraFormatters = options.extraFormatters;\n  this.requestManager = options.requestManager; // reference to eth.accounts\n\n  this.accounts = options.accounts;\n  this.defaultBlock = options.defaultBlock || 'latest';\n  this.defaultAccount = options.defaultAccount || null;\n};\n\nMethod.prototype.setRequestManager = function (requestManager, accounts) {\n  this.requestManager = requestManager; // reference to eth.accounts\n\n  if (accounts) {\n    this.accounts = accounts;\n  }\n};\n\nMethod.prototype.createFunction = function (requestManager, accounts) {\n  var func = this.buildCall();\n  func.call = this.call;\n  this.setRequestManager(requestManager || this.requestManager, accounts || this.accounts);\n  return func;\n};\n\nMethod.prototype.attachToObject = function (obj) {\n  var func = this.buildCall();\n  func.call = this.call;\n  var name = this.name.split('.');\n\n  if (name.length > 1) {\n    obj[name[0]] = obj[name[0]] || {};\n    obj[name[0]][name[1]] = func;\n  } else {\n    obj[name[0]] = func;\n  }\n};\n/**\n * Should be used to determine name of the jsonrpc method based on arguments\n *\n * @method getCall\n * @param {Array} arguments\n * @return {String} name of jsonrpc method\n */\n\n\nMethod.prototype.getCall = function (args) {\n  return _.isFunction(this.call) ? this.call(args) : this.call;\n};\n/**\n * Should be used to extract callback from array of arguments. Modifies input param\n *\n * @method extractCallback\n * @param {Array} arguments\n * @return {Function|Null} callback, if exists\n */\n\n\nMethod.prototype.extractCallback = function (args) {\n  if (_.isFunction(args[args.length - 1])) {\n    return args.pop(); // modify the args array!\n  }\n};\n/**\n * Should be called to check if the number of arguments is correct\n *\n * @method validateArgs\n * @param {Array} arguments\n * @throws {Error} if it is not\n */\n\n\nMethod.prototype.validateArgs = function (args) {\n  if (args.length !== this.params) {\n    throw errors.InvalidNumberOfParams(args.length, this.params, this.name);\n  }\n};\n/**\n * Should be called to format input args of method\n *\n * @method formatInput\n * @param {Array}\n * @return {Array}\n */\n\n\nMethod.prototype.formatInput = function (args) {\n  var _this = this;\n\n  if (!this.inputFormatter) {\n    return args;\n  }\n\n  return this.inputFormatter.map(function (formatter, index) {\n    // bind this for defaultBlock, and defaultAccount\n    return formatter ? formatter.call(_this, args[index]) : args[index];\n  });\n};\n/**\n * Should be called to format output(result) of method\n *\n * @method formatOutput\n * @param {Object}\n * @return {Object}\n */\n\n\nMethod.prototype.formatOutput = function (result) {\n  var _this = this;\n\n  if (_.isArray(result)) {\n    return result.map(function (res) {\n      return _this.outputFormatter && res ? _this.outputFormatter(res) : res;\n    });\n  } else {\n    return this.outputFormatter && result ? this.outputFormatter(result) : result;\n  }\n};\n/**\n * Should create payload from given input args\n *\n * @method toPayload\n * @param {Array} args\n * @return {Object}\n */\n\n\nMethod.prototype.toPayload = function (args) {\n  var call = this.getCall(args);\n  var callback = this.extractCallback(args);\n  var params = this.formatInput(args);\n  this.validateArgs(params);\n  var payload = {\n    method: call,\n    params: params,\n    callback: callback\n  };\n\n  if (this.transformPayload) {\n    payload = this.transformPayload(payload);\n  }\n\n  return payload;\n};\n\nMethod.prototype._confirmTransaction = function (defer, result, payload) {\n  var method = this,\n      promiseResolved = false,\n      canUnsubscribe = true,\n      timeoutCount = 0,\n      confirmationCount = 0,\n      intervalId = null,\n      receiptJSON = '',\n      gasProvided = _.isObject(payload.params[0]) && payload.params[0].gas ? payload.params[0].gas : null,\n      isContractDeployment = _.isObject(payload.params[0]) && payload.params[0].data && payload.params[0].from && !payload.params[0].to; // add custom send Methods\n\n  var _ethereumCalls = [new Method({\n    name: 'getTransactionReceipt',\n    call: 'eth_getTransactionReceipt',\n    params: 1,\n    inputFormatter: [null],\n    outputFormatter: formatters.outputTransactionReceiptFormatter\n  }), new Method({\n    name: 'getCode',\n    call: 'eth_getCode',\n    params: 2,\n    inputFormatter: [formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter]\n  }), new Subscriptions({\n    name: 'subscribe',\n    type: 'eth',\n    subscriptions: {\n      'newBlockHeaders': {\n        subscriptionName: 'newHeads',\n        // replace subscription with this name\n        params: 0,\n        outputFormatter: formatters.outputBlockFormatter\n      }\n    }\n  })]; // attach methods to this._ethereumCall\n\n  var _ethereumCall = {};\n\n  _.each(_ethereumCalls, function (mthd) {\n    mthd.attachToObject(_ethereumCall);\n    mthd.requestManager = method.requestManager; // assign rather than call setRequestManager()\n  }); // fire \"receipt\" and confirmation events and resolve after\n\n\n  var checkConfirmation = function (existingReceipt, isPolling, err, blockHeader, sub) {\n    if (!err) {\n      // create fake unsubscribe\n      if (!sub) {\n        sub = {\n          unsubscribe: function () {\n            clearInterval(intervalId);\n          }\n        };\n      } // if we have a valid receipt we don't need to send a request\n\n\n      return (existingReceipt ? promiEvent.resolve(existingReceipt) : _ethereumCall.getTransactionReceipt(result) // catch error from requesting receipt\n      ).catch(function (err) {\n        sub.unsubscribe();\n        promiseResolved = true;\n\n        utils._fireError({\n          message: 'Failed to check for transaction receipt:',\n          data: err\n        }, defer.eventEmitter, defer.reject);\n      }) // if CONFIRMATION listener exists check for confirmations, by setting canUnsubscribe = false\n      .then(function (receipt) {\n        if (!receipt || !receipt.blockHash) {\n          throw new Error('Receipt missing or blockHash null');\n        } // apply extra formatters\n\n\n        if (method.extraFormatters && method.extraFormatters.receiptFormatter) {\n          receipt = method.extraFormatters.receiptFormatter(receipt);\n        } // check if confirmation listener exists\n\n\n        if (defer.eventEmitter.listeners('confirmation').length > 0) {\n          // If there was an immediately retrieved receipt, it's already\n          // been confirmed by the direct call to checkConfirmation needed\n          // for parity instant-seal\n          if (existingReceipt === undefined || confirmationCount !== 0) {\n            defer.eventEmitter.emit('confirmation', confirmationCount, receipt);\n          }\n\n          canUnsubscribe = false;\n          confirmationCount++;\n\n          if (confirmationCount === CONFIRMATIONBLOCKS + 1) {\n            // add 1 so we account for conf 0\n            sub.unsubscribe();\n            defer.eventEmitter.removeAllListeners();\n          }\n        }\n\n        return receipt;\n      }) // CHECK for CONTRACT DEPLOYMENT\n      .then(function (receipt) {\n        if (isContractDeployment && !promiseResolved) {\n          if (!receipt.contractAddress) {\n            if (canUnsubscribe) {\n              sub.unsubscribe();\n              promiseResolved = true;\n            }\n\n            utils._fireError(new Error('The transaction receipt didn\\'t contain a contract address.'), defer.eventEmitter, defer.reject);\n\n            return;\n          }\n\n          _ethereumCall.getCode(receipt.contractAddress, function (e, code) {\n            if (!code) {\n              return;\n            }\n\n            if (code.length > 2) {\n              defer.eventEmitter.emit('receipt', receipt); // if contract, return instance instead of receipt\n\n              if (method.extraFormatters && method.extraFormatters.contractDeployFormatter) {\n                defer.resolve(method.extraFormatters.contractDeployFormatter(receipt));\n              } else {\n                defer.resolve(receipt);\n              } // need to remove listeners, as they aren't removed automatically when succesfull\n\n\n              if (canUnsubscribe) {\n                defer.eventEmitter.removeAllListeners();\n              }\n            } else {\n              utils._fireError(new Error('The contract code couldn\\'t be stored, please check your gas limit.'), defer.eventEmitter, defer.reject);\n            }\n\n            if (canUnsubscribe) {\n              sub.unsubscribe();\n            }\n\n            promiseResolved = true;\n          });\n        }\n\n        return receipt;\n      }) // CHECK for normal tx check for receipt only\n      .then(function (receipt) {\n        if (!isContractDeployment && !promiseResolved) {\n          if (!receipt.outOfGas && (!gasProvided || gasProvided !== receipt.gasUsed) && (receipt.status === true || receipt.status === '0x1' || typeof receipt.status === 'undefined')) {\n            defer.eventEmitter.emit('receipt', receipt);\n            defer.resolve(receipt); // need to remove listeners, as they aren't removed automatically when succesfull\n\n            if (canUnsubscribe) {\n              defer.eventEmitter.removeAllListeners();\n            }\n          } else {\n            receiptJSON = JSON.stringify(receipt, null, 2);\n\n            if (receipt.status === false || receipt.status === '0x0') {\n              utils._fireError(new Error(\"Transaction has been reverted by the EVM:\\n\" + receiptJSON), defer.eventEmitter, defer.reject);\n            } else {\n              utils._fireError(new Error(\"Transaction ran out of gas. Please provide more gas:\\n\" + receiptJSON), defer.eventEmitter, defer.reject);\n            }\n          }\n\n          if (canUnsubscribe) {\n            sub.unsubscribe();\n          }\n\n          promiseResolved = true;\n        }\n      }) // time out the transaction if not mined after 50 blocks\n      .catch(function () {\n        timeoutCount++; // check to see if we are http polling\n\n        if (!!isPolling) {\n          // polling timeout is different than TIMEOUTBLOCK blocks since we are triggering every second\n          if (timeoutCount - 1 >= POLLINGTIMEOUT) {\n            sub.unsubscribe();\n            promiseResolved = true;\n\n            utils._fireError(new Error('Transaction was not mined within' + POLLINGTIMEOUT + ' seconds, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\n          }\n        } else {\n          if (timeoutCount - 1 >= TIMEOUTBLOCK) {\n            sub.unsubscribe();\n            promiseResolved = true;\n\n            utils._fireError(new Error('Transaction was not mined within 50 blocks, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\n          }\n        }\n      });\n    } else {\n      sub.unsubscribe();\n      promiseResolved = true;\n\n      utils._fireError({\n        message: 'Failed to subscribe to new newBlockHeaders to confirm the transaction receipts.',\n        data: err\n      }, defer.eventEmitter, defer.reject);\n    }\n  }; // start watching for confirmation depending on the support features of the provider\n\n\n  var startWatching = function (existingReceipt) {\n    // if provider allows PUB/SUB\n    if (_.isFunction(this.requestManager.provider.on)) {\n      _ethereumCall.subscribe('newBlockHeaders', checkConfirmation.bind(null, existingReceipt, false));\n    } else {\n      intervalId = setInterval(checkConfirmation.bind(null, existingReceipt, true), 1000);\n    }\n  }.bind(this); // first check if we already have a confirmed transaction\n\n\n  _ethereumCall.getTransactionReceipt(result).then(function (receipt) {\n    if (receipt && receipt.blockHash) {\n      if (defer.eventEmitter.listeners('confirmation').length > 0) {\n        // We must keep on watching for new Blocks, if a confirmation listener is present\n        startWatching(receipt);\n      }\n\n      checkConfirmation(receipt, false);\n    } else if (!promiseResolved) {\n      startWatching();\n    }\n  }).catch(function () {\n    if (!promiseResolved) startWatching();\n  });\n};\n\nvar getWallet = function (from, accounts) {\n  var wallet = null; // is index given\n\n  if (_.isNumber(from)) {\n    wallet = accounts.wallet[from]; // is account given\n  } else if (_.isObject(from) && from.address && from.privateKey) {\n    wallet = from; // search in wallet for address\n  } else {\n    wallet = accounts.wallet[from.toLowerCase()];\n  }\n\n  return wallet;\n};\n\nMethod.prototype.buildCall = function () {\n  var method = this,\n      isSendTx = method.call === 'eth_sendTransaction' || method.call === 'eth_sendRawTransaction'; // || method.call === 'personal_sendTransaction'\n  // actual send function\n\n  var send = function () {\n    var defer = promiEvent(!isSendTx),\n        payload = method.toPayload(Array.prototype.slice.call(arguments)); // CALLBACK function\n\n    var sendTxCallback = function (err, result) {\n      try {\n        result = method.formatOutput(result);\n      } catch (e) {\n        err = e;\n      }\n\n      if (result instanceof Error) {\n        err = result;\n      }\n\n      if (!err) {\n        if (payload.callback) {\n          payload.callback(null, result);\n        }\n      } else {\n        if (err.error) {\n          err = err.error;\n        }\n\n        return utils._fireError(err, defer.eventEmitter, defer.reject, payload.callback);\n      } // return PROMISE\n\n\n      if (!isSendTx) {\n        if (!err) {\n          defer.resolve(result);\n        } // return PROMIEVENT\n\n      } else {\n        defer.eventEmitter.emit('transactionHash', result);\n\n        method._confirmTransaction(defer, result, payload);\n      }\n    }; // SENDS the SIGNED SIGNATURE\n\n\n    var sendSignedTx = function (sign) {\n      var signedPayload = _.extend({}, payload, {\n        method: 'eth_sendRawTransaction',\n        params: [sign.rawTransaction]\n      });\n\n      method.requestManager.send(signedPayload, sendTxCallback);\n    };\n\n    var sendRequest = function (payload, method) {\n      if (method && method.accounts && method.accounts.wallet && method.accounts.wallet.length) {\n        var wallet; // ETH_SENDTRANSACTION\n\n        if (payload.method === 'eth_sendTransaction') {\n          var tx = payload.params[0];\n          wallet = getWallet(_.isObject(tx) ? tx.from : null, method.accounts); // If wallet was found, sign tx, and send using sendRawTransaction\n\n          if (wallet && wallet.privateKey) {\n            return method.accounts.signTransaction(_.omit(tx, 'from'), wallet.privateKey).then(sendSignedTx);\n          } // ETH_SIGN\n\n        } else if (payload.method === 'eth_sign') {\n          var data = payload.params[1];\n          wallet = getWallet(payload.params[0], method.accounts); // If wallet was found, sign tx, and send using sendRawTransaction\n\n          if (wallet && wallet.privateKey) {\n            var sign = method.accounts.sign(data, wallet.privateKey);\n\n            if (payload.callback) {\n              payload.callback(null, sign.signature);\n            }\n\n            defer.resolve(sign.signature);\n            return;\n          }\n        }\n      }\n\n      return method.requestManager.send(payload, sendTxCallback);\n    }; // Send the actual transaction\n\n\n    if (isSendTx && _.isObject(payload.params[0]) && typeof payload.params[0].gasPrice === 'undefined') {\n      var getGasPrice = new Method({\n        name: 'getGasPrice',\n        call: 'eth_gasPrice',\n        params: 0\n      }).createFunction(method.requestManager);\n      getGasPrice(function (err, gasPrice) {\n        if (gasPrice) {\n          payload.params[0].gasPrice = gasPrice;\n        }\n\n        sendRequest(payload, method);\n      });\n    } else {\n      sendRequest(payload, method);\n    }\n\n    return defer.eventEmitter;\n  }; // necessary to attach things to the method\n\n\n  send.method = method; // necessary for batch requests\n\n  send.request = this.request.bind(this);\n  return send;\n};\n/**\n * Should be called to create the pure JSONRPC request which can be used in a batch request\n *\n * @method request\n * @return {Object} jsonrpc request\n */\n\n\nMethod.prototype.request = function () {\n  var payload = this.toPayload(Array.prototype.slice.call(arguments));\n  payload.format = this.formatOutput.bind(this);\n  return payload;\n};\n\nmodule.exports = Method;","map":{"version":3,"names":["_","require","errors","formatters","utils","promiEvent","Subscriptions","subscriptions","TIMEOUTBLOCK","POLLINGTIMEOUT","CONFIRMATIONBLOCKS","Method","options","call","name","Error","params","inputFormatter","outputFormatter","transformPayload","extraFormatters","requestManager","accounts","defaultBlock","defaultAccount","prototype","setRequestManager","createFunction","func","buildCall","attachToObject","obj","split","length","getCall","args","isFunction","extractCallback","pop","validateArgs","InvalidNumberOfParams","formatInput","_this","map","formatter","index","formatOutput","result","isArray","res","toPayload","callback","payload","method","_confirmTransaction","defer","promiseResolved","canUnsubscribe","timeoutCount","confirmationCount","intervalId","receiptJSON","gasProvided","isObject","gas","isContractDeployment","data","from","to","_ethereumCalls","outputTransactionReceiptFormatter","inputAddressFormatter","inputDefaultBlockNumberFormatter","type","subscriptionName","outputBlockFormatter","_ethereumCall","each","mthd","checkConfirmation","existingReceipt","isPolling","err","blockHeader","sub","unsubscribe","clearInterval","resolve","getTransactionReceipt","catch","_fireError","message","eventEmitter","reject","then","receipt","blockHash","receiptFormatter","listeners","undefined","emit","removeAllListeners","contractAddress","getCode","e","code","contractDeployFormatter","outOfGas","gasUsed","status","JSON","stringify","startWatching","provider","on","subscribe","bind","setInterval","getWallet","wallet","isNumber","address","privateKey","toLowerCase","isSendTx","send","Array","slice","arguments","sendTxCallback","error","sendSignedTx","sign","signedPayload","extend","rawTransaction","sendRequest","tx","signTransaction","omit","signature","gasPrice","getGasPrice","request","format","module","exports"],"sources":["D:/공프기/REACT/client/node_modules/truffle-contract/node_modules/web3-core-method/src/index.js"],"sourcesContent":["/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file index.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @author Marek Kotewicz <marek@parity.io>\n * @date 2017\n */\n\n\"use strict\";\n\nvar _ = require('underscore');\nvar errors = require('web3-core-helpers').errors;\nvar formatters = require('web3-core-helpers').formatters;\nvar utils = require('web3-utils');\nvar promiEvent = require('web3-core-promievent');\nvar Subscriptions = require('web3-core-subscriptions').subscriptions;\n\nvar TIMEOUTBLOCK = 50;\nvar POLLINGTIMEOUT = 15 * TIMEOUTBLOCK; // ~average block time (seconds) * TIMEOUTBLOCK\nvar CONFIRMATIONBLOCKS = 24;\n\nvar Method = function Method(options) {\n\n    if(!options.call || !options.name) {\n        throw new Error('When creating a method you need to provide at least the \"name\" and \"call\" property.');\n    }\n\n    this.name = options.name;\n    this.call = options.call;\n    this.params = options.params || 0;\n    this.inputFormatter = options.inputFormatter;\n    this.outputFormatter = options.outputFormatter;\n    this.transformPayload = options.transformPayload;\n    this.extraFormatters = options.extraFormatters;\n\n    this.requestManager = options.requestManager;\n\n    // reference to eth.accounts\n    this.accounts = options.accounts;\n\n    this.defaultBlock = options.defaultBlock || 'latest';\n    this.defaultAccount = options.defaultAccount || null;\n};\n\nMethod.prototype.setRequestManager = function (requestManager, accounts) {\n    this.requestManager = requestManager;\n\n    // reference to eth.accounts\n    if (accounts) {\n        this.accounts = accounts;\n    }\n\n};\n\nMethod.prototype.createFunction = function (requestManager, accounts) {\n    var func = this.buildCall();\n    func.call = this.call;\n\n    this.setRequestManager(requestManager || this.requestManager, accounts || this.accounts);\n\n    return func;\n};\n\nMethod.prototype.attachToObject = function (obj) {\n    var func = this.buildCall();\n    func.call = this.call;\n    var name = this.name.split('.');\n    if (name.length > 1) {\n        obj[name[0]] = obj[name[0]] || {};\n        obj[name[0]][name[1]] = func;\n    } else {\n        obj[name[0]] = func;\n    }\n};\n\n/**\n * Should be used to determine name of the jsonrpc method based on arguments\n *\n * @method getCall\n * @param {Array} arguments\n * @return {String} name of jsonrpc method\n */\nMethod.prototype.getCall = function (args) {\n    return _.isFunction(this.call) ? this.call(args) : this.call;\n};\n\n/**\n * Should be used to extract callback from array of arguments. Modifies input param\n *\n * @method extractCallback\n * @param {Array} arguments\n * @return {Function|Null} callback, if exists\n */\nMethod.prototype.extractCallback = function (args) {\n    if (_.isFunction(args[args.length - 1])) {\n        return args.pop(); // modify the args array!\n    }\n};\n\n/**\n * Should be called to check if the number of arguments is correct\n *\n * @method validateArgs\n * @param {Array} arguments\n * @throws {Error} if it is not\n */\nMethod.prototype.validateArgs = function (args) {\n    if (args.length !== this.params) {\n        throw errors.InvalidNumberOfParams(args.length, this.params, this.name);\n    }\n};\n\n/**\n * Should be called to format input args of method\n *\n * @method formatInput\n * @param {Array}\n * @return {Array}\n */\nMethod.prototype.formatInput = function (args) {\n    var _this = this;\n\n    if (!this.inputFormatter) {\n        return args;\n    }\n\n    return this.inputFormatter.map(function (formatter, index) {\n        // bind this for defaultBlock, and defaultAccount\n        return formatter ? formatter.call(_this, args[index]) : args[index];\n    });\n};\n\n/**\n * Should be called to format output(result) of method\n *\n * @method formatOutput\n * @param {Object}\n * @return {Object}\n */\nMethod.prototype.formatOutput = function (result) {\n    var _this = this;\n\n    if(_.isArray(result)) {\n        return result.map(function(res){\n            return _this.outputFormatter && res ? _this.outputFormatter(res) : res;\n        });\n    } else {\n        return this.outputFormatter && result ? this.outputFormatter(result) : result;\n    }\n};\n\n/**\n * Should create payload from given input args\n *\n * @method toPayload\n * @param {Array} args\n * @return {Object}\n */\nMethod.prototype.toPayload = function (args) {\n    var call = this.getCall(args);\n    var callback = this.extractCallback(args);\n    var params = this.formatInput(args);\n    this.validateArgs(params);\n\n    var payload = {\n        method: call,\n        params: params,\n        callback: callback\n    };\n\n    if (this.transformPayload) {\n        payload = this.transformPayload(payload);\n    }\n\n    return payload;\n};\n\n\nMethod.prototype._confirmTransaction = function (defer, result, payload) {\n    var method = this,\n        promiseResolved = false,\n        canUnsubscribe = true,\n        timeoutCount = 0,\n        confirmationCount = 0,\n        intervalId = null,\n        receiptJSON = '',\n        gasProvided = (_.isObject(payload.params[0]) && payload.params[0].gas) ? payload.params[0].gas : null,\n        isContractDeployment = _.isObject(payload.params[0]) &&\n            payload.params[0].data &&\n            payload.params[0].from &&\n            !payload.params[0].to;\n\n    // add custom send Methods\n    var _ethereumCalls = [\n        new Method({\n            name: 'getTransactionReceipt',\n            call: 'eth_getTransactionReceipt',\n            params: 1,\n            inputFormatter: [null],\n            outputFormatter: formatters.outputTransactionReceiptFormatter\n        }),\n        new Method({\n            name: 'getCode',\n            call: 'eth_getCode',\n            params: 2,\n            inputFormatter: [formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter]\n        }),\n        new Subscriptions({\n            name: 'subscribe',\n            type: 'eth',\n            subscriptions: {\n                'newBlockHeaders': {\n                    subscriptionName: 'newHeads', // replace subscription with this name\n                    params: 0,\n                    outputFormatter: formatters.outputBlockFormatter\n                }\n            }\n        })\n    ];\n    // attach methods to this._ethereumCall\n    var _ethereumCall = {};\n    _.each(_ethereumCalls, function (mthd) {\n        mthd.attachToObject(_ethereumCall);\n        mthd.requestManager = method.requestManager; // assign rather than call setRequestManager()\n    });\n\n\n    // fire \"receipt\" and confirmation events and resolve after\n    var checkConfirmation = function (existingReceipt, isPolling, err, blockHeader, sub) {\n        if (!err) {\n            // create fake unsubscribe\n            if (!sub) {\n                sub = {\n                    unsubscribe: function () {\n                        clearInterval(intervalId);\n                    }\n                };\n            }\n            // if we have a valid receipt we don't need to send a request\n            return (existingReceipt ? promiEvent.resolve(existingReceipt) : _ethereumCall.getTransactionReceipt(result))\n            // catch error from requesting receipt\n            .catch(function (err) {\n                sub.unsubscribe();\n                promiseResolved = true;\n                utils._fireError({message: 'Failed to check for transaction receipt:', data: err}, defer.eventEmitter, defer.reject);\n            })\n            // if CONFIRMATION listener exists check for confirmations, by setting canUnsubscribe = false\n            .then(function(receipt) {\n                if (!receipt || !receipt.blockHash) {\n                    throw new Error('Receipt missing or blockHash null');\n                }\n\n                // apply extra formatters\n                if (method.extraFormatters && method.extraFormatters.receiptFormatter) {\n                    receipt = method.extraFormatters.receiptFormatter(receipt);\n                }\n\n                // check if confirmation listener exists\n                if (defer.eventEmitter.listeners('confirmation').length > 0) {\n\n                    // If there was an immediately retrieved receipt, it's already\n                    // been confirmed by the direct call to checkConfirmation needed\n                    // for parity instant-seal\n                    if (existingReceipt === undefined || confirmationCount !== 0){\n                        defer.eventEmitter.emit('confirmation', confirmationCount, receipt);\n                    }\n\n                    canUnsubscribe = false;\n                    confirmationCount++;\n\n                    if (confirmationCount === CONFIRMATIONBLOCKS + 1) { // add 1 so we account for conf 0\n                        sub.unsubscribe();\n                        defer.eventEmitter.removeAllListeners();\n                    }\n                }\n\n                return receipt;\n            })\n            // CHECK for CONTRACT DEPLOYMENT\n            .then(function(receipt) {\n\n                if (isContractDeployment && !promiseResolved) {\n\n                    if (!receipt.contractAddress) {\n\n                        if (canUnsubscribe) {\n                            sub.unsubscribe();\n                            promiseResolved = true;\n                        }\n\n                        utils._fireError(new Error('The transaction receipt didn\\'t contain a contract address.'), defer.eventEmitter, defer.reject);\n                        return;\n                    }\n\n                    _ethereumCall.getCode(receipt.contractAddress, function (e, code) {\n\n                        if (!code) {\n                            return;\n                        }\n\n\n                        if (code.length > 2) {\n                            defer.eventEmitter.emit('receipt', receipt);\n\n                            // if contract, return instance instead of receipt\n                            if (method.extraFormatters && method.extraFormatters.contractDeployFormatter) {\n                                defer.resolve(method.extraFormatters.contractDeployFormatter(receipt));\n                            } else {\n                                defer.resolve(receipt);\n                            }\n\n                            // need to remove listeners, as they aren't removed automatically when succesfull\n                            if (canUnsubscribe) {\n                                defer.eventEmitter.removeAllListeners();\n                            }\n\n                        } else {\n                            utils._fireError(new Error('The contract code couldn\\'t be stored, please check your gas limit.'), defer.eventEmitter, defer.reject);\n                        }\n\n                        if (canUnsubscribe) {\n                            sub.unsubscribe();\n                        }\n                        promiseResolved = true;\n                    });\n                }\n\n                return receipt;\n            })\n            // CHECK for normal tx check for receipt only\n            .then(function(receipt) {\n\n                if (!isContractDeployment && !promiseResolved) {\n\n                    if(!receipt.outOfGas &&\n                        (!gasProvided || gasProvided !== receipt.gasUsed) &&\n                        (receipt.status === true || receipt.status === '0x1' || typeof receipt.status === 'undefined')) {\n                        defer.eventEmitter.emit('receipt', receipt);\n                        defer.resolve(receipt);\n\n                        // need to remove listeners, as they aren't removed automatically when succesfull\n                        if (canUnsubscribe) {\n                            defer.eventEmitter.removeAllListeners();\n                        }\n\n                    } else {\n                        receiptJSON = JSON.stringify(receipt, null, 2);\n                        if (receipt.status === false || receipt.status === '0x0') {\n                            utils._fireError(new Error(\"Transaction has been reverted by the EVM:\\n\" + receiptJSON),\n                                defer.eventEmitter, defer.reject);\n                        } else {\n                            utils._fireError(\n                                new Error(\"Transaction ran out of gas. Please provide more gas:\\n\" + receiptJSON),\n                                defer.eventEmitter, defer.reject);\n                        }\n                    }\n\n                    if (canUnsubscribe) {\n                        sub.unsubscribe();\n                    }\n                    promiseResolved = true;\n                }\n\n            })\n            // time out the transaction if not mined after 50 blocks\n            .catch(function () {\n                timeoutCount++;\n\n                // check to see if we are http polling\n                if(!!isPolling) {\n                    // polling timeout is different than TIMEOUTBLOCK blocks since we are triggering every second\n                    if (timeoutCount - 1 >= POLLINGTIMEOUT) {\n                        sub.unsubscribe();\n                        promiseResolved = true;\n                        utils._fireError(new Error('Transaction was not mined within' + POLLINGTIMEOUT + ' seconds, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\n                    }\n                } else {\n                    if (timeoutCount - 1 >= TIMEOUTBLOCK) {\n                        sub.unsubscribe();\n                        promiseResolved = true;\n                        utils._fireError(new Error('Transaction was not mined within 50 blocks, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\n                    }\n                }\n            });\n\n\n        } else {\n            sub.unsubscribe();\n            promiseResolved = true;\n            utils._fireError({message: 'Failed to subscribe to new newBlockHeaders to confirm the transaction receipts.', data: err}, defer.eventEmitter, defer.reject);\n        }\n    };\n\n    // start watching for confirmation depending on the support features of the provider\n    var startWatching = function(existingReceipt) {\n        // if provider allows PUB/SUB\n        if (_.isFunction(this.requestManager.provider.on)) {\n            _ethereumCall.subscribe('newBlockHeaders', checkConfirmation.bind(null, existingReceipt, false));\n        } else {\n            intervalId = setInterval(checkConfirmation.bind(null, existingReceipt, true), 1000);\n        }\n    }.bind(this);\n\n\n    // first check if we already have a confirmed transaction\n    _ethereumCall.getTransactionReceipt(result)\n    .then(function(receipt) {\n        if (receipt && receipt.blockHash) {\n            if (defer.eventEmitter.listeners('confirmation').length > 0) {\n                // We must keep on watching for new Blocks, if a confirmation listener is present\n                startWatching(receipt);\n            }\n            checkConfirmation(receipt, false);\n\n        } else if (!promiseResolved) {\n            startWatching();\n        }\n    })\n    .catch(function(){\n        if (!promiseResolved) startWatching();\n    });\n\n};\n\n\nvar getWallet = function(from, accounts) {\n    var wallet = null;\n\n    // is index given\n    if (_.isNumber(from)) {\n        wallet = accounts.wallet[from];\n\n        // is account given\n    } else if (_.isObject(from) && from.address && from.privateKey) {\n        wallet = from;\n\n        // search in wallet for address\n    } else {\n        wallet = accounts.wallet[from.toLowerCase()];\n    }\n\n    return wallet;\n};\n\nMethod.prototype.buildCall = function() {\n    var method = this,\n        isSendTx = (method.call === 'eth_sendTransaction' || method.call === 'eth_sendRawTransaction'); // || method.call === 'personal_sendTransaction'\n\n    // actual send function\n    var send = function () {\n        var defer = promiEvent(!isSendTx),\n            payload = method.toPayload(Array.prototype.slice.call(arguments));\n\n\n        // CALLBACK function\n        var sendTxCallback = function (err, result) {\n            try {\n                result = method.formatOutput(result);\n            } catch(e) {\n                err = e;\n            }\n\n            if (result instanceof Error) {\n                err = result;\n            }\n\n            if (!err) {\n                if (payload.callback) {\n                    payload.callback(null, result);\n                }\n            } else {\n                if(err.error) {\n                    err = err.error;\n                }\n\n                return utils._fireError(err, defer.eventEmitter, defer.reject, payload.callback);\n            }\n\n            // return PROMISE\n            if (!isSendTx) {\n\n                if (!err) {\n                    defer.resolve(result);\n\n                }\n\n                // return PROMIEVENT\n            } else {\n                defer.eventEmitter.emit('transactionHash', result);\n\n                method._confirmTransaction(defer, result, payload);\n            }\n\n        };\n\n        // SENDS the SIGNED SIGNATURE\n        var sendSignedTx = function(sign){\n\n            var signedPayload = _.extend({}, payload, {\n                method: 'eth_sendRawTransaction',\n                params: [sign.rawTransaction]\n            });\n\n            method.requestManager.send(signedPayload, sendTxCallback);\n        };\n\n\n        var sendRequest = function(payload, method) {\n\n            if (method && method.accounts && method.accounts.wallet && method.accounts.wallet.length) {\n                var wallet;\n\n                // ETH_SENDTRANSACTION\n                if (payload.method === 'eth_sendTransaction') {\n                    var tx = payload.params[0];\n                    wallet = getWallet((_.isObject(tx)) ? tx.from : null, method.accounts);\n\n\n                    // If wallet was found, sign tx, and send using sendRawTransaction\n                    if (wallet && wallet.privateKey) {\n                        return method.accounts.signTransaction(_.omit(tx, 'from'), wallet.privateKey).then(sendSignedTx);\n                    }\n\n                    // ETH_SIGN\n                } else if (payload.method === 'eth_sign') {\n                    var data = payload.params[1];\n                    wallet = getWallet(payload.params[0], method.accounts);\n\n                    // If wallet was found, sign tx, and send using sendRawTransaction\n                    if (wallet && wallet.privateKey) {\n                        var sign = method.accounts.sign(data, wallet.privateKey);\n\n                        if (payload.callback) {\n                            payload.callback(null, sign.signature);\n                        }\n\n                        defer.resolve(sign.signature);\n                        return;\n                    }\n\n\n                }\n            }\n\n            return method.requestManager.send(payload, sendTxCallback);\n        };\n\n        // Send the actual transaction\n        if(isSendTx && _.isObject(payload.params[0]) && typeof payload.params[0].gasPrice === 'undefined') {\n\n            var getGasPrice = (new Method({\n                name: 'getGasPrice',\n                call: 'eth_gasPrice',\n                params: 0\n            })).createFunction(method.requestManager);\n\n            getGasPrice(function (err, gasPrice) {\n\n                if (gasPrice) {\n                    payload.params[0].gasPrice = gasPrice;\n                }\n                sendRequest(payload, method);\n            });\n\n        } else {\n            sendRequest(payload, method);\n        }\n\n\n        return defer.eventEmitter;\n    };\n\n    // necessary to attach things to the method\n    send.method = method;\n    // necessary for batch requests\n    send.request = this.request.bind(this);\n    return send;\n};\n\n/**\n * Should be called to create the pure JSONRPC request which can be used in a batch request\n *\n * @method request\n * @return {Object} jsonrpc request\n */\nMethod.prototype.request = function () {\n    var payload = this.toPayload(Array.prototype.slice.call(arguments));\n    payload.format = this.formatOutput.bind(this);\n    return payload;\n};\n\nmodule.exports = Method;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}